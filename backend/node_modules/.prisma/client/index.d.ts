
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ProgramStudi
 * 
 */
export type ProgramStudi = $Result.DefaultSelection<Prisma.$ProgramStudiPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Kurikulum
 * 
 */
export type Kurikulum = $Result.DefaultSelection<Prisma.$KurikulumPayload>
/**
 * Model MataKuliah
 * 
 */
export type MataKuliah = $Result.DefaultSelection<Prisma.$MataKuliahPayload>
/**
 * Model PIGroup
 * 
 */
export type PIGroup = $Result.DefaultSelection<Prisma.$PIGroupPayload>
/**
 * Model PerformanceIndicator
 * 
 */
export type PerformanceIndicator = $Result.DefaultSelection<Prisma.$PerformanceIndicatorPayload>
/**
 * Model CPL
 * 
 */
export type CPL = $Result.DefaultSelection<Prisma.$CPLPayload>
/**
 * Model TahunAjaran
 * 
 */
export type TahunAjaran = $Result.DefaultSelection<Prisma.$TahunAjaranPayload>
/**
 * Model Kelas
 * 
 */
export type Kelas = $Result.DefaultSelection<Prisma.$KelasPayload>
/**
 * Model DosenPengampu
 * 
 */
export type DosenPengampu = $Result.DefaultSelection<Prisma.$DosenPengampuPayload>
/**
 * Model PesertaKelas
 * 
 */
export type PesertaKelas = $Result.DefaultSelection<Prisma.$PesertaKelasPayload>
/**
 * Model RPS
 * 
 */
export type RPS = $Result.DefaultSelection<Prisma.$RPSPayload>
/**
 * Model CPMK
 * 
 */
export type CPMK = $Result.DefaultSelection<Prisma.$CPMKPayload>
/**
 * Model CPMK_PI_Map
 * 
 */
export type CPMK_PI_Map = $Result.DefaultSelection<Prisma.$CPMK_PI_MapPayload>
/**
 * Model KomponenPenilaian
 * 
 */
export type KomponenPenilaian = $Result.DefaultSelection<Prisma.$KomponenPenilaianPayload>
/**
 * Model Nilai
 * 
 */
export type Nilai = $Result.DefaultSelection<Prisma.$NilaiPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  DOSEN: 'DOSEN',
  MAHASISWA: 'MAHASISWA'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const Semester: {
  GANJIL: 'GANJIL',
  GENAP: 'GENAP'
};

export type Semester = (typeof Semester)[keyof typeof Semester]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type Semester = $Enums.Semester

export const Semester: typeof $Enums.Semester

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more ProgramStudis
 * const programStudis = await prisma.programStudi.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more ProgramStudis
   * const programStudis = await prisma.programStudi.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.programStudi`: Exposes CRUD operations for the **ProgramStudi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramStudis
    * const programStudis = await prisma.programStudi.findMany()
    * ```
    */
  get programStudi(): Prisma.ProgramStudiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kurikulum`: Exposes CRUD operations for the **Kurikulum** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kurikulums
    * const kurikulums = await prisma.kurikulum.findMany()
    * ```
    */
  get kurikulum(): Prisma.KurikulumDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mataKuliah`: Exposes CRUD operations for the **MataKuliah** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MataKuliahs
    * const mataKuliahs = await prisma.mataKuliah.findMany()
    * ```
    */
  get mataKuliah(): Prisma.MataKuliahDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pIGroup`: Exposes CRUD operations for the **PIGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PIGroups
    * const pIGroups = await prisma.pIGroup.findMany()
    * ```
    */
  get pIGroup(): Prisma.PIGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performanceIndicator`: Exposes CRUD operations for the **PerformanceIndicator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceIndicators
    * const performanceIndicators = await prisma.performanceIndicator.findMany()
    * ```
    */
  get performanceIndicator(): Prisma.PerformanceIndicatorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cPL`: Exposes CRUD operations for the **CPL** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CPLS
    * const cPLS = await prisma.cPL.findMany()
    * ```
    */
  get cPL(): Prisma.CPLDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tahunAjaran`: Exposes CRUD operations for the **TahunAjaran** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TahunAjarans
    * const tahunAjarans = await prisma.tahunAjaran.findMany()
    * ```
    */
  get tahunAjaran(): Prisma.TahunAjaranDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kelas`: Exposes CRUD operations for the **Kelas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kelas
    * const kelas = await prisma.kelas.findMany()
    * ```
    */
  get kelas(): Prisma.KelasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dosenPengampu`: Exposes CRUD operations for the **DosenPengampu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DosenPengampus
    * const dosenPengampus = await prisma.dosenPengampu.findMany()
    * ```
    */
  get dosenPengampu(): Prisma.DosenPengampuDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pesertaKelas`: Exposes CRUD operations for the **PesertaKelas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PesertaKelas
    * const pesertaKelas = await prisma.pesertaKelas.findMany()
    * ```
    */
  get pesertaKelas(): Prisma.PesertaKelasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rPS`: Exposes CRUD operations for the **RPS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RPS
    * const rPS = await prisma.rPS.findMany()
    * ```
    */
  get rPS(): Prisma.RPSDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cPMK`: Exposes CRUD operations for the **CPMK** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CPMKS
    * const cPMKS = await prisma.cPMK.findMany()
    * ```
    */
  get cPMK(): Prisma.CPMKDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cPMK_PI_Map`: Exposes CRUD operations for the **CPMK_PI_Map** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CPMK_PI_Maps
    * const cPMK_PI_Maps = await prisma.cPMK_PI_Map.findMany()
    * ```
    */
  get cPMK_PI_Map(): Prisma.CPMK_PI_MapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.komponenPenilaian`: Exposes CRUD operations for the **KomponenPenilaian** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KomponenPenilaians
    * const komponenPenilaians = await prisma.komponenPenilaian.findMany()
    * ```
    */
  get komponenPenilaian(): Prisma.KomponenPenilaianDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nilai`: Exposes CRUD operations for the **Nilai** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nilais
    * const nilais = await prisma.nilai.findMany()
    * ```
    */
  get nilai(): Prisma.NilaiDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ProgramStudi: 'ProgramStudi',
    User: 'User',
    Kurikulum: 'Kurikulum',
    MataKuliah: 'MataKuliah',
    PIGroup: 'PIGroup',
    PerformanceIndicator: 'PerformanceIndicator',
    CPL: 'CPL',
    TahunAjaran: 'TahunAjaran',
    Kelas: 'Kelas',
    DosenPengampu: 'DosenPengampu',
    PesertaKelas: 'PesertaKelas',
    RPS: 'RPS',
    CPMK: 'CPMK',
    CPMK_PI_Map: 'CPMK_PI_Map',
    KomponenPenilaian: 'KomponenPenilaian',
    Nilai: 'Nilai'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "programStudi" | "user" | "kurikulum" | "mataKuliah" | "pIGroup" | "performanceIndicator" | "cPL" | "tahunAjaran" | "kelas" | "dosenPengampu" | "pesertaKelas" | "rPS" | "cPMK" | "cPMK_PI_Map" | "komponenPenilaian" | "nilai"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      ProgramStudi: {
        payload: Prisma.$ProgramStudiPayload<ExtArgs>
        fields: Prisma.ProgramStudiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramStudiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramStudiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramStudiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramStudiPayload>
          }
          findFirst: {
            args: Prisma.ProgramStudiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramStudiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramStudiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramStudiPayload>
          }
          findMany: {
            args: Prisma.ProgramStudiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramStudiPayload>[]
          }
          create: {
            args: Prisma.ProgramStudiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramStudiPayload>
          }
          createMany: {
            args: Prisma.ProgramStudiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramStudiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramStudiPayload>[]
          }
          delete: {
            args: Prisma.ProgramStudiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramStudiPayload>
          }
          update: {
            args: Prisma.ProgramStudiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramStudiPayload>
          }
          deleteMany: {
            args: Prisma.ProgramStudiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramStudiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgramStudiUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramStudiPayload>[]
          }
          upsert: {
            args: Prisma.ProgramStudiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramStudiPayload>
          }
          aggregate: {
            args: Prisma.ProgramStudiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramStudi>
          }
          groupBy: {
            args: Prisma.ProgramStudiGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramStudiGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramStudiCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramStudiCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Kurikulum: {
        payload: Prisma.$KurikulumPayload<ExtArgs>
        fields: Prisma.KurikulumFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KurikulumFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KurikulumPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KurikulumFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KurikulumPayload>
          }
          findFirst: {
            args: Prisma.KurikulumFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KurikulumPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KurikulumFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KurikulumPayload>
          }
          findMany: {
            args: Prisma.KurikulumFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KurikulumPayload>[]
          }
          create: {
            args: Prisma.KurikulumCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KurikulumPayload>
          }
          createMany: {
            args: Prisma.KurikulumCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KurikulumCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KurikulumPayload>[]
          }
          delete: {
            args: Prisma.KurikulumDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KurikulumPayload>
          }
          update: {
            args: Prisma.KurikulumUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KurikulumPayload>
          }
          deleteMany: {
            args: Prisma.KurikulumDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KurikulumUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KurikulumUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KurikulumPayload>[]
          }
          upsert: {
            args: Prisma.KurikulumUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KurikulumPayload>
          }
          aggregate: {
            args: Prisma.KurikulumAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKurikulum>
          }
          groupBy: {
            args: Prisma.KurikulumGroupByArgs<ExtArgs>
            result: $Utils.Optional<KurikulumGroupByOutputType>[]
          }
          count: {
            args: Prisma.KurikulumCountArgs<ExtArgs>
            result: $Utils.Optional<KurikulumCountAggregateOutputType> | number
          }
        }
      }
      MataKuliah: {
        payload: Prisma.$MataKuliahPayload<ExtArgs>
        fields: Prisma.MataKuliahFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MataKuliahFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MataKuliahPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MataKuliahFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MataKuliahPayload>
          }
          findFirst: {
            args: Prisma.MataKuliahFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MataKuliahPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MataKuliahFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MataKuliahPayload>
          }
          findMany: {
            args: Prisma.MataKuliahFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MataKuliahPayload>[]
          }
          create: {
            args: Prisma.MataKuliahCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MataKuliahPayload>
          }
          createMany: {
            args: Prisma.MataKuliahCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MataKuliahCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MataKuliahPayload>[]
          }
          delete: {
            args: Prisma.MataKuliahDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MataKuliahPayload>
          }
          update: {
            args: Prisma.MataKuliahUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MataKuliahPayload>
          }
          deleteMany: {
            args: Prisma.MataKuliahDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MataKuliahUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MataKuliahUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MataKuliahPayload>[]
          }
          upsert: {
            args: Prisma.MataKuliahUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MataKuliahPayload>
          }
          aggregate: {
            args: Prisma.MataKuliahAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMataKuliah>
          }
          groupBy: {
            args: Prisma.MataKuliahGroupByArgs<ExtArgs>
            result: $Utils.Optional<MataKuliahGroupByOutputType>[]
          }
          count: {
            args: Prisma.MataKuliahCountArgs<ExtArgs>
            result: $Utils.Optional<MataKuliahCountAggregateOutputType> | number
          }
        }
      }
      PIGroup: {
        payload: Prisma.$PIGroupPayload<ExtArgs>
        fields: Prisma.PIGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PIGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PIGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PIGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PIGroupPayload>
          }
          findFirst: {
            args: Prisma.PIGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PIGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PIGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PIGroupPayload>
          }
          findMany: {
            args: Prisma.PIGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PIGroupPayload>[]
          }
          create: {
            args: Prisma.PIGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PIGroupPayload>
          }
          createMany: {
            args: Prisma.PIGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PIGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PIGroupPayload>[]
          }
          delete: {
            args: Prisma.PIGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PIGroupPayload>
          }
          update: {
            args: Prisma.PIGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PIGroupPayload>
          }
          deleteMany: {
            args: Prisma.PIGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PIGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PIGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PIGroupPayload>[]
          }
          upsert: {
            args: Prisma.PIGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PIGroupPayload>
          }
          aggregate: {
            args: Prisma.PIGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePIGroup>
          }
          groupBy: {
            args: Prisma.PIGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<PIGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.PIGroupCountArgs<ExtArgs>
            result: $Utils.Optional<PIGroupCountAggregateOutputType> | number
          }
        }
      }
      PerformanceIndicator: {
        payload: Prisma.$PerformanceIndicatorPayload<ExtArgs>
        fields: Prisma.PerformanceIndicatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceIndicatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceIndicatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceIndicatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceIndicatorPayload>
          }
          findFirst: {
            args: Prisma.PerformanceIndicatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceIndicatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceIndicatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceIndicatorPayload>
          }
          findMany: {
            args: Prisma.PerformanceIndicatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceIndicatorPayload>[]
          }
          create: {
            args: Prisma.PerformanceIndicatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceIndicatorPayload>
          }
          createMany: {
            args: Prisma.PerformanceIndicatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerformanceIndicatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceIndicatorPayload>[]
          }
          delete: {
            args: Prisma.PerformanceIndicatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceIndicatorPayload>
          }
          update: {
            args: Prisma.PerformanceIndicatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceIndicatorPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceIndicatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceIndicatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PerformanceIndicatorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceIndicatorPayload>[]
          }
          upsert: {
            args: Prisma.PerformanceIndicatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceIndicatorPayload>
          }
          aggregate: {
            args: Prisma.PerformanceIndicatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceIndicator>
          }
          groupBy: {
            args: Prisma.PerformanceIndicatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceIndicatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceIndicatorCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceIndicatorCountAggregateOutputType> | number
          }
        }
      }
      CPL: {
        payload: Prisma.$CPLPayload<ExtArgs>
        fields: Prisma.CPLFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CPLFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPLPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CPLFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPLPayload>
          }
          findFirst: {
            args: Prisma.CPLFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPLPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CPLFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPLPayload>
          }
          findMany: {
            args: Prisma.CPLFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPLPayload>[]
          }
          create: {
            args: Prisma.CPLCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPLPayload>
          }
          createMany: {
            args: Prisma.CPLCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CPLCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPLPayload>[]
          }
          delete: {
            args: Prisma.CPLDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPLPayload>
          }
          update: {
            args: Prisma.CPLUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPLPayload>
          }
          deleteMany: {
            args: Prisma.CPLDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CPLUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CPLUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPLPayload>[]
          }
          upsert: {
            args: Prisma.CPLUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPLPayload>
          }
          aggregate: {
            args: Prisma.CPLAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCPL>
          }
          groupBy: {
            args: Prisma.CPLGroupByArgs<ExtArgs>
            result: $Utils.Optional<CPLGroupByOutputType>[]
          }
          count: {
            args: Prisma.CPLCountArgs<ExtArgs>
            result: $Utils.Optional<CPLCountAggregateOutputType> | number
          }
        }
      }
      TahunAjaran: {
        payload: Prisma.$TahunAjaranPayload<ExtArgs>
        fields: Prisma.TahunAjaranFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TahunAjaranFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahunAjaranPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TahunAjaranFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahunAjaranPayload>
          }
          findFirst: {
            args: Prisma.TahunAjaranFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahunAjaranPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TahunAjaranFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahunAjaranPayload>
          }
          findMany: {
            args: Prisma.TahunAjaranFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahunAjaranPayload>[]
          }
          create: {
            args: Prisma.TahunAjaranCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahunAjaranPayload>
          }
          createMany: {
            args: Prisma.TahunAjaranCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TahunAjaranCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahunAjaranPayload>[]
          }
          delete: {
            args: Prisma.TahunAjaranDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahunAjaranPayload>
          }
          update: {
            args: Prisma.TahunAjaranUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahunAjaranPayload>
          }
          deleteMany: {
            args: Prisma.TahunAjaranDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TahunAjaranUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TahunAjaranUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahunAjaranPayload>[]
          }
          upsert: {
            args: Prisma.TahunAjaranUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahunAjaranPayload>
          }
          aggregate: {
            args: Prisma.TahunAjaranAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTahunAjaran>
          }
          groupBy: {
            args: Prisma.TahunAjaranGroupByArgs<ExtArgs>
            result: $Utils.Optional<TahunAjaranGroupByOutputType>[]
          }
          count: {
            args: Prisma.TahunAjaranCountArgs<ExtArgs>
            result: $Utils.Optional<TahunAjaranCountAggregateOutputType> | number
          }
        }
      }
      Kelas: {
        payload: Prisma.$KelasPayload<ExtArgs>
        fields: Prisma.KelasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KelasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KelasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KelasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KelasPayload>
          }
          findFirst: {
            args: Prisma.KelasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KelasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KelasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KelasPayload>
          }
          findMany: {
            args: Prisma.KelasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KelasPayload>[]
          }
          create: {
            args: Prisma.KelasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KelasPayload>
          }
          createMany: {
            args: Prisma.KelasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KelasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KelasPayload>[]
          }
          delete: {
            args: Prisma.KelasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KelasPayload>
          }
          update: {
            args: Prisma.KelasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KelasPayload>
          }
          deleteMany: {
            args: Prisma.KelasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KelasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KelasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KelasPayload>[]
          }
          upsert: {
            args: Prisma.KelasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KelasPayload>
          }
          aggregate: {
            args: Prisma.KelasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKelas>
          }
          groupBy: {
            args: Prisma.KelasGroupByArgs<ExtArgs>
            result: $Utils.Optional<KelasGroupByOutputType>[]
          }
          count: {
            args: Prisma.KelasCountArgs<ExtArgs>
            result: $Utils.Optional<KelasCountAggregateOutputType> | number
          }
        }
      }
      DosenPengampu: {
        payload: Prisma.$DosenPengampuPayload<ExtArgs>
        fields: Prisma.DosenPengampuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DosenPengampuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosenPengampuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DosenPengampuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosenPengampuPayload>
          }
          findFirst: {
            args: Prisma.DosenPengampuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosenPengampuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DosenPengampuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosenPengampuPayload>
          }
          findMany: {
            args: Prisma.DosenPengampuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosenPengampuPayload>[]
          }
          create: {
            args: Prisma.DosenPengampuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosenPengampuPayload>
          }
          createMany: {
            args: Prisma.DosenPengampuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DosenPengampuCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosenPengampuPayload>[]
          }
          delete: {
            args: Prisma.DosenPengampuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosenPengampuPayload>
          }
          update: {
            args: Prisma.DosenPengampuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosenPengampuPayload>
          }
          deleteMany: {
            args: Prisma.DosenPengampuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DosenPengampuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DosenPengampuUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosenPengampuPayload>[]
          }
          upsert: {
            args: Prisma.DosenPengampuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DosenPengampuPayload>
          }
          aggregate: {
            args: Prisma.DosenPengampuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDosenPengampu>
          }
          groupBy: {
            args: Prisma.DosenPengampuGroupByArgs<ExtArgs>
            result: $Utils.Optional<DosenPengampuGroupByOutputType>[]
          }
          count: {
            args: Prisma.DosenPengampuCountArgs<ExtArgs>
            result: $Utils.Optional<DosenPengampuCountAggregateOutputType> | number
          }
        }
      }
      PesertaKelas: {
        payload: Prisma.$PesertaKelasPayload<ExtArgs>
        fields: Prisma.PesertaKelasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PesertaKelasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PesertaKelasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PesertaKelasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PesertaKelasPayload>
          }
          findFirst: {
            args: Prisma.PesertaKelasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PesertaKelasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PesertaKelasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PesertaKelasPayload>
          }
          findMany: {
            args: Prisma.PesertaKelasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PesertaKelasPayload>[]
          }
          create: {
            args: Prisma.PesertaKelasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PesertaKelasPayload>
          }
          createMany: {
            args: Prisma.PesertaKelasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PesertaKelasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PesertaKelasPayload>[]
          }
          delete: {
            args: Prisma.PesertaKelasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PesertaKelasPayload>
          }
          update: {
            args: Prisma.PesertaKelasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PesertaKelasPayload>
          }
          deleteMany: {
            args: Prisma.PesertaKelasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PesertaKelasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PesertaKelasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PesertaKelasPayload>[]
          }
          upsert: {
            args: Prisma.PesertaKelasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PesertaKelasPayload>
          }
          aggregate: {
            args: Prisma.PesertaKelasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePesertaKelas>
          }
          groupBy: {
            args: Prisma.PesertaKelasGroupByArgs<ExtArgs>
            result: $Utils.Optional<PesertaKelasGroupByOutputType>[]
          }
          count: {
            args: Prisma.PesertaKelasCountArgs<ExtArgs>
            result: $Utils.Optional<PesertaKelasCountAggregateOutputType> | number
          }
        }
      }
      RPS: {
        payload: Prisma.$RPSPayload<ExtArgs>
        fields: Prisma.RPSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RPSFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RPSFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPSPayload>
          }
          findFirst: {
            args: Prisma.RPSFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RPSFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPSPayload>
          }
          findMany: {
            args: Prisma.RPSFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPSPayload>[]
          }
          create: {
            args: Prisma.RPSCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPSPayload>
          }
          createMany: {
            args: Prisma.RPSCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RPSCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPSPayload>[]
          }
          delete: {
            args: Prisma.RPSDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPSPayload>
          }
          update: {
            args: Prisma.RPSUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPSPayload>
          }
          deleteMany: {
            args: Prisma.RPSDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RPSUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RPSUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPSPayload>[]
          }
          upsert: {
            args: Prisma.RPSUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RPSPayload>
          }
          aggregate: {
            args: Prisma.RPSAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRPS>
          }
          groupBy: {
            args: Prisma.RPSGroupByArgs<ExtArgs>
            result: $Utils.Optional<RPSGroupByOutputType>[]
          }
          count: {
            args: Prisma.RPSCountArgs<ExtArgs>
            result: $Utils.Optional<RPSCountAggregateOutputType> | number
          }
        }
      }
      CPMK: {
        payload: Prisma.$CPMKPayload<ExtArgs>
        fields: Prisma.CPMKFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CPMKFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMKPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CPMKFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMKPayload>
          }
          findFirst: {
            args: Prisma.CPMKFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMKPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CPMKFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMKPayload>
          }
          findMany: {
            args: Prisma.CPMKFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMKPayload>[]
          }
          create: {
            args: Prisma.CPMKCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMKPayload>
          }
          createMany: {
            args: Prisma.CPMKCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CPMKCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMKPayload>[]
          }
          delete: {
            args: Prisma.CPMKDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMKPayload>
          }
          update: {
            args: Prisma.CPMKUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMKPayload>
          }
          deleteMany: {
            args: Prisma.CPMKDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CPMKUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CPMKUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMKPayload>[]
          }
          upsert: {
            args: Prisma.CPMKUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMKPayload>
          }
          aggregate: {
            args: Prisma.CPMKAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCPMK>
          }
          groupBy: {
            args: Prisma.CPMKGroupByArgs<ExtArgs>
            result: $Utils.Optional<CPMKGroupByOutputType>[]
          }
          count: {
            args: Prisma.CPMKCountArgs<ExtArgs>
            result: $Utils.Optional<CPMKCountAggregateOutputType> | number
          }
        }
      }
      CPMK_PI_Map: {
        payload: Prisma.$CPMK_PI_MapPayload<ExtArgs>
        fields: Prisma.CPMK_PI_MapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CPMK_PI_MapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMK_PI_MapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CPMK_PI_MapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMK_PI_MapPayload>
          }
          findFirst: {
            args: Prisma.CPMK_PI_MapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMK_PI_MapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CPMK_PI_MapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMK_PI_MapPayload>
          }
          findMany: {
            args: Prisma.CPMK_PI_MapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMK_PI_MapPayload>[]
          }
          create: {
            args: Prisma.CPMK_PI_MapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMK_PI_MapPayload>
          }
          createMany: {
            args: Prisma.CPMK_PI_MapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CPMK_PI_MapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMK_PI_MapPayload>[]
          }
          delete: {
            args: Prisma.CPMK_PI_MapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMK_PI_MapPayload>
          }
          update: {
            args: Prisma.CPMK_PI_MapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMK_PI_MapPayload>
          }
          deleteMany: {
            args: Prisma.CPMK_PI_MapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CPMK_PI_MapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CPMK_PI_MapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMK_PI_MapPayload>[]
          }
          upsert: {
            args: Prisma.CPMK_PI_MapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMK_PI_MapPayload>
          }
          aggregate: {
            args: Prisma.CPMK_PI_MapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCPMK_PI_Map>
          }
          groupBy: {
            args: Prisma.CPMK_PI_MapGroupByArgs<ExtArgs>
            result: $Utils.Optional<CPMK_PI_MapGroupByOutputType>[]
          }
          count: {
            args: Prisma.CPMK_PI_MapCountArgs<ExtArgs>
            result: $Utils.Optional<CPMK_PI_MapCountAggregateOutputType> | number
          }
        }
      }
      KomponenPenilaian: {
        payload: Prisma.$KomponenPenilaianPayload<ExtArgs>
        fields: Prisma.KomponenPenilaianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KomponenPenilaianFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomponenPenilaianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KomponenPenilaianFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomponenPenilaianPayload>
          }
          findFirst: {
            args: Prisma.KomponenPenilaianFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomponenPenilaianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KomponenPenilaianFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomponenPenilaianPayload>
          }
          findMany: {
            args: Prisma.KomponenPenilaianFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomponenPenilaianPayload>[]
          }
          create: {
            args: Prisma.KomponenPenilaianCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomponenPenilaianPayload>
          }
          createMany: {
            args: Prisma.KomponenPenilaianCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KomponenPenilaianCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomponenPenilaianPayload>[]
          }
          delete: {
            args: Prisma.KomponenPenilaianDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomponenPenilaianPayload>
          }
          update: {
            args: Prisma.KomponenPenilaianUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomponenPenilaianPayload>
          }
          deleteMany: {
            args: Prisma.KomponenPenilaianDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KomponenPenilaianUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KomponenPenilaianUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomponenPenilaianPayload>[]
          }
          upsert: {
            args: Prisma.KomponenPenilaianUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomponenPenilaianPayload>
          }
          aggregate: {
            args: Prisma.KomponenPenilaianAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKomponenPenilaian>
          }
          groupBy: {
            args: Prisma.KomponenPenilaianGroupByArgs<ExtArgs>
            result: $Utils.Optional<KomponenPenilaianGroupByOutputType>[]
          }
          count: {
            args: Prisma.KomponenPenilaianCountArgs<ExtArgs>
            result: $Utils.Optional<KomponenPenilaianCountAggregateOutputType> | number
          }
        }
      }
      Nilai: {
        payload: Prisma.$NilaiPayload<ExtArgs>
        fields: Prisma.NilaiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NilaiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NilaiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NilaiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NilaiPayload>
          }
          findFirst: {
            args: Prisma.NilaiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NilaiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NilaiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NilaiPayload>
          }
          findMany: {
            args: Prisma.NilaiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NilaiPayload>[]
          }
          create: {
            args: Prisma.NilaiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NilaiPayload>
          }
          createMany: {
            args: Prisma.NilaiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NilaiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NilaiPayload>[]
          }
          delete: {
            args: Prisma.NilaiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NilaiPayload>
          }
          update: {
            args: Prisma.NilaiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NilaiPayload>
          }
          deleteMany: {
            args: Prisma.NilaiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NilaiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NilaiUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NilaiPayload>[]
          }
          upsert: {
            args: Prisma.NilaiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NilaiPayload>
          }
          aggregate: {
            args: Prisma.NilaiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNilai>
          }
          groupBy: {
            args: Prisma.NilaiGroupByArgs<ExtArgs>
            result: $Utils.Optional<NilaiGroupByOutputType>[]
          }
          count: {
            args: Prisma.NilaiCountArgs<ExtArgs>
            result: $Utils.Optional<NilaiCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    programStudi?: ProgramStudiOmit
    user?: UserOmit
    kurikulum?: KurikulumOmit
    mataKuliah?: MataKuliahOmit
    pIGroup?: PIGroupOmit
    performanceIndicator?: PerformanceIndicatorOmit
    cPL?: CPLOmit
    tahunAjaran?: TahunAjaranOmit
    kelas?: KelasOmit
    dosenPengampu?: DosenPengampuOmit
    pesertaKelas?: PesertaKelasOmit
    rPS?: RPSOmit
    cPMK?: CPMKOmit
    cPMK_PI_Map?: CPMK_PI_MapOmit
    komponenPenilaian?: KomponenPenilaianOmit
    nilai?: NilaiOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProgramStudiCountOutputType
   */

  export type ProgramStudiCountOutputType = {
    users: number
    kurikulum: number
  }

  export type ProgramStudiCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ProgramStudiCountOutputTypeCountUsersArgs
    kurikulum?: boolean | ProgramStudiCountOutputTypeCountKurikulumArgs
  }

  // Custom InputTypes
  /**
   * ProgramStudiCountOutputType without action
   */
  export type ProgramStudiCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramStudiCountOutputType
     */
    select?: ProgramStudiCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramStudiCountOutputType without action
   */
  export type ProgramStudiCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ProgramStudiCountOutputType without action
   */
  export type ProgramStudiCountOutputTypeCountKurikulumArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KurikulumWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    dosenPengampu: number
    pesertaKelas: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dosenPengampu?: boolean | UserCountOutputTypeCountDosenPengampuArgs
    pesertaKelas?: boolean | UserCountOutputTypeCountPesertaKelasArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDosenPengampuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DosenPengampuWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPesertaKelasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PesertaKelasWhereInput
  }


  /**
   * Count Type KurikulumCountOutputType
   */

  export type KurikulumCountOutputType = {
    mataKuliah: number
    cpl: number
    piGroups: number
  }

  export type KurikulumCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mataKuliah?: boolean | KurikulumCountOutputTypeCountMataKuliahArgs
    cpl?: boolean | KurikulumCountOutputTypeCountCplArgs
    piGroups?: boolean | KurikulumCountOutputTypeCountPiGroupsArgs
  }

  // Custom InputTypes
  /**
   * KurikulumCountOutputType without action
   */
  export type KurikulumCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurikulumCountOutputType
     */
    select?: KurikulumCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KurikulumCountOutputType without action
   */
  export type KurikulumCountOutputTypeCountMataKuliahArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MataKuliahWhereInput
  }

  /**
   * KurikulumCountOutputType without action
   */
  export type KurikulumCountOutputTypeCountCplArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CPLWhereInput
  }

  /**
   * KurikulumCountOutputType without action
   */
  export type KurikulumCountOutputTypeCountPiGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PIGroupWhereInput
  }


  /**
   * Count Type MataKuliahCountOutputType
   */

  export type MataKuliahCountOutputType = {
    kelas: number
  }

  export type MataKuliahCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kelas?: boolean | MataKuliahCountOutputTypeCountKelasArgs
  }

  // Custom InputTypes
  /**
   * MataKuliahCountOutputType without action
   */
  export type MataKuliahCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MataKuliahCountOutputType
     */
    select?: MataKuliahCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MataKuliahCountOutputType without action
   */
  export type MataKuliahCountOutputTypeCountKelasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KelasWhereInput
  }


  /**
   * Count Type PIGroupCountOutputType
   */

  export type PIGroupCountOutputType = {
    indicators: number
    cpl: number
  }

  export type PIGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicators?: boolean | PIGroupCountOutputTypeCountIndicatorsArgs
    cpl?: boolean | PIGroupCountOutputTypeCountCplArgs
  }

  // Custom InputTypes
  /**
   * PIGroupCountOutputType without action
   */
  export type PIGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PIGroupCountOutputType
     */
    select?: PIGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PIGroupCountOutputType without action
   */
  export type PIGroupCountOutputTypeCountIndicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceIndicatorWhereInput
  }

  /**
   * PIGroupCountOutputType without action
   */
  export type PIGroupCountOutputTypeCountCplArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CPLWhereInput
  }


  /**
   * Count Type PerformanceIndicatorCountOutputType
   */

  export type PerformanceIndicatorCountOutputType = {
    cpmkMap: number
  }

  export type PerformanceIndicatorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cpmkMap?: boolean | PerformanceIndicatorCountOutputTypeCountCpmkMapArgs
  }

  // Custom InputTypes
  /**
   * PerformanceIndicatorCountOutputType without action
   */
  export type PerformanceIndicatorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceIndicatorCountOutputType
     */
    select?: PerformanceIndicatorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PerformanceIndicatorCountOutputType without action
   */
  export type PerformanceIndicatorCountOutputTypeCountCpmkMapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CPMK_PI_MapWhereInput
  }


  /**
   * Count Type TahunAjaranCountOutputType
   */

  export type TahunAjaranCountOutputType = {
    kelas: number
  }

  export type TahunAjaranCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kelas?: boolean | TahunAjaranCountOutputTypeCountKelasArgs
  }

  // Custom InputTypes
  /**
   * TahunAjaranCountOutputType without action
   */
  export type TahunAjaranCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TahunAjaranCountOutputType
     */
    select?: TahunAjaranCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TahunAjaranCountOutputType without action
   */
  export type TahunAjaranCountOutputTypeCountKelasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KelasWhereInput
  }


  /**
   * Count Type KelasCountOutputType
   */

  export type KelasCountOutputType = {
    dosenPengampu: number
    pesertaKelas: number
    rps: number
    cpmk: number
  }

  export type KelasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dosenPengampu?: boolean | KelasCountOutputTypeCountDosenPengampuArgs
    pesertaKelas?: boolean | KelasCountOutputTypeCountPesertaKelasArgs
    rps?: boolean | KelasCountOutputTypeCountRpsArgs
    cpmk?: boolean | KelasCountOutputTypeCountCpmkArgs
  }

  // Custom InputTypes
  /**
   * KelasCountOutputType without action
   */
  export type KelasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KelasCountOutputType
     */
    select?: KelasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KelasCountOutputType without action
   */
  export type KelasCountOutputTypeCountDosenPengampuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DosenPengampuWhereInput
  }

  /**
   * KelasCountOutputType without action
   */
  export type KelasCountOutputTypeCountPesertaKelasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PesertaKelasWhereInput
  }

  /**
   * KelasCountOutputType without action
   */
  export type KelasCountOutputTypeCountRpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RPSWhereInput
  }

  /**
   * KelasCountOutputType without action
   */
  export type KelasCountOutputTypeCountCpmkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CPMKWhereInput
  }


  /**
   * Count Type PesertaKelasCountOutputType
   */

  export type PesertaKelasCountOutputType = {
    nilai: number
  }

  export type PesertaKelasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nilai?: boolean | PesertaKelasCountOutputTypeCountNilaiArgs
  }

  // Custom InputTypes
  /**
   * PesertaKelasCountOutputType without action
   */
  export type PesertaKelasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PesertaKelasCountOutputType
     */
    select?: PesertaKelasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PesertaKelasCountOutputType without action
   */
  export type PesertaKelasCountOutputTypeCountNilaiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NilaiWhereInput
  }


  /**
   * Count Type CPMKCountOutputType
   */

  export type CPMKCountOutputType = {
    komponenPenilaian: number
    piMap: number
  }

  export type CPMKCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    komponenPenilaian?: boolean | CPMKCountOutputTypeCountKomponenPenilaianArgs
    piMap?: boolean | CPMKCountOutputTypeCountPiMapArgs
  }

  // Custom InputTypes
  /**
   * CPMKCountOutputType without action
   */
  export type CPMKCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMKCountOutputType
     */
    select?: CPMKCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CPMKCountOutputType without action
   */
  export type CPMKCountOutputTypeCountKomponenPenilaianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KomponenPenilaianWhereInput
  }

  /**
   * CPMKCountOutputType without action
   */
  export type CPMKCountOutputTypeCountPiMapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CPMK_PI_MapWhereInput
  }


  /**
   * Count Type KomponenPenilaianCountOutputType
   */

  export type KomponenPenilaianCountOutputType = {
    nilai: number
  }

  export type KomponenPenilaianCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nilai?: boolean | KomponenPenilaianCountOutputTypeCountNilaiArgs
  }

  // Custom InputTypes
  /**
   * KomponenPenilaianCountOutputType without action
   */
  export type KomponenPenilaianCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomponenPenilaianCountOutputType
     */
    select?: KomponenPenilaianCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KomponenPenilaianCountOutputType without action
   */
  export type KomponenPenilaianCountOutputTypeCountNilaiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NilaiWhereInput
  }


  /**
   * Models
   */

  /**
   * Model ProgramStudi
   */

  export type AggregateProgramStudi = {
    _count: ProgramStudiCountAggregateOutputType | null
    _avg: ProgramStudiAvgAggregateOutputType | null
    _sum: ProgramStudiSumAggregateOutputType | null
    _min: ProgramStudiMinAggregateOutputType | null
    _max: ProgramStudiMaxAggregateOutputType | null
  }

  export type ProgramStudiAvgAggregateOutputType = {
    id: number | null
    total_sks_lulus: number | null
  }

  export type ProgramStudiSumAggregateOutputType = {
    id: number | null
    total_sks_lulus: number | null
  }

  export type ProgramStudiMinAggregateOutputType = {
    id: number | null
    nama: string | null
    jenjang: string | null
    total_sks_lulus: number | null
  }

  export type ProgramStudiMaxAggregateOutputType = {
    id: number | null
    nama: string | null
    jenjang: string | null
    total_sks_lulus: number | null
  }

  export type ProgramStudiCountAggregateOutputType = {
    id: number
    nama: number
    jenjang: number
    total_sks_lulus: number
    _all: number
  }


  export type ProgramStudiAvgAggregateInputType = {
    id?: true
    total_sks_lulus?: true
  }

  export type ProgramStudiSumAggregateInputType = {
    id?: true
    total_sks_lulus?: true
  }

  export type ProgramStudiMinAggregateInputType = {
    id?: true
    nama?: true
    jenjang?: true
    total_sks_lulus?: true
  }

  export type ProgramStudiMaxAggregateInputType = {
    id?: true
    nama?: true
    jenjang?: true
    total_sks_lulus?: true
  }

  export type ProgramStudiCountAggregateInputType = {
    id?: true
    nama?: true
    jenjang?: true
    total_sks_lulus?: true
    _all?: true
  }

  export type ProgramStudiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramStudi to aggregate.
     */
    where?: ProgramStudiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramStudis to fetch.
     */
    orderBy?: ProgramStudiOrderByWithRelationInput | ProgramStudiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramStudiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramStudis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramStudis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramStudis
    **/
    _count?: true | ProgramStudiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramStudiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramStudiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramStudiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramStudiMaxAggregateInputType
  }

  export type GetProgramStudiAggregateType<T extends ProgramStudiAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramStudi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramStudi[P]>
      : GetScalarType<T[P], AggregateProgramStudi[P]>
  }




  export type ProgramStudiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramStudiWhereInput
    orderBy?: ProgramStudiOrderByWithAggregationInput | ProgramStudiOrderByWithAggregationInput[]
    by: ProgramStudiScalarFieldEnum[] | ProgramStudiScalarFieldEnum
    having?: ProgramStudiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramStudiCountAggregateInputType | true
    _avg?: ProgramStudiAvgAggregateInputType
    _sum?: ProgramStudiSumAggregateInputType
    _min?: ProgramStudiMinAggregateInputType
    _max?: ProgramStudiMaxAggregateInputType
  }

  export type ProgramStudiGroupByOutputType = {
    id: number
    nama: string
    jenjang: string
    total_sks_lulus: number
    _count: ProgramStudiCountAggregateOutputType | null
    _avg: ProgramStudiAvgAggregateOutputType | null
    _sum: ProgramStudiSumAggregateOutputType | null
    _min: ProgramStudiMinAggregateOutputType | null
    _max: ProgramStudiMaxAggregateOutputType | null
  }

  type GetProgramStudiGroupByPayload<T extends ProgramStudiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramStudiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramStudiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramStudiGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramStudiGroupByOutputType[P]>
        }
      >
    >


  export type ProgramStudiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    jenjang?: boolean
    total_sks_lulus?: boolean
    users?: boolean | ProgramStudi$usersArgs<ExtArgs>
    kurikulum?: boolean | ProgramStudi$kurikulumArgs<ExtArgs>
    _count?: boolean | ProgramStudiCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programStudi"]>

  export type ProgramStudiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    jenjang?: boolean
    total_sks_lulus?: boolean
  }, ExtArgs["result"]["programStudi"]>

  export type ProgramStudiSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    jenjang?: boolean
    total_sks_lulus?: boolean
  }, ExtArgs["result"]["programStudi"]>

  export type ProgramStudiSelectScalar = {
    id?: boolean
    nama?: boolean
    jenjang?: boolean
    total_sks_lulus?: boolean
  }

  export type ProgramStudiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nama" | "jenjang" | "total_sks_lulus", ExtArgs["result"]["programStudi"]>
  export type ProgramStudiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ProgramStudi$usersArgs<ExtArgs>
    kurikulum?: boolean | ProgramStudi$kurikulumArgs<ExtArgs>
    _count?: boolean | ProgramStudiCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProgramStudiIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProgramStudiIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProgramStudiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgramStudi"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      kurikulum: Prisma.$KurikulumPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama: string
      jenjang: string
      total_sks_lulus: number
    }, ExtArgs["result"]["programStudi"]>
    composites: {}
  }

  type ProgramStudiGetPayload<S extends boolean | null | undefined | ProgramStudiDefaultArgs> = $Result.GetResult<Prisma.$ProgramStudiPayload, S>

  type ProgramStudiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgramStudiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgramStudiCountAggregateInputType | true
    }

  export interface ProgramStudiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramStudi'], meta: { name: 'ProgramStudi' } }
    /**
     * Find zero or one ProgramStudi that matches the filter.
     * @param {ProgramStudiFindUniqueArgs} args - Arguments to find a ProgramStudi
     * @example
     * // Get one ProgramStudi
     * const programStudi = await prisma.programStudi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramStudiFindUniqueArgs>(args: SelectSubset<T, ProgramStudiFindUniqueArgs<ExtArgs>>): Prisma__ProgramStudiClient<$Result.GetResult<Prisma.$ProgramStudiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProgramStudi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgramStudiFindUniqueOrThrowArgs} args - Arguments to find a ProgramStudi
     * @example
     * // Get one ProgramStudi
     * const programStudi = await prisma.programStudi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramStudiFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramStudiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramStudiClient<$Result.GetResult<Prisma.$ProgramStudiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgramStudi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramStudiFindFirstArgs} args - Arguments to find a ProgramStudi
     * @example
     * // Get one ProgramStudi
     * const programStudi = await prisma.programStudi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramStudiFindFirstArgs>(args?: SelectSubset<T, ProgramStudiFindFirstArgs<ExtArgs>>): Prisma__ProgramStudiClient<$Result.GetResult<Prisma.$ProgramStudiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgramStudi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramStudiFindFirstOrThrowArgs} args - Arguments to find a ProgramStudi
     * @example
     * // Get one ProgramStudi
     * const programStudi = await prisma.programStudi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramStudiFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramStudiFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramStudiClient<$Result.GetResult<Prisma.$ProgramStudiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProgramStudis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramStudiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramStudis
     * const programStudis = await prisma.programStudi.findMany()
     * 
     * // Get first 10 ProgramStudis
     * const programStudis = await prisma.programStudi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programStudiWithIdOnly = await prisma.programStudi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramStudiFindManyArgs>(args?: SelectSubset<T, ProgramStudiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramStudiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProgramStudi.
     * @param {ProgramStudiCreateArgs} args - Arguments to create a ProgramStudi.
     * @example
     * // Create one ProgramStudi
     * const ProgramStudi = await prisma.programStudi.create({
     *   data: {
     *     // ... data to create a ProgramStudi
     *   }
     * })
     * 
     */
    create<T extends ProgramStudiCreateArgs>(args: SelectSubset<T, ProgramStudiCreateArgs<ExtArgs>>): Prisma__ProgramStudiClient<$Result.GetResult<Prisma.$ProgramStudiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProgramStudis.
     * @param {ProgramStudiCreateManyArgs} args - Arguments to create many ProgramStudis.
     * @example
     * // Create many ProgramStudis
     * const programStudi = await prisma.programStudi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramStudiCreateManyArgs>(args?: SelectSubset<T, ProgramStudiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgramStudis and returns the data saved in the database.
     * @param {ProgramStudiCreateManyAndReturnArgs} args - Arguments to create many ProgramStudis.
     * @example
     * // Create many ProgramStudis
     * const programStudi = await prisma.programStudi.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgramStudis and only return the `id`
     * const programStudiWithIdOnly = await prisma.programStudi.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramStudiCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramStudiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramStudiPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProgramStudi.
     * @param {ProgramStudiDeleteArgs} args - Arguments to delete one ProgramStudi.
     * @example
     * // Delete one ProgramStudi
     * const ProgramStudi = await prisma.programStudi.delete({
     *   where: {
     *     // ... filter to delete one ProgramStudi
     *   }
     * })
     * 
     */
    delete<T extends ProgramStudiDeleteArgs>(args: SelectSubset<T, ProgramStudiDeleteArgs<ExtArgs>>): Prisma__ProgramStudiClient<$Result.GetResult<Prisma.$ProgramStudiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProgramStudi.
     * @param {ProgramStudiUpdateArgs} args - Arguments to update one ProgramStudi.
     * @example
     * // Update one ProgramStudi
     * const programStudi = await prisma.programStudi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramStudiUpdateArgs>(args: SelectSubset<T, ProgramStudiUpdateArgs<ExtArgs>>): Prisma__ProgramStudiClient<$Result.GetResult<Prisma.$ProgramStudiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProgramStudis.
     * @param {ProgramStudiDeleteManyArgs} args - Arguments to filter ProgramStudis to delete.
     * @example
     * // Delete a few ProgramStudis
     * const { count } = await prisma.programStudi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramStudiDeleteManyArgs>(args?: SelectSubset<T, ProgramStudiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramStudis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramStudiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramStudis
     * const programStudi = await prisma.programStudi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramStudiUpdateManyArgs>(args: SelectSubset<T, ProgramStudiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramStudis and returns the data updated in the database.
     * @param {ProgramStudiUpdateManyAndReturnArgs} args - Arguments to update many ProgramStudis.
     * @example
     * // Update many ProgramStudis
     * const programStudi = await prisma.programStudi.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProgramStudis and only return the `id`
     * const programStudiWithIdOnly = await prisma.programStudi.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgramStudiUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgramStudiUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramStudiPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProgramStudi.
     * @param {ProgramStudiUpsertArgs} args - Arguments to update or create a ProgramStudi.
     * @example
     * // Update or create a ProgramStudi
     * const programStudi = await prisma.programStudi.upsert({
     *   create: {
     *     // ... data to create a ProgramStudi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramStudi we want to update
     *   }
     * })
     */
    upsert<T extends ProgramStudiUpsertArgs>(args: SelectSubset<T, ProgramStudiUpsertArgs<ExtArgs>>): Prisma__ProgramStudiClient<$Result.GetResult<Prisma.$ProgramStudiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProgramStudis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramStudiCountArgs} args - Arguments to filter ProgramStudis to count.
     * @example
     * // Count the number of ProgramStudis
     * const count = await prisma.programStudi.count({
     *   where: {
     *     // ... the filter for the ProgramStudis we want to count
     *   }
     * })
    **/
    count<T extends ProgramStudiCountArgs>(
      args?: Subset<T, ProgramStudiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramStudiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramStudi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramStudiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramStudiAggregateArgs>(args: Subset<T, ProgramStudiAggregateArgs>): Prisma.PrismaPromise<GetProgramStudiAggregateType<T>>

    /**
     * Group by ProgramStudi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramStudiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramStudiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramStudiGroupByArgs['orderBy'] }
        : { orderBy?: ProgramStudiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramStudiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramStudiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgramStudi model
   */
  readonly fields: ProgramStudiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramStudi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramStudiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends ProgramStudi$usersArgs<ExtArgs> = {}>(args?: Subset<T, ProgramStudi$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kurikulum<T extends ProgramStudi$kurikulumArgs<ExtArgs> = {}>(args?: Subset<T, ProgramStudi$kurikulumArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KurikulumPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgramStudi model
   */
  interface ProgramStudiFieldRefs {
    readonly id: FieldRef<"ProgramStudi", 'Int'>
    readonly nama: FieldRef<"ProgramStudi", 'String'>
    readonly jenjang: FieldRef<"ProgramStudi", 'String'>
    readonly total_sks_lulus: FieldRef<"ProgramStudi", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProgramStudi findUnique
   */
  export type ProgramStudiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramStudi
     */
    select?: ProgramStudiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramStudi
     */
    omit?: ProgramStudiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramStudiInclude<ExtArgs> | null
    /**
     * Filter, which ProgramStudi to fetch.
     */
    where: ProgramStudiWhereUniqueInput
  }

  /**
   * ProgramStudi findUniqueOrThrow
   */
  export type ProgramStudiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramStudi
     */
    select?: ProgramStudiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramStudi
     */
    omit?: ProgramStudiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramStudiInclude<ExtArgs> | null
    /**
     * Filter, which ProgramStudi to fetch.
     */
    where: ProgramStudiWhereUniqueInput
  }

  /**
   * ProgramStudi findFirst
   */
  export type ProgramStudiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramStudi
     */
    select?: ProgramStudiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramStudi
     */
    omit?: ProgramStudiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramStudiInclude<ExtArgs> | null
    /**
     * Filter, which ProgramStudi to fetch.
     */
    where?: ProgramStudiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramStudis to fetch.
     */
    orderBy?: ProgramStudiOrderByWithRelationInput | ProgramStudiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramStudis.
     */
    cursor?: ProgramStudiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramStudis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramStudis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramStudis.
     */
    distinct?: ProgramStudiScalarFieldEnum | ProgramStudiScalarFieldEnum[]
  }

  /**
   * ProgramStudi findFirstOrThrow
   */
  export type ProgramStudiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramStudi
     */
    select?: ProgramStudiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramStudi
     */
    omit?: ProgramStudiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramStudiInclude<ExtArgs> | null
    /**
     * Filter, which ProgramStudi to fetch.
     */
    where?: ProgramStudiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramStudis to fetch.
     */
    orderBy?: ProgramStudiOrderByWithRelationInput | ProgramStudiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramStudis.
     */
    cursor?: ProgramStudiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramStudis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramStudis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramStudis.
     */
    distinct?: ProgramStudiScalarFieldEnum | ProgramStudiScalarFieldEnum[]
  }

  /**
   * ProgramStudi findMany
   */
  export type ProgramStudiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramStudi
     */
    select?: ProgramStudiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramStudi
     */
    omit?: ProgramStudiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramStudiInclude<ExtArgs> | null
    /**
     * Filter, which ProgramStudis to fetch.
     */
    where?: ProgramStudiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramStudis to fetch.
     */
    orderBy?: ProgramStudiOrderByWithRelationInput | ProgramStudiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramStudis.
     */
    cursor?: ProgramStudiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramStudis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramStudis.
     */
    skip?: number
    distinct?: ProgramStudiScalarFieldEnum | ProgramStudiScalarFieldEnum[]
  }

  /**
   * ProgramStudi create
   */
  export type ProgramStudiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramStudi
     */
    select?: ProgramStudiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramStudi
     */
    omit?: ProgramStudiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramStudiInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgramStudi.
     */
    data: XOR<ProgramStudiCreateInput, ProgramStudiUncheckedCreateInput>
  }

  /**
   * ProgramStudi createMany
   */
  export type ProgramStudiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgramStudis.
     */
    data: ProgramStudiCreateManyInput | ProgramStudiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgramStudi createManyAndReturn
   */
  export type ProgramStudiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramStudi
     */
    select?: ProgramStudiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramStudi
     */
    omit?: ProgramStudiOmit<ExtArgs> | null
    /**
     * The data used to create many ProgramStudis.
     */
    data: ProgramStudiCreateManyInput | ProgramStudiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgramStudi update
   */
  export type ProgramStudiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramStudi
     */
    select?: ProgramStudiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramStudi
     */
    omit?: ProgramStudiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramStudiInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgramStudi.
     */
    data: XOR<ProgramStudiUpdateInput, ProgramStudiUncheckedUpdateInput>
    /**
     * Choose, which ProgramStudi to update.
     */
    where: ProgramStudiWhereUniqueInput
  }

  /**
   * ProgramStudi updateMany
   */
  export type ProgramStudiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgramStudis.
     */
    data: XOR<ProgramStudiUpdateManyMutationInput, ProgramStudiUncheckedUpdateManyInput>
    /**
     * Filter which ProgramStudis to update
     */
    where?: ProgramStudiWhereInput
    /**
     * Limit how many ProgramStudis to update.
     */
    limit?: number
  }

  /**
   * ProgramStudi updateManyAndReturn
   */
  export type ProgramStudiUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramStudi
     */
    select?: ProgramStudiSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramStudi
     */
    omit?: ProgramStudiOmit<ExtArgs> | null
    /**
     * The data used to update ProgramStudis.
     */
    data: XOR<ProgramStudiUpdateManyMutationInput, ProgramStudiUncheckedUpdateManyInput>
    /**
     * Filter which ProgramStudis to update
     */
    where?: ProgramStudiWhereInput
    /**
     * Limit how many ProgramStudis to update.
     */
    limit?: number
  }

  /**
   * ProgramStudi upsert
   */
  export type ProgramStudiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramStudi
     */
    select?: ProgramStudiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramStudi
     */
    omit?: ProgramStudiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramStudiInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgramStudi to update in case it exists.
     */
    where: ProgramStudiWhereUniqueInput
    /**
     * In case the ProgramStudi found by the `where` argument doesn't exist, create a new ProgramStudi with this data.
     */
    create: XOR<ProgramStudiCreateInput, ProgramStudiUncheckedCreateInput>
    /**
     * In case the ProgramStudi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramStudiUpdateInput, ProgramStudiUncheckedUpdateInput>
  }

  /**
   * ProgramStudi delete
   */
  export type ProgramStudiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramStudi
     */
    select?: ProgramStudiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramStudi
     */
    omit?: ProgramStudiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramStudiInclude<ExtArgs> | null
    /**
     * Filter which ProgramStudi to delete.
     */
    where: ProgramStudiWhereUniqueInput
  }

  /**
   * ProgramStudi deleteMany
   */
  export type ProgramStudiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramStudis to delete
     */
    where?: ProgramStudiWhereInput
    /**
     * Limit how many ProgramStudis to delete.
     */
    limit?: number
  }

  /**
   * ProgramStudi.users
   */
  export type ProgramStudi$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * ProgramStudi.kurikulum
   */
  export type ProgramStudi$kurikulumArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kurikulum
     */
    select?: KurikulumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kurikulum
     */
    omit?: KurikulumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KurikulumInclude<ExtArgs> | null
    where?: KurikulumWhereInput
    orderBy?: KurikulumOrderByWithRelationInput | KurikulumOrderByWithRelationInput[]
    cursor?: KurikulumWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KurikulumScalarFieldEnum | KurikulumScalarFieldEnum[]
  }

  /**
   * ProgramStudi without action
   */
  export type ProgramStudiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramStudi
     */
    select?: ProgramStudiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramStudi
     */
    omit?: ProgramStudiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramStudiInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    program_studi_id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    program_studi_id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password_hash: string | null
    nama: string | null
    role: $Enums.UserRole | null
    program_studi_id: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password_hash: string | null
    nama: string | null
    role: $Enums.UserRole | null
    program_studi_id: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password_hash: number
    nama: number
    role: number
    program_studi_id: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    program_studi_id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    program_studi_id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password_hash?: true
    nama?: true
    role?: true
    program_studi_id?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password_hash?: true
    nama?: true
    role?: true
    program_studi_id?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password_hash?: true
    nama?: true
    role?: true
    program_studi_id?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password_hash: string
    nama: string
    role: $Enums.UserRole
    program_studi_id: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password_hash?: boolean
    nama?: boolean
    role?: boolean
    program_studi_id?: boolean
    programStudi?: boolean | ProgramStudiDefaultArgs<ExtArgs>
    dosenPengampu?: boolean | User$dosenPengampuArgs<ExtArgs>
    pesertaKelas?: boolean | User$pesertaKelasArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password_hash?: boolean
    nama?: boolean
    role?: boolean
    program_studi_id?: boolean
    programStudi?: boolean | ProgramStudiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password_hash?: boolean
    nama?: boolean
    role?: boolean
    program_studi_id?: boolean
    programStudi?: boolean | ProgramStudiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password_hash?: boolean
    nama?: boolean
    role?: boolean
    program_studi_id?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password_hash" | "nama" | "role" | "program_studi_id", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programStudi?: boolean | ProgramStudiDefaultArgs<ExtArgs>
    dosenPengampu?: boolean | User$dosenPengampuArgs<ExtArgs>
    pesertaKelas?: boolean | User$pesertaKelasArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programStudi?: boolean | ProgramStudiDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programStudi?: boolean | ProgramStudiDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      programStudi: Prisma.$ProgramStudiPayload<ExtArgs>
      dosenPengampu: Prisma.$DosenPengampuPayload<ExtArgs>[]
      pesertaKelas: Prisma.$PesertaKelasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password_hash: string
      nama: string
      role: $Enums.UserRole
      program_studi_id: number
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    programStudi<T extends ProgramStudiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramStudiDefaultArgs<ExtArgs>>): Prisma__ProgramStudiClient<$Result.GetResult<Prisma.$ProgramStudiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dosenPengampu<T extends User$dosenPengampuArgs<ExtArgs> = {}>(args?: Subset<T, User$dosenPengampuArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DosenPengampuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pesertaKelas<T extends User$pesertaKelasArgs<ExtArgs> = {}>(args?: Subset<T, User$pesertaKelasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PesertaKelasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password_hash: FieldRef<"User", 'String'>
    readonly nama: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly program_studi_id: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.dosenPengampu
   */
  export type User$dosenPengampuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DosenPengampu
     */
    select?: DosenPengampuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DosenPengampu
     */
    omit?: DosenPengampuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosenPengampuInclude<ExtArgs> | null
    where?: DosenPengampuWhereInput
    orderBy?: DosenPengampuOrderByWithRelationInput | DosenPengampuOrderByWithRelationInput[]
    cursor?: DosenPengampuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DosenPengampuScalarFieldEnum | DosenPengampuScalarFieldEnum[]
  }

  /**
   * User.pesertaKelas
   */
  export type User$pesertaKelasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PesertaKelas
     */
    select?: PesertaKelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PesertaKelas
     */
    omit?: PesertaKelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PesertaKelasInclude<ExtArgs> | null
    where?: PesertaKelasWhereInput
    orderBy?: PesertaKelasOrderByWithRelationInput | PesertaKelasOrderByWithRelationInput[]
    cursor?: PesertaKelasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PesertaKelasScalarFieldEnum | PesertaKelasScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Kurikulum
   */

  export type AggregateKurikulum = {
    _count: KurikulumCountAggregateOutputType | null
    _avg: KurikulumAvgAggregateOutputType | null
    _sum: KurikulumSumAggregateOutputType | null
    _min: KurikulumMinAggregateOutputType | null
    _max: KurikulumMaxAggregateOutputType | null
  }

  export type KurikulumAvgAggregateOutputType = {
    id: number | null
    tahun: number | null
    program_studi_id: number | null
  }

  export type KurikulumSumAggregateOutputType = {
    id: number | null
    tahun: number | null
    program_studi_id: number | null
  }

  export type KurikulumMinAggregateOutputType = {
    id: number | null
    nama: string | null
    tahun: number | null
    createdAt: Date | null
    updatedAt: Date | null
    program_studi_id: number | null
  }

  export type KurikulumMaxAggregateOutputType = {
    id: number | null
    nama: string | null
    tahun: number | null
    createdAt: Date | null
    updatedAt: Date | null
    program_studi_id: number | null
  }

  export type KurikulumCountAggregateOutputType = {
    id: number
    nama: number
    tahun: number
    createdAt: number
    updatedAt: number
    program_studi_id: number
    _all: number
  }


  export type KurikulumAvgAggregateInputType = {
    id?: true
    tahun?: true
    program_studi_id?: true
  }

  export type KurikulumSumAggregateInputType = {
    id?: true
    tahun?: true
    program_studi_id?: true
  }

  export type KurikulumMinAggregateInputType = {
    id?: true
    nama?: true
    tahun?: true
    createdAt?: true
    updatedAt?: true
    program_studi_id?: true
  }

  export type KurikulumMaxAggregateInputType = {
    id?: true
    nama?: true
    tahun?: true
    createdAt?: true
    updatedAt?: true
    program_studi_id?: true
  }

  export type KurikulumCountAggregateInputType = {
    id?: true
    nama?: true
    tahun?: true
    createdAt?: true
    updatedAt?: true
    program_studi_id?: true
    _all?: true
  }

  export type KurikulumAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kurikulum to aggregate.
     */
    where?: KurikulumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kurikulums to fetch.
     */
    orderBy?: KurikulumOrderByWithRelationInput | KurikulumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KurikulumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kurikulums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kurikulums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kurikulums
    **/
    _count?: true | KurikulumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KurikulumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KurikulumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KurikulumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KurikulumMaxAggregateInputType
  }

  export type GetKurikulumAggregateType<T extends KurikulumAggregateArgs> = {
        [P in keyof T & keyof AggregateKurikulum]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKurikulum[P]>
      : GetScalarType<T[P], AggregateKurikulum[P]>
  }




  export type KurikulumGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KurikulumWhereInput
    orderBy?: KurikulumOrderByWithAggregationInput | KurikulumOrderByWithAggregationInput[]
    by: KurikulumScalarFieldEnum[] | KurikulumScalarFieldEnum
    having?: KurikulumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KurikulumCountAggregateInputType | true
    _avg?: KurikulumAvgAggregateInputType
    _sum?: KurikulumSumAggregateInputType
    _min?: KurikulumMinAggregateInputType
    _max?: KurikulumMaxAggregateInputType
  }

  export type KurikulumGroupByOutputType = {
    id: number
    nama: string
    tahun: number
    createdAt: Date
    updatedAt: Date
    program_studi_id: number
    _count: KurikulumCountAggregateOutputType | null
    _avg: KurikulumAvgAggregateOutputType | null
    _sum: KurikulumSumAggregateOutputType | null
    _min: KurikulumMinAggregateOutputType | null
    _max: KurikulumMaxAggregateOutputType | null
  }

  type GetKurikulumGroupByPayload<T extends KurikulumGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KurikulumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KurikulumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KurikulumGroupByOutputType[P]>
            : GetScalarType<T[P], KurikulumGroupByOutputType[P]>
        }
      >
    >


  export type KurikulumSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    tahun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program_studi_id?: boolean
    programStudi?: boolean | ProgramStudiDefaultArgs<ExtArgs>
    mataKuliah?: boolean | Kurikulum$mataKuliahArgs<ExtArgs>
    cpl?: boolean | Kurikulum$cplArgs<ExtArgs>
    piGroups?: boolean | Kurikulum$piGroupsArgs<ExtArgs>
    _count?: boolean | KurikulumCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kurikulum"]>

  export type KurikulumSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    tahun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program_studi_id?: boolean
    programStudi?: boolean | ProgramStudiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kurikulum"]>

  export type KurikulumSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    tahun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program_studi_id?: boolean
    programStudi?: boolean | ProgramStudiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kurikulum"]>

  export type KurikulumSelectScalar = {
    id?: boolean
    nama?: boolean
    tahun?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program_studi_id?: boolean
  }

  export type KurikulumOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nama" | "tahun" | "createdAt" | "updatedAt" | "program_studi_id", ExtArgs["result"]["kurikulum"]>
  export type KurikulumInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programStudi?: boolean | ProgramStudiDefaultArgs<ExtArgs>
    mataKuliah?: boolean | Kurikulum$mataKuliahArgs<ExtArgs>
    cpl?: boolean | Kurikulum$cplArgs<ExtArgs>
    piGroups?: boolean | Kurikulum$piGroupsArgs<ExtArgs>
    _count?: boolean | KurikulumCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KurikulumIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programStudi?: boolean | ProgramStudiDefaultArgs<ExtArgs>
  }
  export type KurikulumIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programStudi?: boolean | ProgramStudiDefaultArgs<ExtArgs>
  }

  export type $KurikulumPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Kurikulum"
    objects: {
      programStudi: Prisma.$ProgramStudiPayload<ExtArgs>
      mataKuliah: Prisma.$MataKuliahPayload<ExtArgs>[]
      cpl: Prisma.$CPLPayload<ExtArgs>[]
      piGroups: Prisma.$PIGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama: string
      tahun: number
      createdAt: Date
      updatedAt: Date
      program_studi_id: number
    }, ExtArgs["result"]["kurikulum"]>
    composites: {}
  }

  type KurikulumGetPayload<S extends boolean | null | undefined | KurikulumDefaultArgs> = $Result.GetResult<Prisma.$KurikulumPayload, S>

  type KurikulumCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KurikulumFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KurikulumCountAggregateInputType | true
    }

  export interface KurikulumDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Kurikulum'], meta: { name: 'Kurikulum' } }
    /**
     * Find zero or one Kurikulum that matches the filter.
     * @param {KurikulumFindUniqueArgs} args - Arguments to find a Kurikulum
     * @example
     * // Get one Kurikulum
     * const kurikulum = await prisma.kurikulum.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KurikulumFindUniqueArgs>(args: SelectSubset<T, KurikulumFindUniqueArgs<ExtArgs>>): Prisma__KurikulumClient<$Result.GetResult<Prisma.$KurikulumPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Kurikulum that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KurikulumFindUniqueOrThrowArgs} args - Arguments to find a Kurikulum
     * @example
     * // Get one Kurikulum
     * const kurikulum = await prisma.kurikulum.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KurikulumFindUniqueOrThrowArgs>(args: SelectSubset<T, KurikulumFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KurikulumClient<$Result.GetResult<Prisma.$KurikulumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kurikulum that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurikulumFindFirstArgs} args - Arguments to find a Kurikulum
     * @example
     * // Get one Kurikulum
     * const kurikulum = await prisma.kurikulum.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KurikulumFindFirstArgs>(args?: SelectSubset<T, KurikulumFindFirstArgs<ExtArgs>>): Prisma__KurikulumClient<$Result.GetResult<Prisma.$KurikulumPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kurikulum that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurikulumFindFirstOrThrowArgs} args - Arguments to find a Kurikulum
     * @example
     * // Get one Kurikulum
     * const kurikulum = await prisma.kurikulum.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KurikulumFindFirstOrThrowArgs>(args?: SelectSubset<T, KurikulumFindFirstOrThrowArgs<ExtArgs>>): Prisma__KurikulumClient<$Result.GetResult<Prisma.$KurikulumPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Kurikulums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurikulumFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kurikulums
     * const kurikulums = await prisma.kurikulum.findMany()
     * 
     * // Get first 10 Kurikulums
     * const kurikulums = await prisma.kurikulum.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kurikulumWithIdOnly = await prisma.kurikulum.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KurikulumFindManyArgs>(args?: SelectSubset<T, KurikulumFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KurikulumPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Kurikulum.
     * @param {KurikulumCreateArgs} args - Arguments to create a Kurikulum.
     * @example
     * // Create one Kurikulum
     * const Kurikulum = await prisma.kurikulum.create({
     *   data: {
     *     // ... data to create a Kurikulum
     *   }
     * })
     * 
     */
    create<T extends KurikulumCreateArgs>(args: SelectSubset<T, KurikulumCreateArgs<ExtArgs>>): Prisma__KurikulumClient<$Result.GetResult<Prisma.$KurikulumPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Kurikulums.
     * @param {KurikulumCreateManyArgs} args - Arguments to create many Kurikulums.
     * @example
     * // Create many Kurikulums
     * const kurikulum = await prisma.kurikulum.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KurikulumCreateManyArgs>(args?: SelectSubset<T, KurikulumCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kurikulums and returns the data saved in the database.
     * @param {KurikulumCreateManyAndReturnArgs} args - Arguments to create many Kurikulums.
     * @example
     * // Create many Kurikulums
     * const kurikulum = await prisma.kurikulum.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kurikulums and only return the `id`
     * const kurikulumWithIdOnly = await prisma.kurikulum.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KurikulumCreateManyAndReturnArgs>(args?: SelectSubset<T, KurikulumCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KurikulumPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Kurikulum.
     * @param {KurikulumDeleteArgs} args - Arguments to delete one Kurikulum.
     * @example
     * // Delete one Kurikulum
     * const Kurikulum = await prisma.kurikulum.delete({
     *   where: {
     *     // ... filter to delete one Kurikulum
     *   }
     * })
     * 
     */
    delete<T extends KurikulumDeleteArgs>(args: SelectSubset<T, KurikulumDeleteArgs<ExtArgs>>): Prisma__KurikulumClient<$Result.GetResult<Prisma.$KurikulumPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Kurikulum.
     * @param {KurikulumUpdateArgs} args - Arguments to update one Kurikulum.
     * @example
     * // Update one Kurikulum
     * const kurikulum = await prisma.kurikulum.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KurikulumUpdateArgs>(args: SelectSubset<T, KurikulumUpdateArgs<ExtArgs>>): Prisma__KurikulumClient<$Result.GetResult<Prisma.$KurikulumPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Kurikulums.
     * @param {KurikulumDeleteManyArgs} args - Arguments to filter Kurikulums to delete.
     * @example
     * // Delete a few Kurikulums
     * const { count } = await prisma.kurikulum.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KurikulumDeleteManyArgs>(args?: SelectSubset<T, KurikulumDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kurikulums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurikulumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kurikulums
     * const kurikulum = await prisma.kurikulum.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KurikulumUpdateManyArgs>(args: SelectSubset<T, KurikulumUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kurikulums and returns the data updated in the database.
     * @param {KurikulumUpdateManyAndReturnArgs} args - Arguments to update many Kurikulums.
     * @example
     * // Update many Kurikulums
     * const kurikulum = await prisma.kurikulum.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Kurikulums and only return the `id`
     * const kurikulumWithIdOnly = await prisma.kurikulum.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KurikulumUpdateManyAndReturnArgs>(args: SelectSubset<T, KurikulumUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KurikulumPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Kurikulum.
     * @param {KurikulumUpsertArgs} args - Arguments to update or create a Kurikulum.
     * @example
     * // Update or create a Kurikulum
     * const kurikulum = await prisma.kurikulum.upsert({
     *   create: {
     *     // ... data to create a Kurikulum
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kurikulum we want to update
     *   }
     * })
     */
    upsert<T extends KurikulumUpsertArgs>(args: SelectSubset<T, KurikulumUpsertArgs<ExtArgs>>): Prisma__KurikulumClient<$Result.GetResult<Prisma.$KurikulumPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Kurikulums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurikulumCountArgs} args - Arguments to filter Kurikulums to count.
     * @example
     * // Count the number of Kurikulums
     * const count = await prisma.kurikulum.count({
     *   where: {
     *     // ... the filter for the Kurikulums we want to count
     *   }
     * })
    **/
    count<T extends KurikulumCountArgs>(
      args?: Subset<T, KurikulumCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KurikulumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kurikulum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurikulumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KurikulumAggregateArgs>(args: Subset<T, KurikulumAggregateArgs>): Prisma.PrismaPromise<GetKurikulumAggregateType<T>>

    /**
     * Group by Kurikulum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurikulumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KurikulumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KurikulumGroupByArgs['orderBy'] }
        : { orderBy?: KurikulumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KurikulumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKurikulumGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Kurikulum model
   */
  readonly fields: KurikulumFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Kurikulum.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KurikulumClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    programStudi<T extends ProgramStudiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramStudiDefaultArgs<ExtArgs>>): Prisma__ProgramStudiClient<$Result.GetResult<Prisma.$ProgramStudiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mataKuliah<T extends Kurikulum$mataKuliahArgs<ExtArgs> = {}>(args?: Subset<T, Kurikulum$mataKuliahArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MataKuliahPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cpl<T extends Kurikulum$cplArgs<ExtArgs> = {}>(args?: Subset<T, Kurikulum$cplArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CPLPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    piGroups<T extends Kurikulum$piGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Kurikulum$piGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PIGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Kurikulum model
   */
  interface KurikulumFieldRefs {
    readonly id: FieldRef<"Kurikulum", 'Int'>
    readonly nama: FieldRef<"Kurikulum", 'String'>
    readonly tahun: FieldRef<"Kurikulum", 'Int'>
    readonly createdAt: FieldRef<"Kurikulum", 'DateTime'>
    readonly updatedAt: FieldRef<"Kurikulum", 'DateTime'>
    readonly program_studi_id: FieldRef<"Kurikulum", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Kurikulum findUnique
   */
  export type KurikulumFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kurikulum
     */
    select?: KurikulumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kurikulum
     */
    omit?: KurikulumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KurikulumInclude<ExtArgs> | null
    /**
     * Filter, which Kurikulum to fetch.
     */
    where: KurikulumWhereUniqueInput
  }

  /**
   * Kurikulum findUniqueOrThrow
   */
  export type KurikulumFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kurikulum
     */
    select?: KurikulumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kurikulum
     */
    omit?: KurikulumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KurikulumInclude<ExtArgs> | null
    /**
     * Filter, which Kurikulum to fetch.
     */
    where: KurikulumWhereUniqueInput
  }

  /**
   * Kurikulum findFirst
   */
  export type KurikulumFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kurikulum
     */
    select?: KurikulumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kurikulum
     */
    omit?: KurikulumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KurikulumInclude<ExtArgs> | null
    /**
     * Filter, which Kurikulum to fetch.
     */
    where?: KurikulumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kurikulums to fetch.
     */
    orderBy?: KurikulumOrderByWithRelationInput | KurikulumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kurikulums.
     */
    cursor?: KurikulumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kurikulums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kurikulums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kurikulums.
     */
    distinct?: KurikulumScalarFieldEnum | KurikulumScalarFieldEnum[]
  }

  /**
   * Kurikulum findFirstOrThrow
   */
  export type KurikulumFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kurikulum
     */
    select?: KurikulumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kurikulum
     */
    omit?: KurikulumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KurikulumInclude<ExtArgs> | null
    /**
     * Filter, which Kurikulum to fetch.
     */
    where?: KurikulumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kurikulums to fetch.
     */
    orderBy?: KurikulumOrderByWithRelationInput | KurikulumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kurikulums.
     */
    cursor?: KurikulumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kurikulums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kurikulums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kurikulums.
     */
    distinct?: KurikulumScalarFieldEnum | KurikulumScalarFieldEnum[]
  }

  /**
   * Kurikulum findMany
   */
  export type KurikulumFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kurikulum
     */
    select?: KurikulumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kurikulum
     */
    omit?: KurikulumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KurikulumInclude<ExtArgs> | null
    /**
     * Filter, which Kurikulums to fetch.
     */
    where?: KurikulumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kurikulums to fetch.
     */
    orderBy?: KurikulumOrderByWithRelationInput | KurikulumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kurikulums.
     */
    cursor?: KurikulumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kurikulums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kurikulums.
     */
    skip?: number
    distinct?: KurikulumScalarFieldEnum | KurikulumScalarFieldEnum[]
  }

  /**
   * Kurikulum create
   */
  export type KurikulumCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kurikulum
     */
    select?: KurikulumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kurikulum
     */
    omit?: KurikulumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KurikulumInclude<ExtArgs> | null
    /**
     * The data needed to create a Kurikulum.
     */
    data: XOR<KurikulumCreateInput, KurikulumUncheckedCreateInput>
  }

  /**
   * Kurikulum createMany
   */
  export type KurikulumCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Kurikulums.
     */
    data: KurikulumCreateManyInput | KurikulumCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Kurikulum createManyAndReturn
   */
  export type KurikulumCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kurikulum
     */
    select?: KurikulumSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kurikulum
     */
    omit?: KurikulumOmit<ExtArgs> | null
    /**
     * The data used to create many Kurikulums.
     */
    data: KurikulumCreateManyInput | KurikulumCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KurikulumIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Kurikulum update
   */
  export type KurikulumUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kurikulum
     */
    select?: KurikulumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kurikulum
     */
    omit?: KurikulumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KurikulumInclude<ExtArgs> | null
    /**
     * The data needed to update a Kurikulum.
     */
    data: XOR<KurikulumUpdateInput, KurikulumUncheckedUpdateInput>
    /**
     * Choose, which Kurikulum to update.
     */
    where: KurikulumWhereUniqueInput
  }

  /**
   * Kurikulum updateMany
   */
  export type KurikulumUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Kurikulums.
     */
    data: XOR<KurikulumUpdateManyMutationInput, KurikulumUncheckedUpdateManyInput>
    /**
     * Filter which Kurikulums to update
     */
    where?: KurikulumWhereInput
    /**
     * Limit how many Kurikulums to update.
     */
    limit?: number
  }

  /**
   * Kurikulum updateManyAndReturn
   */
  export type KurikulumUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kurikulum
     */
    select?: KurikulumSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kurikulum
     */
    omit?: KurikulumOmit<ExtArgs> | null
    /**
     * The data used to update Kurikulums.
     */
    data: XOR<KurikulumUpdateManyMutationInput, KurikulumUncheckedUpdateManyInput>
    /**
     * Filter which Kurikulums to update
     */
    where?: KurikulumWhereInput
    /**
     * Limit how many Kurikulums to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KurikulumIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Kurikulum upsert
   */
  export type KurikulumUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kurikulum
     */
    select?: KurikulumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kurikulum
     */
    omit?: KurikulumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KurikulumInclude<ExtArgs> | null
    /**
     * The filter to search for the Kurikulum to update in case it exists.
     */
    where: KurikulumWhereUniqueInput
    /**
     * In case the Kurikulum found by the `where` argument doesn't exist, create a new Kurikulum with this data.
     */
    create: XOR<KurikulumCreateInput, KurikulumUncheckedCreateInput>
    /**
     * In case the Kurikulum was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KurikulumUpdateInput, KurikulumUncheckedUpdateInput>
  }

  /**
   * Kurikulum delete
   */
  export type KurikulumDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kurikulum
     */
    select?: KurikulumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kurikulum
     */
    omit?: KurikulumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KurikulumInclude<ExtArgs> | null
    /**
     * Filter which Kurikulum to delete.
     */
    where: KurikulumWhereUniqueInput
  }

  /**
   * Kurikulum deleteMany
   */
  export type KurikulumDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kurikulums to delete
     */
    where?: KurikulumWhereInput
    /**
     * Limit how many Kurikulums to delete.
     */
    limit?: number
  }

  /**
   * Kurikulum.mataKuliah
   */
  export type Kurikulum$mataKuliahArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MataKuliah
     */
    select?: MataKuliahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MataKuliah
     */
    omit?: MataKuliahOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MataKuliahInclude<ExtArgs> | null
    where?: MataKuliahWhereInput
    orderBy?: MataKuliahOrderByWithRelationInput | MataKuliahOrderByWithRelationInput[]
    cursor?: MataKuliahWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MataKuliahScalarFieldEnum | MataKuliahScalarFieldEnum[]
  }

  /**
   * Kurikulum.cpl
   */
  export type Kurikulum$cplArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPL
     */
    select?: CPLSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPL
     */
    omit?: CPLOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPLInclude<ExtArgs> | null
    where?: CPLWhereInput
    orderBy?: CPLOrderByWithRelationInput | CPLOrderByWithRelationInput[]
    cursor?: CPLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CPLScalarFieldEnum | CPLScalarFieldEnum[]
  }

  /**
   * Kurikulum.piGroups
   */
  export type Kurikulum$piGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PIGroup
     */
    select?: PIGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PIGroup
     */
    omit?: PIGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PIGroupInclude<ExtArgs> | null
    where?: PIGroupWhereInput
    orderBy?: PIGroupOrderByWithRelationInput | PIGroupOrderByWithRelationInput[]
    cursor?: PIGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PIGroupScalarFieldEnum | PIGroupScalarFieldEnum[]
  }

  /**
   * Kurikulum without action
   */
  export type KurikulumDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kurikulum
     */
    select?: KurikulumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kurikulum
     */
    omit?: KurikulumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KurikulumInclude<ExtArgs> | null
  }


  /**
   * Model MataKuliah
   */

  export type AggregateMataKuliah = {
    _count: MataKuliahCountAggregateOutputType | null
    _avg: MataKuliahAvgAggregateOutputType | null
    _sum: MataKuliahSumAggregateOutputType | null
    _min: MataKuliahMinAggregateOutputType | null
    _max: MataKuliahMaxAggregateOutputType | null
  }

  export type MataKuliahAvgAggregateOutputType = {
    id: number | null
    sks: number | null
    kurikulum_id: number | null
  }

  export type MataKuliahSumAggregateOutputType = {
    id: number | null
    sks: number | null
    kurikulum_id: number | null
  }

  export type MataKuliahMinAggregateOutputType = {
    id: number | null
    kode_mk: string | null
    nama: string | null
    sks: number | null
    createdAt: Date | null
    updatedAt: Date | null
    kurikulum_id: number | null
  }

  export type MataKuliahMaxAggregateOutputType = {
    id: number | null
    kode_mk: string | null
    nama: string | null
    sks: number | null
    createdAt: Date | null
    updatedAt: Date | null
    kurikulum_id: number | null
  }

  export type MataKuliahCountAggregateOutputType = {
    id: number
    kode_mk: number
    nama: number
    sks: number
    createdAt: number
    updatedAt: number
    kurikulum_id: number
    _all: number
  }


  export type MataKuliahAvgAggregateInputType = {
    id?: true
    sks?: true
    kurikulum_id?: true
  }

  export type MataKuliahSumAggregateInputType = {
    id?: true
    sks?: true
    kurikulum_id?: true
  }

  export type MataKuliahMinAggregateInputType = {
    id?: true
    kode_mk?: true
    nama?: true
    sks?: true
    createdAt?: true
    updatedAt?: true
    kurikulum_id?: true
  }

  export type MataKuliahMaxAggregateInputType = {
    id?: true
    kode_mk?: true
    nama?: true
    sks?: true
    createdAt?: true
    updatedAt?: true
    kurikulum_id?: true
  }

  export type MataKuliahCountAggregateInputType = {
    id?: true
    kode_mk?: true
    nama?: true
    sks?: true
    createdAt?: true
    updatedAt?: true
    kurikulum_id?: true
    _all?: true
  }

  export type MataKuliahAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MataKuliah to aggregate.
     */
    where?: MataKuliahWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MataKuliahs to fetch.
     */
    orderBy?: MataKuliahOrderByWithRelationInput | MataKuliahOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MataKuliahWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MataKuliahs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MataKuliahs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MataKuliahs
    **/
    _count?: true | MataKuliahCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MataKuliahAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MataKuliahSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MataKuliahMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MataKuliahMaxAggregateInputType
  }

  export type GetMataKuliahAggregateType<T extends MataKuliahAggregateArgs> = {
        [P in keyof T & keyof AggregateMataKuliah]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMataKuliah[P]>
      : GetScalarType<T[P], AggregateMataKuliah[P]>
  }




  export type MataKuliahGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MataKuliahWhereInput
    orderBy?: MataKuliahOrderByWithAggregationInput | MataKuliahOrderByWithAggregationInput[]
    by: MataKuliahScalarFieldEnum[] | MataKuliahScalarFieldEnum
    having?: MataKuliahScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MataKuliahCountAggregateInputType | true
    _avg?: MataKuliahAvgAggregateInputType
    _sum?: MataKuliahSumAggregateInputType
    _min?: MataKuliahMinAggregateInputType
    _max?: MataKuliahMaxAggregateInputType
  }

  export type MataKuliahGroupByOutputType = {
    id: number
    kode_mk: string
    nama: string
    sks: number
    createdAt: Date
    updatedAt: Date
    kurikulum_id: number
    _count: MataKuliahCountAggregateOutputType | null
    _avg: MataKuliahAvgAggregateOutputType | null
    _sum: MataKuliahSumAggregateOutputType | null
    _min: MataKuliahMinAggregateOutputType | null
    _max: MataKuliahMaxAggregateOutputType | null
  }

  type GetMataKuliahGroupByPayload<T extends MataKuliahGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MataKuliahGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MataKuliahGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MataKuliahGroupByOutputType[P]>
            : GetScalarType<T[P], MataKuliahGroupByOutputType[P]>
        }
      >
    >


  export type MataKuliahSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode_mk?: boolean
    nama?: boolean
    sks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kurikulum_id?: boolean
    kurikulum?: boolean | KurikulumDefaultArgs<ExtArgs>
    kelas?: boolean | MataKuliah$kelasArgs<ExtArgs>
    _count?: boolean | MataKuliahCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mataKuliah"]>

  export type MataKuliahSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode_mk?: boolean
    nama?: boolean
    sks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kurikulum_id?: boolean
    kurikulum?: boolean | KurikulumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mataKuliah"]>

  export type MataKuliahSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode_mk?: boolean
    nama?: boolean
    sks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kurikulum_id?: boolean
    kurikulum?: boolean | KurikulumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mataKuliah"]>

  export type MataKuliahSelectScalar = {
    id?: boolean
    kode_mk?: boolean
    nama?: boolean
    sks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kurikulum_id?: boolean
  }

  export type MataKuliahOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kode_mk" | "nama" | "sks" | "createdAt" | "updatedAt" | "kurikulum_id", ExtArgs["result"]["mataKuliah"]>
  export type MataKuliahInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kurikulum?: boolean | KurikulumDefaultArgs<ExtArgs>
    kelas?: boolean | MataKuliah$kelasArgs<ExtArgs>
    _count?: boolean | MataKuliahCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MataKuliahIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kurikulum?: boolean | KurikulumDefaultArgs<ExtArgs>
  }
  export type MataKuliahIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kurikulum?: boolean | KurikulumDefaultArgs<ExtArgs>
  }

  export type $MataKuliahPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MataKuliah"
    objects: {
      kurikulum: Prisma.$KurikulumPayload<ExtArgs>
      kelas: Prisma.$KelasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kode_mk: string
      nama: string
      sks: number
      createdAt: Date
      updatedAt: Date
      kurikulum_id: number
    }, ExtArgs["result"]["mataKuliah"]>
    composites: {}
  }

  type MataKuliahGetPayload<S extends boolean | null | undefined | MataKuliahDefaultArgs> = $Result.GetResult<Prisma.$MataKuliahPayload, S>

  type MataKuliahCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MataKuliahFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MataKuliahCountAggregateInputType | true
    }

  export interface MataKuliahDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MataKuliah'], meta: { name: 'MataKuliah' } }
    /**
     * Find zero or one MataKuliah that matches the filter.
     * @param {MataKuliahFindUniqueArgs} args - Arguments to find a MataKuliah
     * @example
     * // Get one MataKuliah
     * const mataKuliah = await prisma.mataKuliah.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MataKuliahFindUniqueArgs>(args: SelectSubset<T, MataKuliahFindUniqueArgs<ExtArgs>>): Prisma__MataKuliahClient<$Result.GetResult<Prisma.$MataKuliahPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MataKuliah that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MataKuliahFindUniqueOrThrowArgs} args - Arguments to find a MataKuliah
     * @example
     * // Get one MataKuliah
     * const mataKuliah = await prisma.mataKuliah.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MataKuliahFindUniqueOrThrowArgs>(args: SelectSubset<T, MataKuliahFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MataKuliahClient<$Result.GetResult<Prisma.$MataKuliahPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MataKuliah that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataKuliahFindFirstArgs} args - Arguments to find a MataKuliah
     * @example
     * // Get one MataKuliah
     * const mataKuliah = await prisma.mataKuliah.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MataKuliahFindFirstArgs>(args?: SelectSubset<T, MataKuliahFindFirstArgs<ExtArgs>>): Prisma__MataKuliahClient<$Result.GetResult<Prisma.$MataKuliahPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MataKuliah that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataKuliahFindFirstOrThrowArgs} args - Arguments to find a MataKuliah
     * @example
     * // Get one MataKuliah
     * const mataKuliah = await prisma.mataKuliah.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MataKuliahFindFirstOrThrowArgs>(args?: SelectSubset<T, MataKuliahFindFirstOrThrowArgs<ExtArgs>>): Prisma__MataKuliahClient<$Result.GetResult<Prisma.$MataKuliahPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MataKuliahs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataKuliahFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MataKuliahs
     * const mataKuliahs = await prisma.mataKuliah.findMany()
     * 
     * // Get first 10 MataKuliahs
     * const mataKuliahs = await prisma.mataKuliah.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mataKuliahWithIdOnly = await prisma.mataKuliah.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MataKuliahFindManyArgs>(args?: SelectSubset<T, MataKuliahFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MataKuliahPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MataKuliah.
     * @param {MataKuliahCreateArgs} args - Arguments to create a MataKuliah.
     * @example
     * // Create one MataKuliah
     * const MataKuliah = await prisma.mataKuliah.create({
     *   data: {
     *     // ... data to create a MataKuliah
     *   }
     * })
     * 
     */
    create<T extends MataKuliahCreateArgs>(args: SelectSubset<T, MataKuliahCreateArgs<ExtArgs>>): Prisma__MataKuliahClient<$Result.GetResult<Prisma.$MataKuliahPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MataKuliahs.
     * @param {MataKuliahCreateManyArgs} args - Arguments to create many MataKuliahs.
     * @example
     * // Create many MataKuliahs
     * const mataKuliah = await prisma.mataKuliah.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MataKuliahCreateManyArgs>(args?: SelectSubset<T, MataKuliahCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MataKuliahs and returns the data saved in the database.
     * @param {MataKuliahCreateManyAndReturnArgs} args - Arguments to create many MataKuliahs.
     * @example
     * // Create many MataKuliahs
     * const mataKuliah = await prisma.mataKuliah.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MataKuliahs and only return the `id`
     * const mataKuliahWithIdOnly = await prisma.mataKuliah.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MataKuliahCreateManyAndReturnArgs>(args?: SelectSubset<T, MataKuliahCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MataKuliahPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MataKuliah.
     * @param {MataKuliahDeleteArgs} args - Arguments to delete one MataKuliah.
     * @example
     * // Delete one MataKuliah
     * const MataKuliah = await prisma.mataKuliah.delete({
     *   where: {
     *     // ... filter to delete one MataKuliah
     *   }
     * })
     * 
     */
    delete<T extends MataKuliahDeleteArgs>(args: SelectSubset<T, MataKuliahDeleteArgs<ExtArgs>>): Prisma__MataKuliahClient<$Result.GetResult<Prisma.$MataKuliahPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MataKuliah.
     * @param {MataKuliahUpdateArgs} args - Arguments to update one MataKuliah.
     * @example
     * // Update one MataKuliah
     * const mataKuliah = await prisma.mataKuliah.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MataKuliahUpdateArgs>(args: SelectSubset<T, MataKuliahUpdateArgs<ExtArgs>>): Prisma__MataKuliahClient<$Result.GetResult<Prisma.$MataKuliahPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MataKuliahs.
     * @param {MataKuliahDeleteManyArgs} args - Arguments to filter MataKuliahs to delete.
     * @example
     * // Delete a few MataKuliahs
     * const { count } = await prisma.mataKuliah.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MataKuliahDeleteManyArgs>(args?: SelectSubset<T, MataKuliahDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MataKuliahs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataKuliahUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MataKuliahs
     * const mataKuliah = await prisma.mataKuliah.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MataKuliahUpdateManyArgs>(args: SelectSubset<T, MataKuliahUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MataKuliahs and returns the data updated in the database.
     * @param {MataKuliahUpdateManyAndReturnArgs} args - Arguments to update many MataKuliahs.
     * @example
     * // Update many MataKuliahs
     * const mataKuliah = await prisma.mataKuliah.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MataKuliahs and only return the `id`
     * const mataKuliahWithIdOnly = await prisma.mataKuliah.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MataKuliahUpdateManyAndReturnArgs>(args: SelectSubset<T, MataKuliahUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MataKuliahPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MataKuliah.
     * @param {MataKuliahUpsertArgs} args - Arguments to update or create a MataKuliah.
     * @example
     * // Update or create a MataKuliah
     * const mataKuliah = await prisma.mataKuliah.upsert({
     *   create: {
     *     // ... data to create a MataKuliah
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MataKuliah we want to update
     *   }
     * })
     */
    upsert<T extends MataKuliahUpsertArgs>(args: SelectSubset<T, MataKuliahUpsertArgs<ExtArgs>>): Prisma__MataKuliahClient<$Result.GetResult<Prisma.$MataKuliahPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MataKuliahs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataKuliahCountArgs} args - Arguments to filter MataKuliahs to count.
     * @example
     * // Count the number of MataKuliahs
     * const count = await prisma.mataKuliah.count({
     *   where: {
     *     // ... the filter for the MataKuliahs we want to count
     *   }
     * })
    **/
    count<T extends MataKuliahCountArgs>(
      args?: Subset<T, MataKuliahCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MataKuliahCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MataKuliah.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataKuliahAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MataKuliahAggregateArgs>(args: Subset<T, MataKuliahAggregateArgs>): Prisma.PrismaPromise<GetMataKuliahAggregateType<T>>

    /**
     * Group by MataKuliah.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MataKuliahGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MataKuliahGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MataKuliahGroupByArgs['orderBy'] }
        : { orderBy?: MataKuliahGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MataKuliahGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMataKuliahGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MataKuliah model
   */
  readonly fields: MataKuliahFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MataKuliah.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MataKuliahClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kurikulum<T extends KurikulumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KurikulumDefaultArgs<ExtArgs>>): Prisma__KurikulumClient<$Result.GetResult<Prisma.$KurikulumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    kelas<T extends MataKuliah$kelasArgs<ExtArgs> = {}>(args?: Subset<T, MataKuliah$kelasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KelasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MataKuliah model
   */
  interface MataKuliahFieldRefs {
    readonly id: FieldRef<"MataKuliah", 'Int'>
    readonly kode_mk: FieldRef<"MataKuliah", 'String'>
    readonly nama: FieldRef<"MataKuliah", 'String'>
    readonly sks: FieldRef<"MataKuliah", 'Int'>
    readonly createdAt: FieldRef<"MataKuliah", 'DateTime'>
    readonly updatedAt: FieldRef<"MataKuliah", 'DateTime'>
    readonly kurikulum_id: FieldRef<"MataKuliah", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MataKuliah findUnique
   */
  export type MataKuliahFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MataKuliah
     */
    select?: MataKuliahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MataKuliah
     */
    omit?: MataKuliahOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MataKuliahInclude<ExtArgs> | null
    /**
     * Filter, which MataKuliah to fetch.
     */
    where: MataKuliahWhereUniqueInput
  }

  /**
   * MataKuliah findUniqueOrThrow
   */
  export type MataKuliahFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MataKuliah
     */
    select?: MataKuliahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MataKuliah
     */
    omit?: MataKuliahOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MataKuliahInclude<ExtArgs> | null
    /**
     * Filter, which MataKuliah to fetch.
     */
    where: MataKuliahWhereUniqueInput
  }

  /**
   * MataKuliah findFirst
   */
  export type MataKuliahFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MataKuliah
     */
    select?: MataKuliahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MataKuliah
     */
    omit?: MataKuliahOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MataKuliahInclude<ExtArgs> | null
    /**
     * Filter, which MataKuliah to fetch.
     */
    where?: MataKuliahWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MataKuliahs to fetch.
     */
    orderBy?: MataKuliahOrderByWithRelationInput | MataKuliahOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MataKuliahs.
     */
    cursor?: MataKuliahWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MataKuliahs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MataKuliahs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MataKuliahs.
     */
    distinct?: MataKuliahScalarFieldEnum | MataKuliahScalarFieldEnum[]
  }

  /**
   * MataKuliah findFirstOrThrow
   */
  export type MataKuliahFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MataKuliah
     */
    select?: MataKuliahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MataKuliah
     */
    omit?: MataKuliahOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MataKuliahInclude<ExtArgs> | null
    /**
     * Filter, which MataKuliah to fetch.
     */
    where?: MataKuliahWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MataKuliahs to fetch.
     */
    orderBy?: MataKuliahOrderByWithRelationInput | MataKuliahOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MataKuliahs.
     */
    cursor?: MataKuliahWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MataKuliahs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MataKuliahs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MataKuliahs.
     */
    distinct?: MataKuliahScalarFieldEnum | MataKuliahScalarFieldEnum[]
  }

  /**
   * MataKuliah findMany
   */
  export type MataKuliahFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MataKuliah
     */
    select?: MataKuliahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MataKuliah
     */
    omit?: MataKuliahOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MataKuliahInclude<ExtArgs> | null
    /**
     * Filter, which MataKuliahs to fetch.
     */
    where?: MataKuliahWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MataKuliahs to fetch.
     */
    orderBy?: MataKuliahOrderByWithRelationInput | MataKuliahOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MataKuliahs.
     */
    cursor?: MataKuliahWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MataKuliahs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MataKuliahs.
     */
    skip?: number
    distinct?: MataKuliahScalarFieldEnum | MataKuliahScalarFieldEnum[]
  }

  /**
   * MataKuliah create
   */
  export type MataKuliahCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MataKuliah
     */
    select?: MataKuliahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MataKuliah
     */
    omit?: MataKuliahOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MataKuliahInclude<ExtArgs> | null
    /**
     * The data needed to create a MataKuliah.
     */
    data: XOR<MataKuliahCreateInput, MataKuliahUncheckedCreateInput>
  }

  /**
   * MataKuliah createMany
   */
  export type MataKuliahCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MataKuliahs.
     */
    data: MataKuliahCreateManyInput | MataKuliahCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MataKuliah createManyAndReturn
   */
  export type MataKuliahCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MataKuliah
     */
    select?: MataKuliahSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MataKuliah
     */
    omit?: MataKuliahOmit<ExtArgs> | null
    /**
     * The data used to create many MataKuliahs.
     */
    data: MataKuliahCreateManyInput | MataKuliahCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MataKuliahIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MataKuliah update
   */
  export type MataKuliahUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MataKuliah
     */
    select?: MataKuliahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MataKuliah
     */
    omit?: MataKuliahOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MataKuliahInclude<ExtArgs> | null
    /**
     * The data needed to update a MataKuliah.
     */
    data: XOR<MataKuliahUpdateInput, MataKuliahUncheckedUpdateInput>
    /**
     * Choose, which MataKuliah to update.
     */
    where: MataKuliahWhereUniqueInput
  }

  /**
   * MataKuliah updateMany
   */
  export type MataKuliahUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MataKuliahs.
     */
    data: XOR<MataKuliahUpdateManyMutationInput, MataKuliahUncheckedUpdateManyInput>
    /**
     * Filter which MataKuliahs to update
     */
    where?: MataKuliahWhereInput
    /**
     * Limit how many MataKuliahs to update.
     */
    limit?: number
  }

  /**
   * MataKuliah updateManyAndReturn
   */
  export type MataKuliahUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MataKuliah
     */
    select?: MataKuliahSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MataKuliah
     */
    omit?: MataKuliahOmit<ExtArgs> | null
    /**
     * The data used to update MataKuliahs.
     */
    data: XOR<MataKuliahUpdateManyMutationInput, MataKuliahUncheckedUpdateManyInput>
    /**
     * Filter which MataKuliahs to update
     */
    where?: MataKuliahWhereInput
    /**
     * Limit how many MataKuliahs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MataKuliahIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MataKuliah upsert
   */
  export type MataKuliahUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MataKuliah
     */
    select?: MataKuliahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MataKuliah
     */
    omit?: MataKuliahOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MataKuliahInclude<ExtArgs> | null
    /**
     * The filter to search for the MataKuliah to update in case it exists.
     */
    where: MataKuliahWhereUniqueInput
    /**
     * In case the MataKuliah found by the `where` argument doesn't exist, create a new MataKuliah with this data.
     */
    create: XOR<MataKuliahCreateInput, MataKuliahUncheckedCreateInput>
    /**
     * In case the MataKuliah was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MataKuliahUpdateInput, MataKuliahUncheckedUpdateInput>
  }

  /**
   * MataKuliah delete
   */
  export type MataKuliahDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MataKuliah
     */
    select?: MataKuliahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MataKuliah
     */
    omit?: MataKuliahOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MataKuliahInclude<ExtArgs> | null
    /**
     * Filter which MataKuliah to delete.
     */
    where: MataKuliahWhereUniqueInput
  }

  /**
   * MataKuliah deleteMany
   */
  export type MataKuliahDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MataKuliahs to delete
     */
    where?: MataKuliahWhereInput
    /**
     * Limit how many MataKuliahs to delete.
     */
    limit?: number
  }

  /**
   * MataKuliah.kelas
   */
  export type MataKuliah$kelasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kelas
     */
    select?: KelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kelas
     */
    omit?: KelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KelasInclude<ExtArgs> | null
    where?: KelasWhereInput
    orderBy?: KelasOrderByWithRelationInput | KelasOrderByWithRelationInput[]
    cursor?: KelasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KelasScalarFieldEnum | KelasScalarFieldEnum[]
  }

  /**
   * MataKuliah without action
   */
  export type MataKuliahDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MataKuliah
     */
    select?: MataKuliahSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MataKuliah
     */
    omit?: MataKuliahOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MataKuliahInclude<ExtArgs> | null
  }


  /**
   * Model PIGroup
   */

  export type AggregatePIGroup = {
    _count: PIGroupCountAggregateOutputType | null
    _avg: PIGroupAvgAggregateOutputType | null
    _sum: PIGroupSumAggregateOutputType | null
    _min: PIGroupMinAggregateOutputType | null
    _max: PIGroupMaxAggregateOutputType | null
  }

  export type PIGroupAvgAggregateOutputType = {
    id: number | null
    kurikulum_id: number | null
  }

  export type PIGroupSumAggregateOutputType = {
    id: number | null
    kurikulum_id: number | null
  }

  export type PIGroupMinAggregateOutputType = {
    id: number | null
    kode_grup: string | null
    nama_grup: string | null
    createdAt: Date | null
    updatedAt: Date | null
    kurikulum_id: number | null
  }

  export type PIGroupMaxAggregateOutputType = {
    id: number | null
    kode_grup: string | null
    nama_grup: string | null
    createdAt: Date | null
    updatedAt: Date | null
    kurikulum_id: number | null
  }

  export type PIGroupCountAggregateOutputType = {
    id: number
    kode_grup: number
    nama_grup: number
    createdAt: number
    updatedAt: number
    kurikulum_id: number
    _all: number
  }


  export type PIGroupAvgAggregateInputType = {
    id?: true
    kurikulum_id?: true
  }

  export type PIGroupSumAggregateInputType = {
    id?: true
    kurikulum_id?: true
  }

  export type PIGroupMinAggregateInputType = {
    id?: true
    kode_grup?: true
    nama_grup?: true
    createdAt?: true
    updatedAt?: true
    kurikulum_id?: true
  }

  export type PIGroupMaxAggregateInputType = {
    id?: true
    kode_grup?: true
    nama_grup?: true
    createdAt?: true
    updatedAt?: true
    kurikulum_id?: true
  }

  export type PIGroupCountAggregateInputType = {
    id?: true
    kode_grup?: true
    nama_grup?: true
    createdAt?: true
    updatedAt?: true
    kurikulum_id?: true
    _all?: true
  }

  export type PIGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PIGroup to aggregate.
     */
    where?: PIGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PIGroups to fetch.
     */
    orderBy?: PIGroupOrderByWithRelationInput | PIGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PIGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PIGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PIGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PIGroups
    **/
    _count?: true | PIGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PIGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PIGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PIGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PIGroupMaxAggregateInputType
  }

  export type GetPIGroupAggregateType<T extends PIGroupAggregateArgs> = {
        [P in keyof T & keyof AggregatePIGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePIGroup[P]>
      : GetScalarType<T[P], AggregatePIGroup[P]>
  }




  export type PIGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PIGroupWhereInput
    orderBy?: PIGroupOrderByWithAggregationInput | PIGroupOrderByWithAggregationInput[]
    by: PIGroupScalarFieldEnum[] | PIGroupScalarFieldEnum
    having?: PIGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PIGroupCountAggregateInputType | true
    _avg?: PIGroupAvgAggregateInputType
    _sum?: PIGroupSumAggregateInputType
    _min?: PIGroupMinAggregateInputType
    _max?: PIGroupMaxAggregateInputType
  }

  export type PIGroupGroupByOutputType = {
    id: number
    kode_grup: string
    nama_grup: string
    createdAt: Date
    updatedAt: Date
    kurikulum_id: number
    _count: PIGroupCountAggregateOutputType | null
    _avg: PIGroupAvgAggregateOutputType | null
    _sum: PIGroupSumAggregateOutputType | null
    _min: PIGroupMinAggregateOutputType | null
    _max: PIGroupMaxAggregateOutputType | null
  }

  type GetPIGroupGroupByPayload<T extends PIGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PIGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PIGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PIGroupGroupByOutputType[P]>
            : GetScalarType<T[P], PIGroupGroupByOutputType[P]>
        }
      >
    >


  export type PIGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode_grup?: boolean
    nama_grup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kurikulum_id?: boolean
    kurikulum?: boolean | KurikulumDefaultArgs<ExtArgs>
    indicators?: boolean | PIGroup$indicatorsArgs<ExtArgs>
    cpl?: boolean | PIGroup$cplArgs<ExtArgs>
    _count?: boolean | PIGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pIGroup"]>

  export type PIGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode_grup?: boolean
    nama_grup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kurikulum_id?: boolean
    kurikulum?: boolean | KurikulumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pIGroup"]>

  export type PIGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode_grup?: boolean
    nama_grup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kurikulum_id?: boolean
    kurikulum?: boolean | KurikulumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pIGroup"]>

  export type PIGroupSelectScalar = {
    id?: boolean
    kode_grup?: boolean
    nama_grup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kurikulum_id?: boolean
  }

  export type PIGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kode_grup" | "nama_grup" | "createdAt" | "updatedAt" | "kurikulum_id", ExtArgs["result"]["pIGroup"]>
  export type PIGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kurikulum?: boolean | KurikulumDefaultArgs<ExtArgs>
    indicators?: boolean | PIGroup$indicatorsArgs<ExtArgs>
    cpl?: boolean | PIGroup$cplArgs<ExtArgs>
    _count?: boolean | PIGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PIGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kurikulum?: boolean | KurikulumDefaultArgs<ExtArgs>
  }
  export type PIGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kurikulum?: boolean | KurikulumDefaultArgs<ExtArgs>
  }

  export type $PIGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PIGroup"
    objects: {
      kurikulum: Prisma.$KurikulumPayload<ExtArgs>
      indicators: Prisma.$PerformanceIndicatorPayload<ExtArgs>[]
      cpl: Prisma.$CPLPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kode_grup: string
      nama_grup: string
      createdAt: Date
      updatedAt: Date
      kurikulum_id: number
    }, ExtArgs["result"]["pIGroup"]>
    composites: {}
  }

  type PIGroupGetPayload<S extends boolean | null | undefined | PIGroupDefaultArgs> = $Result.GetResult<Prisma.$PIGroupPayload, S>

  type PIGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PIGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PIGroupCountAggregateInputType | true
    }

  export interface PIGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PIGroup'], meta: { name: 'PIGroup' } }
    /**
     * Find zero or one PIGroup that matches the filter.
     * @param {PIGroupFindUniqueArgs} args - Arguments to find a PIGroup
     * @example
     * // Get one PIGroup
     * const pIGroup = await prisma.pIGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PIGroupFindUniqueArgs>(args: SelectSubset<T, PIGroupFindUniqueArgs<ExtArgs>>): Prisma__PIGroupClient<$Result.GetResult<Prisma.$PIGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PIGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PIGroupFindUniqueOrThrowArgs} args - Arguments to find a PIGroup
     * @example
     * // Get one PIGroup
     * const pIGroup = await prisma.pIGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PIGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, PIGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PIGroupClient<$Result.GetResult<Prisma.$PIGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PIGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PIGroupFindFirstArgs} args - Arguments to find a PIGroup
     * @example
     * // Get one PIGroup
     * const pIGroup = await prisma.pIGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PIGroupFindFirstArgs>(args?: SelectSubset<T, PIGroupFindFirstArgs<ExtArgs>>): Prisma__PIGroupClient<$Result.GetResult<Prisma.$PIGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PIGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PIGroupFindFirstOrThrowArgs} args - Arguments to find a PIGroup
     * @example
     * // Get one PIGroup
     * const pIGroup = await prisma.pIGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PIGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, PIGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__PIGroupClient<$Result.GetResult<Prisma.$PIGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PIGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PIGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PIGroups
     * const pIGroups = await prisma.pIGroup.findMany()
     * 
     * // Get first 10 PIGroups
     * const pIGroups = await prisma.pIGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pIGroupWithIdOnly = await prisma.pIGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PIGroupFindManyArgs>(args?: SelectSubset<T, PIGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PIGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PIGroup.
     * @param {PIGroupCreateArgs} args - Arguments to create a PIGroup.
     * @example
     * // Create one PIGroup
     * const PIGroup = await prisma.pIGroup.create({
     *   data: {
     *     // ... data to create a PIGroup
     *   }
     * })
     * 
     */
    create<T extends PIGroupCreateArgs>(args: SelectSubset<T, PIGroupCreateArgs<ExtArgs>>): Prisma__PIGroupClient<$Result.GetResult<Prisma.$PIGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PIGroups.
     * @param {PIGroupCreateManyArgs} args - Arguments to create many PIGroups.
     * @example
     * // Create many PIGroups
     * const pIGroup = await prisma.pIGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PIGroupCreateManyArgs>(args?: SelectSubset<T, PIGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PIGroups and returns the data saved in the database.
     * @param {PIGroupCreateManyAndReturnArgs} args - Arguments to create many PIGroups.
     * @example
     * // Create many PIGroups
     * const pIGroup = await prisma.pIGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PIGroups and only return the `id`
     * const pIGroupWithIdOnly = await prisma.pIGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PIGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, PIGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PIGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PIGroup.
     * @param {PIGroupDeleteArgs} args - Arguments to delete one PIGroup.
     * @example
     * // Delete one PIGroup
     * const PIGroup = await prisma.pIGroup.delete({
     *   where: {
     *     // ... filter to delete one PIGroup
     *   }
     * })
     * 
     */
    delete<T extends PIGroupDeleteArgs>(args: SelectSubset<T, PIGroupDeleteArgs<ExtArgs>>): Prisma__PIGroupClient<$Result.GetResult<Prisma.$PIGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PIGroup.
     * @param {PIGroupUpdateArgs} args - Arguments to update one PIGroup.
     * @example
     * // Update one PIGroup
     * const pIGroup = await prisma.pIGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PIGroupUpdateArgs>(args: SelectSubset<T, PIGroupUpdateArgs<ExtArgs>>): Prisma__PIGroupClient<$Result.GetResult<Prisma.$PIGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PIGroups.
     * @param {PIGroupDeleteManyArgs} args - Arguments to filter PIGroups to delete.
     * @example
     * // Delete a few PIGroups
     * const { count } = await prisma.pIGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PIGroupDeleteManyArgs>(args?: SelectSubset<T, PIGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PIGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PIGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PIGroups
     * const pIGroup = await prisma.pIGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PIGroupUpdateManyArgs>(args: SelectSubset<T, PIGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PIGroups and returns the data updated in the database.
     * @param {PIGroupUpdateManyAndReturnArgs} args - Arguments to update many PIGroups.
     * @example
     * // Update many PIGroups
     * const pIGroup = await prisma.pIGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PIGroups and only return the `id`
     * const pIGroupWithIdOnly = await prisma.pIGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PIGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, PIGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PIGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PIGroup.
     * @param {PIGroupUpsertArgs} args - Arguments to update or create a PIGroup.
     * @example
     * // Update or create a PIGroup
     * const pIGroup = await prisma.pIGroup.upsert({
     *   create: {
     *     // ... data to create a PIGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PIGroup we want to update
     *   }
     * })
     */
    upsert<T extends PIGroupUpsertArgs>(args: SelectSubset<T, PIGroupUpsertArgs<ExtArgs>>): Prisma__PIGroupClient<$Result.GetResult<Prisma.$PIGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PIGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PIGroupCountArgs} args - Arguments to filter PIGroups to count.
     * @example
     * // Count the number of PIGroups
     * const count = await prisma.pIGroup.count({
     *   where: {
     *     // ... the filter for the PIGroups we want to count
     *   }
     * })
    **/
    count<T extends PIGroupCountArgs>(
      args?: Subset<T, PIGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PIGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PIGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PIGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PIGroupAggregateArgs>(args: Subset<T, PIGroupAggregateArgs>): Prisma.PrismaPromise<GetPIGroupAggregateType<T>>

    /**
     * Group by PIGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PIGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PIGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PIGroupGroupByArgs['orderBy'] }
        : { orderBy?: PIGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PIGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPIGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PIGroup model
   */
  readonly fields: PIGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PIGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PIGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kurikulum<T extends KurikulumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KurikulumDefaultArgs<ExtArgs>>): Prisma__KurikulumClient<$Result.GetResult<Prisma.$KurikulumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    indicators<T extends PIGroup$indicatorsArgs<ExtArgs> = {}>(args?: Subset<T, PIGroup$indicatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceIndicatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cpl<T extends PIGroup$cplArgs<ExtArgs> = {}>(args?: Subset<T, PIGroup$cplArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CPLPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PIGroup model
   */
  interface PIGroupFieldRefs {
    readonly id: FieldRef<"PIGroup", 'Int'>
    readonly kode_grup: FieldRef<"PIGroup", 'String'>
    readonly nama_grup: FieldRef<"PIGroup", 'String'>
    readonly createdAt: FieldRef<"PIGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"PIGroup", 'DateTime'>
    readonly kurikulum_id: FieldRef<"PIGroup", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PIGroup findUnique
   */
  export type PIGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PIGroup
     */
    select?: PIGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PIGroup
     */
    omit?: PIGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PIGroupInclude<ExtArgs> | null
    /**
     * Filter, which PIGroup to fetch.
     */
    where: PIGroupWhereUniqueInput
  }

  /**
   * PIGroup findUniqueOrThrow
   */
  export type PIGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PIGroup
     */
    select?: PIGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PIGroup
     */
    omit?: PIGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PIGroupInclude<ExtArgs> | null
    /**
     * Filter, which PIGroup to fetch.
     */
    where: PIGroupWhereUniqueInput
  }

  /**
   * PIGroup findFirst
   */
  export type PIGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PIGroup
     */
    select?: PIGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PIGroup
     */
    omit?: PIGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PIGroupInclude<ExtArgs> | null
    /**
     * Filter, which PIGroup to fetch.
     */
    where?: PIGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PIGroups to fetch.
     */
    orderBy?: PIGroupOrderByWithRelationInput | PIGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PIGroups.
     */
    cursor?: PIGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PIGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PIGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PIGroups.
     */
    distinct?: PIGroupScalarFieldEnum | PIGroupScalarFieldEnum[]
  }

  /**
   * PIGroup findFirstOrThrow
   */
  export type PIGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PIGroup
     */
    select?: PIGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PIGroup
     */
    omit?: PIGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PIGroupInclude<ExtArgs> | null
    /**
     * Filter, which PIGroup to fetch.
     */
    where?: PIGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PIGroups to fetch.
     */
    orderBy?: PIGroupOrderByWithRelationInput | PIGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PIGroups.
     */
    cursor?: PIGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PIGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PIGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PIGroups.
     */
    distinct?: PIGroupScalarFieldEnum | PIGroupScalarFieldEnum[]
  }

  /**
   * PIGroup findMany
   */
  export type PIGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PIGroup
     */
    select?: PIGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PIGroup
     */
    omit?: PIGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PIGroupInclude<ExtArgs> | null
    /**
     * Filter, which PIGroups to fetch.
     */
    where?: PIGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PIGroups to fetch.
     */
    orderBy?: PIGroupOrderByWithRelationInput | PIGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PIGroups.
     */
    cursor?: PIGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PIGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PIGroups.
     */
    skip?: number
    distinct?: PIGroupScalarFieldEnum | PIGroupScalarFieldEnum[]
  }

  /**
   * PIGroup create
   */
  export type PIGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PIGroup
     */
    select?: PIGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PIGroup
     */
    omit?: PIGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PIGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a PIGroup.
     */
    data: XOR<PIGroupCreateInput, PIGroupUncheckedCreateInput>
  }

  /**
   * PIGroup createMany
   */
  export type PIGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PIGroups.
     */
    data: PIGroupCreateManyInput | PIGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PIGroup createManyAndReturn
   */
  export type PIGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PIGroup
     */
    select?: PIGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PIGroup
     */
    omit?: PIGroupOmit<ExtArgs> | null
    /**
     * The data used to create many PIGroups.
     */
    data: PIGroupCreateManyInput | PIGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PIGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PIGroup update
   */
  export type PIGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PIGroup
     */
    select?: PIGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PIGroup
     */
    omit?: PIGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PIGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a PIGroup.
     */
    data: XOR<PIGroupUpdateInput, PIGroupUncheckedUpdateInput>
    /**
     * Choose, which PIGroup to update.
     */
    where: PIGroupWhereUniqueInput
  }

  /**
   * PIGroup updateMany
   */
  export type PIGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PIGroups.
     */
    data: XOR<PIGroupUpdateManyMutationInput, PIGroupUncheckedUpdateManyInput>
    /**
     * Filter which PIGroups to update
     */
    where?: PIGroupWhereInput
    /**
     * Limit how many PIGroups to update.
     */
    limit?: number
  }

  /**
   * PIGroup updateManyAndReturn
   */
  export type PIGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PIGroup
     */
    select?: PIGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PIGroup
     */
    omit?: PIGroupOmit<ExtArgs> | null
    /**
     * The data used to update PIGroups.
     */
    data: XOR<PIGroupUpdateManyMutationInput, PIGroupUncheckedUpdateManyInput>
    /**
     * Filter which PIGroups to update
     */
    where?: PIGroupWhereInput
    /**
     * Limit how many PIGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PIGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PIGroup upsert
   */
  export type PIGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PIGroup
     */
    select?: PIGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PIGroup
     */
    omit?: PIGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PIGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the PIGroup to update in case it exists.
     */
    where: PIGroupWhereUniqueInput
    /**
     * In case the PIGroup found by the `where` argument doesn't exist, create a new PIGroup with this data.
     */
    create: XOR<PIGroupCreateInput, PIGroupUncheckedCreateInput>
    /**
     * In case the PIGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PIGroupUpdateInput, PIGroupUncheckedUpdateInput>
  }

  /**
   * PIGroup delete
   */
  export type PIGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PIGroup
     */
    select?: PIGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PIGroup
     */
    omit?: PIGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PIGroupInclude<ExtArgs> | null
    /**
     * Filter which PIGroup to delete.
     */
    where: PIGroupWhereUniqueInput
  }

  /**
   * PIGroup deleteMany
   */
  export type PIGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PIGroups to delete
     */
    where?: PIGroupWhereInput
    /**
     * Limit how many PIGroups to delete.
     */
    limit?: number
  }

  /**
   * PIGroup.indicators
   */
  export type PIGroup$indicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceIndicator
     */
    select?: PerformanceIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceIndicator
     */
    omit?: PerformanceIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceIndicatorInclude<ExtArgs> | null
    where?: PerformanceIndicatorWhereInput
    orderBy?: PerformanceIndicatorOrderByWithRelationInput | PerformanceIndicatorOrderByWithRelationInput[]
    cursor?: PerformanceIndicatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceIndicatorScalarFieldEnum | PerformanceIndicatorScalarFieldEnum[]
  }

  /**
   * PIGroup.cpl
   */
  export type PIGroup$cplArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPL
     */
    select?: CPLSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPL
     */
    omit?: CPLOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPLInclude<ExtArgs> | null
    where?: CPLWhereInput
    orderBy?: CPLOrderByWithRelationInput | CPLOrderByWithRelationInput[]
    cursor?: CPLWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CPLScalarFieldEnum | CPLScalarFieldEnum[]
  }

  /**
   * PIGroup without action
   */
  export type PIGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PIGroup
     */
    select?: PIGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PIGroup
     */
    omit?: PIGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PIGroupInclude<ExtArgs> | null
  }


  /**
   * Model PerformanceIndicator
   */

  export type AggregatePerformanceIndicator = {
    _count: PerformanceIndicatorCountAggregateOutputType | null
    _avg: PerformanceIndicatorAvgAggregateOutputType | null
    _sum: PerformanceIndicatorSumAggregateOutputType | null
    _min: PerformanceIndicatorMinAggregateOutputType | null
    _max: PerformanceIndicatorMaxAggregateOutputType | null
  }

  export type PerformanceIndicatorAvgAggregateOutputType = {
    id: number | null
    pi_group_id: number | null
  }

  export type PerformanceIndicatorSumAggregateOutputType = {
    id: number | null
    pi_group_id: number | null
  }

  export type PerformanceIndicatorMinAggregateOutputType = {
    id: number | null
    kode_pi: string | null
    deskripsi: string | null
    is_locked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    pi_group_id: number | null
  }

  export type PerformanceIndicatorMaxAggregateOutputType = {
    id: number | null
    kode_pi: string | null
    deskripsi: string | null
    is_locked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    pi_group_id: number | null
  }

  export type PerformanceIndicatorCountAggregateOutputType = {
    id: number
    kode_pi: number
    deskripsi: number
    is_locked: number
    createdAt: number
    updatedAt: number
    pi_group_id: number
    _all: number
  }


  export type PerformanceIndicatorAvgAggregateInputType = {
    id?: true
    pi_group_id?: true
  }

  export type PerformanceIndicatorSumAggregateInputType = {
    id?: true
    pi_group_id?: true
  }

  export type PerformanceIndicatorMinAggregateInputType = {
    id?: true
    kode_pi?: true
    deskripsi?: true
    is_locked?: true
    createdAt?: true
    updatedAt?: true
    pi_group_id?: true
  }

  export type PerformanceIndicatorMaxAggregateInputType = {
    id?: true
    kode_pi?: true
    deskripsi?: true
    is_locked?: true
    createdAt?: true
    updatedAt?: true
    pi_group_id?: true
  }

  export type PerformanceIndicatorCountAggregateInputType = {
    id?: true
    kode_pi?: true
    deskripsi?: true
    is_locked?: true
    createdAt?: true
    updatedAt?: true
    pi_group_id?: true
    _all?: true
  }

  export type PerformanceIndicatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceIndicator to aggregate.
     */
    where?: PerformanceIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceIndicators to fetch.
     */
    orderBy?: PerformanceIndicatorOrderByWithRelationInput | PerformanceIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceIndicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceIndicators
    **/
    _count?: true | PerformanceIndicatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceIndicatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceIndicatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceIndicatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceIndicatorMaxAggregateInputType
  }

  export type GetPerformanceIndicatorAggregateType<T extends PerformanceIndicatorAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceIndicator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceIndicator[P]>
      : GetScalarType<T[P], AggregatePerformanceIndicator[P]>
  }




  export type PerformanceIndicatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceIndicatorWhereInput
    orderBy?: PerformanceIndicatorOrderByWithAggregationInput | PerformanceIndicatorOrderByWithAggregationInput[]
    by: PerformanceIndicatorScalarFieldEnum[] | PerformanceIndicatorScalarFieldEnum
    having?: PerformanceIndicatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceIndicatorCountAggregateInputType | true
    _avg?: PerformanceIndicatorAvgAggregateInputType
    _sum?: PerformanceIndicatorSumAggregateInputType
    _min?: PerformanceIndicatorMinAggregateInputType
    _max?: PerformanceIndicatorMaxAggregateInputType
  }

  export type PerformanceIndicatorGroupByOutputType = {
    id: number
    kode_pi: string
    deskripsi: string
    is_locked: boolean
    createdAt: Date
    updatedAt: Date
    pi_group_id: number
    _count: PerformanceIndicatorCountAggregateOutputType | null
    _avg: PerformanceIndicatorAvgAggregateOutputType | null
    _sum: PerformanceIndicatorSumAggregateOutputType | null
    _min: PerformanceIndicatorMinAggregateOutputType | null
    _max: PerformanceIndicatorMaxAggregateOutputType | null
  }

  type GetPerformanceIndicatorGroupByPayload<T extends PerformanceIndicatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceIndicatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceIndicatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceIndicatorGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceIndicatorGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceIndicatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode_pi?: boolean
    deskripsi?: boolean
    is_locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pi_group_id?: boolean
    piGroup?: boolean | PIGroupDefaultArgs<ExtArgs>
    cpmkMap?: boolean | PerformanceIndicator$cpmkMapArgs<ExtArgs>
    _count?: boolean | PerformanceIndicatorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceIndicator"]>

  export type PerformanceIndicatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode_pi?: boolean
    deskripsi?: boolean
    is_locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pi_group_id?: boolean
    piGroup?: boolean | PIGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceIndicator"]>

  export type PerformanceIndicatorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode_pi?: boolean
    deskripsi?: boolean
    is_locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pi_group_id?: boolean
    piGroup?: boolean | PIGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceIndicator"]>

  export type PerformanceIndicatorSelectScalar = {
    id?: boolean
    kode_pi?: boolean
    deskripsi?: boolean
    is_locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pi_group_id?: boolean
  }

  export type PerformanceIndicatorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kode_pi" | "deskripsi" | "is_locked" | "createdAt" | "updatedAt" | "pi_group_id", ExtArgs["result"]["performanceIndicator"]>
  export type PerformanceIndicatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    piGroup?: boolean | PIGroupDefaultArgs<ExtArgs>
    cpmkMap?: boolean | PerformanceIndicator$cpmkMapArgs<ExtArgs>
    _count?: boolean | PerformanceIndicatorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PerformanceIndicatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    piGroup?: boolean | PIGroupDefaultArgs<ExtArgs>
  }
  export type PerformanceIndicatorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    piGroup?: boolean | PIGroupDefaultArgs<ExtArgs>
  }

  export type $PerformanceIndicatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceIndicator"
    objects: {
      piGroup: Prisma.$PIGroupPayload<ExtArgs>
      cpmkMap: Prisma.$CPMK_PI_MapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kode_pi: string
      deskripsi: string
      is_locked: boolean
      createdAt: Date
      updatedAt: Date
      pi_group_id: number
    }, ExtArgs["result"]["performanceIndicator"]>
    composites: {}
  }

  type PerformanceIndicatorGetPayload<S extends boolean | null | undefined | PerformanceIndicatorDefaultArgs> = $Result.GetResult<Prisma.$PerformanceIndicatorPayload, S>

  type PerformanceIndicatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerformanceIndicatorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformanceIndicatorCountAggregateInputType | true
    }

  export interface PerformanceIndicatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceIndicator'], meta: { name: 'PerformanceIndicator' } }
    /**
     * Find zero or one PerformanceIndicator that matches the filter.
     * @param {PerformanceIndicatorFindUniqueArgs} args - Arguments to find a PerformanceIndicator
     * @example
     * // Get one PerformanceIndicator
     * const performanceIndicator = await prisma.performanceIndicator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceIndicatorFindUniqueArgs>(args: SelectSubset<T, PerformanceIndicatorFindUniqueArgs<ExtArgs>>): Prisma__PerformanceIndicatorClient<$Result.GetResult<Prisma.$PerformanceIndicatorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PerformanceIndicator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerformanceIndicatorFindUniqueOrThrowArgs} args - Arguments to find a PerformanceIndicator
     * @example
     * // Get one PerformanceIndicator
     * const performanceIndicator = await prisma.performanceIndicator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceIndicatorFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceIndicatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceIndicatorClient<$Result.GetResult<Prisma.$PerformanceIndicatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceIndicator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceIndicatorFindFirstArgs} args - Arguments to find a PerformanceIndicator
     * @example
     * // Get one PerformanceIndicator
     * const performanceIndicator = await prisma.performanceIndicator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceIndicatorFindFirstArgs>(args?: SelectSubset<T, PerformanceIndicatorFindFirstArgs<ExtArgs>>): Prisma__PerformanceIndicatorClient<$Result.GetResult<Prisma.$PerformanceIndicatorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceIndicator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceIndicatorFindFirstOrThrowArgs} args - Arguments to find a PerformanceIndicator
     * @example
     * // Get one PerformanceIndicator
     * const performanceIndicator = await prisma.performanceIndicator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceIndicatorFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceIndicatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceIndicatorClient<$Result.GetResult<Prisma.$PerformanceIndicatorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PerformanceIndicators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceIndicatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceIndicators
     * const performanceIndicators = await prisma.performanceIndicator.findMany()
     * 
     * // Get first 10 PerformanceIndicators
     * const performanceIndicators = await prisma.performanceIndicator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceIndicatorWithIdOnly = await prisma.performanceIndicator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceIndicatorFindManyArgs>(args?: SelectSubset<T, PerformanceIndicatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceIndicatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PerformanceIndicator.
     * @param {PerformanceIndicatorCreateArgs} args - Arguments to create a PerformanceIndicator.
     * @example
     * // Create one PerformanceIndicator
     * const PerformanceIndicator = await prisma.performanceIndicator.create({
     *   data: {
     *     // ... data to create a PerformanceIndicator
     *   }
     * })
     * 
     */
    create<T extends PerformanceIndicatorCreateArgs>(args: SelectSubset<T, PerformanceIndicatorCreateArgs<ExtArgs>>): Prisma__PerformanceIndicatorClient<$Result.GetResult<Prisma.$PerformanceIndicatorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PerformanceIndicators.
     * @param {PerformanceIndicatorCreateManyArgs} args - Arguments to create many PerformanceIndicators.
     * @example
     * // Create many PerformanceIndicators
     * const performanceIndicator = await prisma.performanceIndicator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceIndicatorCreateManyArgs>(args?: SelectSubset<T, PerformanceIndicatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerformanceIndicators and returns the data saved in the database.
     * @param {PerformanceIndicatorCreateManyAndReturnArgs} args - Arguments to create many PerformanceIndicators.
     * @example
     * // Create many PerformanceIndicators
     * const performanceIndicator = await prisma.performanceIndicator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerformanceIndicators and only return the `id`
     * const performanceIndicatorWithIdOnly = await prisma.performanceIndicator.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerformanceIndicatorCreateManyAndReturnArgs>(args?: SelectSubset<T, PerformanceIndicatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceIndicatorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PerformanceIndicator.
     * @param {PerformanceIndicatorDeleteArgs} args - Arguments to delete one PerformanceIndicator.
     * @example
     * // Delete one PerformanceIndicator
     * const PerformanceIndicator = await prisma.performanceIndicator.delete({
     *   where: {
     *     // ... filter to delete one PerformanceIndicator
     *   }
     * })
     * 
     */
    delete<T extends PerformanceIndicatorDeleteArgs>(args: SelectSubset<T, PerformanceIndicatorDeleteArgs<ExtArgs>>): Prisma__PerformanceIndicatorClient<$Result.GetResult<Prisma.$PerformanceIndicatorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PerformanceIndicator.
     * @param {PerformanceIndicatorUpdateArgs} args - Arguments to update one PerformanceIndicator.
     * @example
     * // Update one PerformanceIndicator
     * const performanceIndicator = await prisma.performanceIndicator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceIndicatorUpdateArgs>(args: SelectSubset<T, PerformanceIndicatorUpdateArgs<ExtArgs>>): Prisma__PerformanceIndicatorClient<$Result.GetResult<Prisma.$PerformanceIndicatorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PerformanceIndicators.
     * @param {PerformanceIndicatorDeleteManyArgs} args - Arguments to filter PerformanceIndicators to delete.
     * @example
     * // Delete a few PerformanceIndicators
     * const { count } = await prisma.performanceIndicator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceIndicatorDeleteManyArgs>(args?: SelectSubset<T, PerformanceIndicatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceIndicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceIndicatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceIndicators
     * const performanceIndicator = await prisma.performanceIndicator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceIndicatorUpdateManyArgs>(args: SelectSubset<T, PerformanceIndicatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceIndicators and returns the data updated in the database.
     * @param {PerformanceIndicatorUpdateManyAndReturnArgs} args - Arguments to update many PerformanceIndicators.
     * @example
     * // Update many PerformanceIndicators
     * const performanceIndicator = await prisma.performanceIndicator.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PerformanceIndicators and only return the `id`
     * const performanceIndicatorWithIdOnly = await prisma.performanceIndicator.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PerformanceIndicatorUpdateManyAndReturnArgs>(args: SelectSubset<T, PerformanceIndicatorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceIndicatorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PerformanceIndicator.
     * @param {PerformanceIndicatorUpsertArgs} args - Arguments to update or create a PerformanceIndicator.
     * @example
     * // Update or create a PerformanceIndicator
     * const performanceIndicator = await prisma.performanceIndicator.upsert({
     *   create: {
     *     // ... data to create a PerformanceIndicator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceIndicator we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceIndicatorUpsertArgs>(args: SelectSubset<T, PerformanceIndicatorUpsertArgs<ExtArgs>>): Prisma__PerformanceIndicatorClient<$Result.GetResult<Prisma.$PerformanceIndicatorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PerformanceIndicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceIndicatorCountArgs} args - Arguments to filter PerformanceIndicators to count.
     * @example
     * // Count the number of PerformanceIndicators
     * const count = await prisma.performanceIndicator.count({
     *   where: {
     *     // ... the filter for the PerformanceIndicators we want to count
     *   }
     * })
    **/
    count<T extends PerformanceIndicatorCountArgs>(
      args?: Subset<T, PerformanceIndicatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceIndicatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceIndicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceIndicatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceIndicatorAggregateArgs>(args: Subset<T, PerformanceIndicatorAggregateArgs>): Prisma.PrismaPromise<GetPerformanceIndicatorAggregateType<T>>

    /**
     * Group by PerformanceIndicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceIndicatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceIndicatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceIndicatorGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceIndicatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceIndicatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceIndicatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceIndicator model
   */
  readonly fields: PerformanceIndicatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceIndicator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceIndicatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    piGroup<T extends PIGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PIGroupDefaultArgs<ExtArgs>>): Prisma__PIGroupClient<$Result.GetResult<Prisma.$PIGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cpmkMap<T extends PerformanceIndicator$cpmkMapArgs<ExtArgs> = {}>(args?: Subset<T, PerformanceIndicator$cpmkMapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CPMK_PI_MapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceIndicator model
   */
  interface PerformanceIndicatorFieldRefs {
    readonly id: FieldRef<"PerformanceIndicator", 'Int'>
    readonly kode_pi: FieldRef<"PerformanceIndicator", 'String'>
    readonly deskripsi: FieldRef<"PerformanceIndicator", 'String'>
    readonly is_locked: FieldRef<"PerformanceIndicator", 'Boolean'>
    readonly createdAt: FieldRef<"PerformanceIndicator", 'DateTime'>
    readonly updatedAt: FieldRef<"PerformanceIndicator", 'DateTime'>
    readonly pi_group_id: FieldRef<"PerformanceIndicator", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceIndicator findUnique
   */
  export type PerformanceIndicatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceIndicator
     */
    select?: PerformanceIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceIndicator
     */
    omit?: PerformanceIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceIndicator to fetch.
     */
    where: PerformanceIndicatorWhereUniqueInput
  }

  /**
   * PerformanceIndicator findUniqueOrThrow
   */
  export type PerformanceIndicatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceIndicator
     */
    select?: PerformanceIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceIndicator
     */
    omit?: PerformanceIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceIndicator to fetch.
     */
    where: PerformanceIndicatorWhereUniqueInput
  }

  /**
   * PerformanceIndicator findFirst
   */
  export type PerformanceIndicatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceIndicator
     */
    select?: PerformanceIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceIndicator
     */
    omit?: PerformanceIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceIndicator to fetch.
     */
    where?: PerformanceIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceIndicators to fetch.
     */
    orderBy?: PerformanceIndicatorOrderByWithRelationInput | PerformanceIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceIndicators.
     */
    cursor?: PerformanceIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceIndicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceIndicators.
     */
    distinct?: PerformanceIndicatorScalarFieldEnum | PerformanceIndicatorScalarFieldEnum[]
  }

  /**
   * PerformanceIndicator findFirstOrThrow
   */
  export type PerformanceIndicatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceIndicator
     */
    select?: PerformanceIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceIndicator
     */
    omit?: PerformanceIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceIndicator to fetch.
     */
    where?: PerformanceIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceIndicators to fetch.
     */
    orderBy?: PerformanceIndicatorOrderByWithRelationInput | PerformanceIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceIndicators.
     */
    cursor?: PerformanceIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceIndicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceIndicators.
     */
    distinct?: PerformanceIndicatorScalarFieldEnum | PerformanceIndicatorScalarFieldEnum[]
  }

  /**
   * PerformanceIndicator findMany
   */
  export type PerformanceIndicatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceIndicator
     */
    select?: PerformanceIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceIndicator
     */
    omit?: PerformanceIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceIndicators to fetch.
     */
    where?: PerformanceIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceIndicators to fetch.
     */
    orderBy?: PerformanceIndicatorOrderByWithRelationInput | PerformanceIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceIndicators.
     */
    cursor?: PerformanceIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceIndicators.
     */
    skip?: number
    distinct?: PerformanceIndicatorScalarFieldEnum | PerformanceIndicatorScalarFieldEnum[]
  }

  /**
   * PerformanceIndicator create
   */
  export type PerformanceIndicatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceIndicator
     */
    select?: PerformanceIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceIndicator
     */
    omit?: PerformanceIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceIndicatorInclude<ExtArgs> | null
    /**
     * The data needed to create a PerformanceIndicator.
     */
    data: XOR<PerformanceIndicatorCreateInput, PerformanceIndicatorUncheckedCreateInput>
  }

  /**
   * PerformanceIndicator createMany
   */
  export type PerformanceIndicatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceIndicators.
     */
    data: PerformanceIndicatorCreateManyInput | PerformanceIndicatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceIndicator createManyAndReturn
   */
  export type PerformanceIndicatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceIndicator
     */
    select?: PerformanceIndicatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceIndicator
     */
    omit?: PerformanceIndicatorOmit<ExtArgs> | null
    /**
     * The data used to create many PerformanceIndicators.
     */
    data: PerformanceIndicatorCreateManyInput | PerformanceIndicatorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceIndicatorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceIndicator update
   */
  export type PerformanceIndicatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceIndicator
     */
    select?: PerformanceIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceIndicator
     */
    omit?: PerformanceIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceIndicatorInclude<ExtArgs> | null
    /**
     * The data needed to update a PerformanceIndicator.
     */
    data: XOR<PerformanceIndicatorUpdateInput, PerformanceIndicatorUncheckedUpdateInput>
    /**
     * Choose, which PerformanceIndicator to update.
     */
    where: PerformanceIndicatorWhereUniqueInput
  }

  /**
   * PerformanceIndicator updateMany
   */
  export type PerformanceIndicatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceIndicators.
     */
    data: XOR<PerformanceIndicatorUpdateManyMutationInput, PerformanceIndicatorUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceIndicators to update
     */
    where?: PerformanceIndicatorWhereInput
    /**
     * Limit how many PerformanceIndicators to update.
     */
    limit?: number
  }

  /**
   * PerformanceIndicator updateManyAndReturn
   */
  export type PerformanceIndicatorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceIndicator
     */
    select?: PerformanceIndicatorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceIndicator
     */
    omit?: PerformanceIndicatorOmit<ExtArgs> | null
    /**
     * The data used to update PerformanceIndicators.
     */
    data: XOR<PerformanceIndicatorUpdateManyMutationInput, PerformanceIndicatorUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceIndicators to update
     */
    where?: PerformanceIndicatorWhereInput
    /**
     * Limit how many PerformanceIndicators to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceIndicatorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceIndicator upsert
   */
  export type PerformanceIndicatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceIndicator
     */
    select?: PerformanceIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceIndicator
     */
    omit?: PerformanceIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceIndicatorInclude<ExtArgs> | null
    /**
     * The filter to search for the PerformanceIndicator to update in case it exists.
     */
    where: PerformanceIndicatorWhereUniqueInput
    /**
     * In case the PerformanceIndicator found by the `where` argument doesn't exist, create a new PerformanceIndicator with this data.
     */
    create: XOR<PerformanceIndicatorCreateInput, PerformanceIndicatorUncheckedCreateInput>
    /**
     * In case the PerformanceIndicator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceIndicatorUpdateInput, PerformanceIndicatorUncheckedUpdateInput>
  }

  /**
   * PerformanceIndicator delete
   */
  export type PerformanceIndicatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceIndicator
     */
    select?: PerformanceIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceIndicator
     */
    omit?: PerformanceIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceIndicatorInclude<ExtArgs> | null
    /**
     * Filter which PerformanceIndicator to delete.
     */
    where: PerformanceIndicatorWhereUniqueInput
  }

  /**
   * PerformanceIndicator deleteMany
   */
  export type PerformanceIndicatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceIndicators to delete
     */
    where?: PerformanceIndicatorWhereInput
    /**
     * Limit how many PerformanceIndicators to delete.
     */
    limit?: number
  }

  /**
   * PerformanceIndicator.cpmkMap
   */
  export type PerformanceIndicator$cpmkMapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK_PI_Map
     */
    select?: CPMK_PI_MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK_PI_Map
     */
    omit?: CPMK_PI_MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMK_PI_MapInclude<ExtArgs> | null
    where?: CPMK_PI_MapWhereInput
    orderBy?: CPMK_PI_MapOrderByWithRelationInput | CPMK_PI_MapOrderByWithRelationInput[]
    cursor?: CPMK_PI_MapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CPMK_PI_MapScalarFieldEnum | CPMK_PI_MapScalarFieldEnum[]
  }

  /**
   * PerformanceIndicator without action
   */
  export type PerformanceIndicatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceIndicator
     */
    select?: PerformanceIndicatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceIndicator
     */
    omit?: PerformanceIndicatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceIndicatorInclude<ExtArgs> | null
  }


  /**
   * Model CPL
   */

  export type AggregateCPL = {
    _count: CPLCountAggregateOutputType | null
    _avg: CPLAvgAggregateOutputType | null
    _sum: CPLSumAggregateOutputType | null
    _min: CPLMinAggregateOutputType | null
    _max: CPLMaxAggregateOutputType | null
  }

  export type CPLAvgAggregateOutputType = {
    id: number | null
    kurikulum_id: number | null
    pi_group_id: number | null
  }

  export type CPLSumAggregateOutputType = {
    id: number | null
    kurikulum_id: number | null
    pi_group_id: number | null
  }

  export type CPLMinAggregateOutputType = {
    id: number | null
    kode_cpl: string | null
    deskripsi: string | null
    createdAt: Date | null
    updatedAt: Date | null
    kurikulum_id: number | null
    pi_group_id: number | null
  }

  export type CPLMaxAggregateOutputType = {
    id: number | null
    kode_cpl: string | null
    deskripsi: string | null
    createdAt: Date | null
    updatedAt: Date | null
    kurikulum_id: number | null
    pi_group_id: number | null
  }

  export type CPLCountAggregateOutputType = {
    id: number
    kode_cpl: number
    deskripsi: number
    createdAt: number
    updatedAt: number
    kurikulum_id: number
    pi_group_id: number
    _all: number
  }


  export type CPLAvgAggregateInputType = {
    id?: true
    kurikulum_id?: true
    pi_group_id?: true
  }

  export type CPLSumAggregateInputType = {
    id?: true
    kurikulum_id?: true
    pi_group_id?: true
  }

  export type CPLMinAggregateInputType = {
    id?: true
    kode_cpl?: true
    deskripsi?: true
    createdAt?: true
    updatedAt?: true
    kurikulum_id?: true
    pi_group_id?: true
  }

  export type CPLMaxAggregateInputType = {
    id?: true
    kode_cpl?: true
    deskripsi?: true
    createdAt?: true
    updatedAt?: true
    kurikulum_id?: true
    pi_group_id?: true
  }

  export type CPLCountAggregateInputType = {
    id?: true
    kode_cpl?: true
    deskripsi?: true
    createdAt?: true
    updatedAt?: true
    kurikulum_id?: true
    pi_group_id?: true
    _all?: true
  }

  export type CPLAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CPL to aggregate.
     */
    where?: CPLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CPLS to fetch.
     */
    orderBy?: CPLOrderByWithRelationInput | CPLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CPLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CPLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CPLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CPLS
    **/
    _count?: true | CPLCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CPLAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CPLSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CPLMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CPLMaxAggregateInputType
  }

  export type GetCPLAggregateType<T extends CPLAggregateArgs> = {
        [P in keyof T & keyof AggregateCPL]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCPL[P]>
      : GetScalarType<T[P], AggregateCPL[P]>
  }




  export type CPLGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CPLWhereInput
    orderBy?: CPLOrderByWithAggregationInput | CPLOrderByWithAggregationInput[]
    by: CPLScalarFieldEnum[] | CPLScalarFieldEnum
    having?: CPLScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CPLCountAggregateInputType | true
    _avg?: CPLAvgAggregateInputType
    _sum?: CPLSumAggregateInputType
    _min?: CPLMinAggregateInputType
    _max?: CPLMaxAggregateInputType
  }

  export type CPLGroupByOutputType = {
    id: number
    kode_cpl: string
    deskripsi: string
    createdAt: Date
    updatedAt: Date
    kurikulum_id: number
    pi_group_id: number
    _count: CPLCountAggregateOutputType | null
    _avg: CPLAvgAggregateOutputType | null
    _sum: CPLSumAggregateOutputType | null
    _min: CPLMinAggregateOutputType | null
    _max: CPLMaxAggregateOutputType | null
  }

  type GetCPLGroupByPayload<T extends CPLGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CPLGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CPLGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CPLGroupByOutputType[P]>
            : GetScalarType<T[P], CPLGroupByOutputType[P]>
        }
      >
    >


  export type CPLSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode_cpl?: boolean
    deskripsi?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kurikulum_id?: boolean
    pi_group_id?: boolean
    kurikulum?: boolean | KurikulumDefaultArgs<ExtArgs>
    piGroup?: boolean | PIGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cPL"]>

  export type CPLSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode_cpl?: boolean
    deskripsi?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kurikulum_id?: boolean
    pi_group_id?: boolean
    kurikulum?: boolean | KurikulumDefaultArgs<ExtArgs>
    piGroup?: boolean | PIGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cPL"]>

  export type CPLSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode_cpl?: boolean
    deskripsi?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kurikulum_id?: boolean
    pi_group_id?: boolean
    kurikulum?: boolean | KurikulumDefaultArgs<ExtArgs>
    piGroup?: boolean | PIGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cPL"]>

  export type CPLSelectScalar = {
    id?: boolean
    kode_cpl?: boolean
    deskripsi?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kurikulum_id?: boolean
    pi_group_id?: boolean
  }

  export type CPLOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kode_cpl" | "deskripsi" | "createdAt" | "updatedAt" | "kurikulum_id" | "pi_group_id", ExtArgs["result"]["cPL"]>
  export type CPLInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kurikulum?: boolean | KurikulumDefaultArgs<ExtArgs>
    piGroup?: boolean | PIGroupDefaultArgs<ExtArgs>
  }
  export type CPLIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kurikulum?: boolean | KurikulumDefaultArgs<ExtArgs>
    piGroup?: boolean | PIGroupDefaultArgs<ExtArgs>
  }
  export type CPLIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kurikulum?: boolean | KurikulumDefaultArgs<ExtArgs>
    piGroup?: boolean | PIGroupDefaultArgs<ExtArgs>
  }

  export type $CPLPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CPL"
    objects: {
      kurikulum: Prisma.$KurikulumPayload<ExtArgs>
      piGroup: Prisma.$PIGroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kode_cpl: string
      deskripsi: string
      createdAt: Date
      updatedAt: Date
      kurikulum_id: number
      pi_group_id: number
    }, ExtArgs["result"]["cPL"]>
    composites: {}
  }

  type CPLGetPayload<S extends boolean | null | undefined | CPLDefaultArgs> = $Result.GetResult<Prisma.$CPLPayload, S>

  type CPLCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CPLFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CPLCountAggregateInputType | true
    }

  export interface CPLDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CPL'], meta: { name: 'CPL' } }
    /**
     * Find zero or one CPL that matches the filter.
     * @param {CPLFindUniqueArgs} args - Arguments to find a CPL
     * @example
     * // Get one CPL
     * const cPL = await prisma.cPL.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CPLFindUniqueArgs>(args: SelectSubset<T, CPLFindUniqueArgs<ExtArgs>>): Prisma__CPLClient<$Result.GetResult<Prisma.$CPLPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CPL that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CPLFindUniqueOrThrowArgs} args - Arguments to find a CPL
     * @example
     * // Get one CPL
     * const cPL = await prisma.cPL.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CPLFindUniqueOrThrowArgs>(args: SelectSubset<T, CPLFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CPLClient<$Result.GetResult<Prisma.$CPLPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CPL that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPLFindFirstArgs} args - Arguments to find a CPL
     * @example
     * // Get one CPL
     * const cPL = await prisma.cPL.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CPLFindFirstArgs>(args?: SelectSubset<T, CPLFindFirstArgs<ExtArgs>>): Prisma__CPLClient<$Result.GetResult<Prisma.$CPLPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CPL that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPLFindFirstOrThrowArgs} args - Arguments to find a CPL
     * @example
     * // Get one CPL
     * const cPL = await prisma.cPL.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CPLFindFirstOrThrowArgs>(args?: SelectSubset<T, CPLFindFirstOrThrowArgs<ExtArgs>>): Prisma__CPLClient<$Result.GetResult<Prisma.$CPLPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CPLS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPLFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CPLS
     * const cPLS = await prisma.cPL.findMany()
     * 
     * // Get first 10 CPLS
     * const cPLS = await prisma.cPL.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cPLWithIdOnly = await prisma.cPL.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CPLFindManyArgs>(args?: SelectSubset<T, CPLFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CPLPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CPL.
     * @param {CPLCreateArgs} args - Arguments to create a CPL.
     * @example
     * // Create one CPL
     * const CPL = await prisma.cPL.create({
     *   data: {
     *     // ... data to create a CPL
     *   }
     * })
     * 
     */
    create<T extends CPLCreateArgs>(args: SelectSubset<T, CPLCreateArgs<ExtArgs>>): Prisma__CPLClient<$Result.GetResult<Prisma.$CPLPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CPLS.
     * @param {CPLCreateManyArgs} args - Arguments to create many CPLS.
     * @example
     * // Create many CPLS
     * const cPL = await prisma.cPL.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CPLCreateManyArgs>(args?: SelectSubset<T, CPLCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CPLS and returns the data saved in the database.
     * @param {CPLCreateManyAndReturnArgs} args - Arguments to create many CPLS.
     * @example
     * // Create many CPLS
     * const cPL = await prisma.cPL.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CPLS and only return the `id`
     * const cPLWithIdOnly = await prisma.cPL.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CPLCreateManyAndReturnArgs>(args?: SelectSubset<T, CPLCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CPLPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CPL.
     * @param {CPLDeleteArgs} args - Arguments to delete one CPL.
     * @example
     * // Delete one CPL
     * const CPL = await prisma.cPL.delete({
     *   where: {
     *     // ... filter to delete one CPL
     *   }
     * })
     * 
     */
    delete<T extends CPLDeleteArgs>(args: SelectSubset<T, CPLDeleteArgs<ExtArgs>>): Prisma__CPLClient<$Result.GetResult<Prisma.$CPLPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CPL.
     * @param {CPLUpdateArgs} args - Arguments to update one CPL.
     * @example
     * // Update one CPL
     * const cPL = await prisma.cPL.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CPLUpdateArgs>(args: SelectSubset<T, CPLUpdateArgs<ExtArgs>>): Prisma__CPLClient<$Result.GetResult<Prisma.$CPLPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CPLS.
     * @param {CPLDeleteManyArgs} args - Arguments to filter CPLS to delete.
     * @example
     * // Delete a few CPLS
     * const { count } = await prisma.cPL.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CPLDeleteManyArgs>(args?: SelectSubset<T, CPLDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CPLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPLUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CPLS
     * const cPL = await prisma.cPL.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CPLUpdateManyArgs>(args: SelectSubset<T, CPLUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CPLS and returns the data updated in the database.
     * @param {CPLUpdateManyAndReturnArgs} args - Arguments to update many CPLS.
     * @example
     * // Update many CPLS
     * const cPL = await prisma.cPL.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CPLS and only return the `id`
     * const cPLWithIdOnly = await prisma.cPL.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CPLUpdateManyAndReturnArgs>(args: SelectSubset<T, CPLUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CPLPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CPL.
     * @param {CPLUpsertArgs} args - Arguments to update or create a CPL.
     * @example
     * // Update or create a CPL
     * const cPL = await prisma.cPL.upsert({
     *   create: {
     *     // ... data to create a CPL
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CPL we want to update
     *   }
     * })
     */
    upsert<T extends CPLUpsertArgs>(args: SelectSubset<T, CPLUpsertArgs<ExtArgs>>): Prisma__CPLClient<$Result.GetResult<Prisma.$CPLPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CPLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPLCountArgs} args - Arguments to filter CPLS to count.
     * @example
     * // Count the number of CPLS
     * const count = await prisma.cPL.count({
     *   where: {
     *     // ... the filter for the CPLS we want to count
     *   }
     * })
    **/
    count<T extends CPLCountArgs>(
      args?: Subset<T, CPLCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CPLCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CPL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPLAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CPLAggregateArgs>(args: Subset<T, CPLAggregateArgs>): Prisma.PrismaPromise<GetCPLAggregateType<T>>

    /**
     * Group by CPL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPLGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CPLGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CPLGroupByArgs['orderBy'] }
        : { orderBy?: CPLGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CPLGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCPLGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CPL model
   */
  readonly fields: CPLFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CPL.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CPLClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kurikulum<T extends KurikulumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KurikulumDefaultArgs<ExtArgs>>): Prisma__KurikulumClient<$Result.GetResult<Prisma.$KurikulumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    piGroup<T extends PIGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PIGroupDefaultArgs<ExtArgs>>): Prisma__PIGroupClient<$Result.GetResult<Prisma.$PIGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CPL model
   */
  interface CPLFieldRefs {
    readonly id: FieldRef<"CPL", 'Int'>
    readonly kode_cpl: FieldRef<"CPL", 'String'>
    readonly deskripsi: FieldRef<"CPL", 'String'>
    readonly createdAt: FieldRef<"CPL", 'DateTime'>
    readonly updatedAt: FieldRef<"CPL", 'DateTime'>
    readonly kurikulum_id: FieldRef<"CPL", 'Int'>
    readonly pi_group_id: FieldRef<"CPL", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CPL findUnique
   */
  export type CPLFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPL
     */
    select?: CPLSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPL
     */
    omit?: CPLOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPLInclude<ExtArgs> | null
    /**
     * Filter, which CPL to fetch.
     */
    where: CPLWhereUniqueInput
  }

  /**
   * CPL findUniqueOrThrow
   */
  export type CPLFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPL
     */
    select?: CPLSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPL
     */
    omit?: CPLOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPLInclude<ExtArgs> | null
    /**
     * Filter, which CPL to fetch.
     */
    where: CPLWhereUniqueInput
  }

  /**
   * CPL findFirst
   */
  export type CPLFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPL
     */
    select?: CPLSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPL
     */
    omit?: CPLOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPLInclude<ExtArgs> | null
    /**
     * Filter, which CPL to fetch.
     */
    where?: CPLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CPLS to fetch.
     */
    orderBy?: CPLOrderByWithRelationInput | CPLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CPLS.
     */
    cursor?: CPLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CPLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CPLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CPLS.
     */
    distinct?: CPLScalarFieldEnum | CPLScalarFieldEnum[]
  }

  /**
   * CPL findFirstOrThrow
   */
  export type CPLFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPL
     */
    select?: CPLSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPL
     */
    omit?: CPLOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPLInclude<ExtArgs> | null
    /**
     * Filter, which CPL to fetch.
     */
    where?: CPLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CPLS to fetch.
     */
    orderBy?: CPLOrderByWithRelationInput | CPLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CPLS.
     */
    cursor?: CPLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CPLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CPLS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CPLS.
     */
    distinct?: CPLScalarFieldEnum | CPLScalarFieldEnum[]
  }

  /**
   * CPL findMany
   */
  export type CPLFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPL
     */
    select?: CPLSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPL
     */
    omit?: CPLOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPLInclude<ExtArgs> | null
    /**
     * Filter, which CPLS to fetch.
     */
    where?: CPLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CPLS to fetch.
     */
    orderBy?: CPLOrderByWithRelationInput | CPLOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CPLS.
     */
    cursor?: CPLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CPLS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CPLS.
     */
    skip?: number
    distinct?: CPLScalarFieldEnum | CPLScalarFieldEnum[]
  }

  /**
   * CPL create
   */
  export type CPLCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPL
     */
    select?: CPLSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPL
     */
    omit?: CPLOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPLInclude<ExtArgs> | null
    /**
     * The data needed to create a CPL.
     */
    data: XOR<CPLCreateInput, CPLUncheckedCreateInput>
  }

  /**
   * CPL createMany
   */
  export type CPLCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CPLS.
     */
    data: CPLCreateManyInput | CPLCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CPL createManyAndReturn
   */
  export type CPLCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPL
     */
    select?: CPLSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CPL
     */
    omit?: CPLOmit<ExtArgs> | null
    /**
     * The data used to create many CPLS.
     */
    data: CPLCreateManyInput | CPLCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPLIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CPL update
   */
  export type CPLUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPL
     */
    select?: CPLSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPL
     */
    omit?: CPLOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPLInclude<ExtArgs> | null
    /**
     * The data needed to update a CPL.
     */
    data: XOR<CPLUpdateInput, CPLUncheckedUpdateInput>
    /**
     * Choose, which CPL to update.
     */
    where: CPLWhereUniqueInput
  }

  /**
   * CPL updateMany
   */
  export type CPLUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CPLS.
     */
    data: XOR<CPLUpdateManyMutationInput, CPLUncheckedUpdateManyInput>
    /**
     * Filter which CPLS to update
     */
    where?: CPLWhereInput
    /**
     * Limit how many CPLS to update.
     */
    limit?: number
  }

  /**
   * CPL updateManyAndReturn
   */
  export type CPLUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPL
     */
    select?: CPLSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CPL
     */
    omit?: CPLOmit<ExtArgs> | null
    /**
     * The data used to update CPLS.
     */
    data: XOR<CPLUpdateManyMutationInput, CPLUncheckedUpdateManyInput>
    /**
     * Filter which CPLS to update
     */
    where?: CPLWhereInput
    /**
     * Limit how many CPLS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPLIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CPL upsert
   */
  export type CPLUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPL
     */
    select?: CPLSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPL
     */
    omit?: CPLOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPLInclude<ExtArgs> | null
    /**
     * The filter to search for the CPL to update in case it exists.
     */
    where: CPLWhereUniqueInput
    /**
     * In case the CPL found by the `where` argument doesn't exist, create a new CPL with this data.
     */
    create: XOR<CPLCreateInput, CPLUncheckedCreateInput>
    /**
     * In case the CPL was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CPLUpdateInput, CPLUncheckedUpdateInput>
  }

  /**
   * CPL delete
   */
  export type CPLDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPL
     */
    select?: CPLSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPL
     */
    omit?: CPLOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPLInclude<ExtArgs> | null
    /**
     * Filter which CPL to delete.
     */
    where: CPLWhereUniqueInput
  }

  /**
   * CPL deleteMany
   */
  export type CPLDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CPLS to delete
     */
    where?: CPLWhereInput
    /**
     * Limit how many CPLS to delete.
     */
    limit?: number
  }

  /**
   * CPL without action
   */
  export type CPLDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPL
     */
    select?: CPLSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPL
     */
    omit?: CPLOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPLInclude<ExtArgs> | null
  }


  /**
   * Model TahunAjaran
   */

  export type AggregateTahunAjaran = {
    _count: TahunAjaranCountAggregateOutputType | null
    _avg: TahunAjaranAvgAggregateOutputType | null
    _sum: TahunAjaranSumAggregateOutputType | null
    _min: TahunAjaranMinAggregateOutputType | null
    _max: TahunAjaranMaxAggregateOutputType | null
  }

  export type TahunAjaranAvgAggregateOutputType = {
    id: number | null
  }

  export type TahunAjaranSumAggregateOutputType = {
    id: number | null
  }

  export type TahunAjaranMinAggregateOutputType = {
    id: number | null
    tahun: string | null
    semester: $Enums.Semester | null
  }

  export type TahunAjaranMaxAggregateOutputType = {
    id: number | null
    tahun: string | null
    semester: $Enums.Semester | null
  }

  export type TahunAjaranCountAggregateOutputType = {
    id: number
    tahun: number
    semester: number
    _all: number
  }


  export type TahunAjaranAvgAggregateInputType = {
    id?: true
  }

  export type TahunAjaranSumAggregateInputType = {
    id?: true
  }

  export type TahunAjaranMinAggregateInputType = {
    id?: true
    tahun?: true
    semester?: true
  }

  export type TahunAjaranMaxAggregateInputType = {
    id?: true
    tahun?: true
    semester?: true
  }

  export type TahunAjaranCountAggregateInputType = {
    id?: true
    tahun?: true
    semester?: true
    _all?: true
  }

  export type TahunAjaranAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TahunAjaran to aggregate.
     */
    where?: TahunAjaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TahunAjarans to fetch.
     */
    orderBy?: TahunAjaranOrderByWithRelationInput | TahunAjaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TahunAjaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TahunAjarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TahunAjarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TahunAjarans
    **/
    _count?: true | TahunAjaranCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TahunAjaranAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TahunAjaranSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TahunAjaranMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TahunAjaranMaxAggregateInputType
  }

  export type GetTahunAjaranAggregateType<T extends TahunAjaranAggregateArgs> = {
        [P in keyof T & keyof AggregateTahunAjaran]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTahunAjaran[P]>
      : GetScalarType<T[P], AggregateTahunAjaran[P]>
  }




  export type TahunAjaranGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TahunAjaranWhereInput
    orderBy?: TahunAjaranOrderByWithAggregationInput | TahunAjaranOrderByWithAggregationInput[]
    by: TahunAjaranScalarFieldEnum[] | TahunAjaranScalarFieldEnum
    having?: TahunAjaranScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TahunAjaranCountAggregateInputType | true
    _avg?: TahunAjaranAvgAggregateInputType
    _sum?: TahunAjaranSumAggregateInputType
    _min?: TahunAjaranMinAggregateInputType
    _max?: TahunAjaranMaxAggregateInputType
  }

  export type TahunAjaranGroupByOutputType = {
    id: number
    tahun: string
    semester: $Enums.Semester
    _count: TahunAjaranCountAggregateOutputType | null
    _avg: TahunAjaranAvgAggregateOutputType | null
    _sum: TahunAjaranSumAggregateOutputType | null
    _min: TahunAjaranMinAggregateOutputType | null
    _max: TahunAjaranMaxAggregateOutputType | null
  }

  type GetTahunAjaranGroupByPayload<T extends TahunAjaranGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TahunAjaranGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TahunAjaranGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TahunAjaranGroupByOutputType[P]>
            : GetScalarType<T[P], TahunAjaranGroupByOutputType[P]>
        }
      >
    >


  export type TahunAjaranSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tahun?: boolean
    semester?: boolean
    kelas?: boolean | TahunAjaran$kelasArgs<ExtArgs>
    _count?: boolean | TahunAjaranCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tahunAjaran"]>

  export type TahunAjaranSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tahun?: boolean
    semester?: boolean
  }, ExtArgs["result"]["tahunAjaran"]>

  export type TahunAjaranSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tahun?: boolean
    semester?: boolean
  }, ExtArgs["result"]["tahunAjaran"]>

  export type TahunAjaranSelectScalar = {
    id?: boolean
    tahun?: boolean
    semester?: boolean
  }

  export type TahunAjaranOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tahun" | "semester", ExtArgs["result"]["tahunAjaran"]>
  export type TahunAjaranInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kelas?: boolean | TahunAjaran$kelasArgs<ExtArgs>
    _count?: boolean | TahunAjaranCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TahunAjaranIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TahunAjaranIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TahunAjaranPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TahunAjaran"
    objects: {
      kelas: Prisma.$KelasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tahun: string
      semester: $Enums.Semester
    }, ExtArgs["result"]["tahunAjaran"]>
    composites: {}
  }

  type TahunAjaranGetPayload<S extends boolean | null | undefined | TahunAjaranDefaultArgs> = $Result.GetResult<Prisma.$TahunAjaranPayload, S>

  type TahunAjaranCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TahunAjaranFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TahunAjaranCountAggregateInputType | true
    }

  export interface TahunAjaranDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TahunAjaran'], meta: { name: 'TahunAjaran' } }
    /**
     * Find zero or one TahunAjaran that matches the filter.
     * @param {TahunAjaranFindUniqueArgs} args - Arguments to find a TahunAjaran
     * @example
     * // Get one TahunAjaran
     * const tahunAjaran = await prisma.tahunAjaran.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TahunAjaranFindUniqueArgs>(args: SelectSubset<T, TahunAjaranFindUniqueArgs<ExtArgs>>): Prisma__TahunAjaranClient<$Result.GetResult<Prisma.$TahunAjaranPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TahunAjaran that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TahunAjaranFindUniqueOrThrowArgs} args - Arguments to find a TahunAjaran
     * @example
     * // Get one TahunAjaran
     * const tahunAjaran = await prisma.tahunAjaran.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TahunAjaranFindUniqueOrThrowArgs>(args: SelectSubset<T, TahunAjaranFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TahunAjaranClient<$Result.GetResult<Prisma.$TahunAjaranPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TahunAjaran that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahunAjaranFindFirstArgs} args - Arguments to find a TahunAjaran
     * @example
     * // Get one TahunAjaran
     * const tahunAjaran = await prisma.tahunAjaran.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TahunAjaranFindFirstArgs>(args?: SelectSubset<T, TahunAjaranFindFirstArgs<ExtArgs>>): Prisma__TahunAjaranClient<$Result.GetResult<Prisma.$TahunAjaranPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TahunAjaran that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahunAjaranFindFirstOrThrowArgs} args - Arguments to find a TahunAjaran
     * @example
     * // Get one TahunAjaran
     * const tahunAjaran = await prisma.tahunAjaran.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TahunAjaranFindFirstOrThrowArgs>(args?: SelectSubset<T, TahunAjaranFindFirstOrThrowArgs<ExtArgs>>): Prisma__TahunAjaranClient<$Result.GetResult<Prisma.$TahunAjaranPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TahunAjarans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahunAjaranFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TahunAjarans
     * const tahunAjarans = await prisma.tahunAjaran.findMany()
     * 
     * // Get first 10 TahunAjarans
     * const tahunAjarans = await prisma.tahunAjaran.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tahunAjaranWithIdOnly = await prisma.tahunAjaran.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TahunAjaranFindManyArgs>(args?: SelectSubset<T, TahunAjaranFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TahunAjaranPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TahunAjaran.
     * @param {TahunAjaranCreateArgs} args - Arguments to create a TahunAjaran.
     * @example
     * // Create one TahunAjaran
     * const TahunAjaran = await prisma.tahunAjaran.create({
     *   data: {
     *     // ... data to create a TahunAjaran
     *   }
     * })
     * 
     */
    create<T extends TahunAjaranCreateArgs>(args: SelectSubset<T, TahunAjaranCreateArgs<ExtArgs>>): Prisma__TahunAjaranClient<$Result.GetResult<Prisma.$TahunAjaranPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TahunAjarans.
     * @param {TahunAjaranCreateManyArgs} args - Arguments to create many TahunAjarans.
     * @example
     * // Create many TahunAjarans
     * const tahunAjaran = await prisma.tahunAjaran.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TahunAjaranCreateManyArgs>(args?: SelectSubset<T, TahunAjaranCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TahunAjarans and returns the data saved in the database.
     * @param {TahunAjaranCreateManyAndReturnArgs} args - Arguments to create many TahunAjarans.
     * @example
     * // Create many TahunAjarans
     * const tahunAjaran = await prisma.tahunAjaran.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TahunAjarans and only return the `id`
     * const tahunAjaranWithIdOnly = await prisma.tahunAjaran.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TahunAjaranCreateManyAndReturnArgs>(args?: SelectSubset<T, TahunAjaranCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TahunAjaranPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TahunAjaran.
     * @param {TahunAjaranDeleteArgs} args - Arguments to delete one TahunAjaran.
     * @example
     * // Delete one TahunAjaran
     * const TahunAjaran = await prisma.tahunAjaran.delete({
     *   where: {
     *     // ... filter to delete one TahunAjaran
     *   }
     * })
     * 
     */
    delete<T extends TahunAjaranDeleteArgs>(args: SelectSubset<T, TahunAjaranDeleteArgs<ExtArgs>>): Prisma__TahunAjaranClient<$Result.GetResult<Prisma.$TahunAjaranPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TahunAjaran.
     * @param {TahunAjaranUpdateArgs} args - Arguments to update one TahunAjaran.
     * @example
     * // Update one TahunAjaran
     * const tahunAjaran = await prisma.tahunAjaran.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TahunAjaranUpdateArgs>(args: SelectSubset<T, TahunAjaranUpdateArgs<ExtArgs>>): Prisma__TahunAjaranClient<$Result.GetResult<Prisma.$TahunAjaranPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TahunAjarans.
     * @param {TahunAjaranDeleteManyArgs} args - Arguments to filter TahunAjarans to delete.
     * @example
     * // Delete a few TahunAjarans
     * const { count } = await prisma.tahunAjaran.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TahunAjaranDeleteManyArgs>(args?: SelectSubset<T, TahunAjaranDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TahunAjarans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahunAjaranUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TahunAjarans
     * const tahunAjaran = await prisma.tahunAjaran.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TahunAjaranUpdateManyArgs>(args: SelectSubset<T, TahunAjaranUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TahunAjarans and returns the data updated in the database.
     * @param {TahunAjaranUpdateManyAndReturnArgs} args - Arguments to update many TahunAjarans.
     * @example
     * // Update many TahunAjarans
     * const tahunAjaran = await prisma.tahunAjaran.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TahunAjarans and only return the `id`
     * const tahunAjaranWithIdOnly = await prisma.tahunAjaran.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TahunAjaranUpdateManyAndReturnArgs>(args: SelectSubset<T, TahunAjaranUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TahunAjaranPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TahunAjaran.
     * @param {TahunAjaranUpsertArgs} args - Arguments to update or create a TahunAjaran.
     * @example
     * // Update or create a TahunAjaran
     * const tahunAjaran = await prisma.tahunAjaran.upsert({
     *   create: {
     *     // ... data to create a TahunAjaran
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TahunAjaran we want to update
     *   }
     * })
     */
    upsert<T extends TahunAjaranUpsertArgs>(args: SelectSubset<T, TahunAjaranUpsertArgs<ExtArgs>>): Prisma__TahunAjaranClient<$Result.GetResult<Prisma.$TahunAjaranPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TahunAjarans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahunAjaranCountArgs} args - Arguments to filter TahunAjarans to count.
     * @example
     * // Count the number of TahunAjarans
     * const count = await prisma.tahunAjaran.count({
     *   where: {
     *     // ... the filter for the TahunAjarans we want to count
     *   }
     * })
    **/
    count<T extends TahunAjaranCountArgs>(
      args?: Subset<T, TahunAjaranCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TahunAjaranCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TahunAjaran.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahunAjaranAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TahunAjaranAggregateArgs>(args: Subset<T, TahunAjaranAggregateArgs>): Prisma.PrismaPromise<GetTahunAjaranAggregateType<T>>

    /**
     * Group by TahunAjaran.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahunAjaranGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TahunAjaranGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TahunAjaranGroupByArgs['orderBy'] }
        : { orderBy?: TahunAjaranGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TahunAjaranGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTahunAjaranGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TahunAjaran model
   */
  readonly fields: TahunAjaranFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TahunAjaran.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TahunAjaranClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kelas<T extends TahunAjaran$kelasArgs<ExtArgs> = {}>(args?: Subset<T, TahunAjaran$kelasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KelasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TahunAjaran model
   */
  interface TahunAjaranFieldRefs {
    readonly id: FieldRef<"TahunAjaran", 'Int'>
    readonly tahun: FieldRef<"TahunAjaran", 'String'>
    readonly semester: FieldRef<"TahunAjaran", 'Semester'>
  }
    

  // Custom InputTypes
  /**
   * TahunAjaran findUnique
   */
  export type TahunAjaranFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TahunAjaran
     */
    select?: TahunAjaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TahunAjaran
     */
    omit?: TahunAjaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahunAjaranInclude<ExtArgs> | null
    /**
     * Filter, which TahunAjaran to fetch.
     */
    where: TahunAjaranWhereUniqueInput
  }

  /**
   * TahunAjaran findUniqueOrThrow
   */
  export type TahunAjaranFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TahunAjaran
     */
    select?: TahunAjaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TahunAjaran
     */
    omit?: TahunAjaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahunAjaranInclude<ExtArgs> | null
    /**
     * Filter, which TahunAjaran to fetch.
     */
    where: TahunAjaranWhereUniqueInput
  }

  /**
   * TahunAjaran findFirst
   */
  export type TahunAjaranFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TahunAjaran
     */
    select?: TahunAjaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TahunAjaran
     */
    omit?: TahunAjaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahunAjaranInclude<ExtArgs> | null
    /**
     * Filter, which TahunAjaran to fetch.
     */
    where?: TahunAjaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TahunAjarans to fetch.
     */
    orderBy?: TahunAjaranOrderByWithRelationInput | TahunAjaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TahunAjarans.
     */
    cursor?: TahunAjaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TahunAjarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TahunAjarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TahunAjarans.
     */
    distinct?: TahunAjaranScalarFieldEnum | TahunAjaranScalarFieldEnum[]
  }

  /**
   * TahunAjaran findFirstOrThrow
   */
  export type TahunAjaranFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TahunAjaran
     */
    select?: TahunAjaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TahunAjaran
     */
    omit?: TahunAjaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahunAjaranInclude<ExtArgs> | null
    /**
     * Filter, which TahunAjaran to fetch.
     */
    where?: TahunAjaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TahunAjarans to fetch.
     */
    orderBy?: TahunAjaranOrderByWithRelationInput | TahunAjaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TahunAjarans.
     */
    cursor?: TahunAjaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TahunAjarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TahunAjarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TahunAjarans.
     */
    distinct?: TahunAjaranScalarFieldEnum | TahunAjaranScalarFieldEnum[]
  }

  /**
   * TahunAjaran findMany
   */
  export type TahunAjaranFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TahunAjaran
     */
    select?: TahunAjaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TahunAjaran
     */
    omit?: TahunAjaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahunAjaranInclude<ExtArgs> | null
    /**
     * Filter, which TahunAjarans to fetch.
     */
    where?: TahunAjaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TahunAjarans to fetch.
     */
    orderBy?: TahunAjaranOrderByWithRelationInput | TahunAjaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TahunAjarans.
     */
    cursor?: TahunAjaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TahunAjarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TahunAjarans.
     */
    skip?: number
    distinct?: TahunAjaranScalarFieldEnum | TahunAjaranScalarFieldEnum[]
  }

  /**
   * TahunAjaran create
   */
  export type TahunAjaranCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TahunAjaran
     */
    select?: TahunAjaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TahunAjaran
     */
    omit?: TahunAjaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahunAjaranInclude<ExtArgs> | null
    /**
     * The data needed to create a TahunAjaran.
     */
    data: XOR<TahunAjaranCreateInput, TahunAjaranUncheckedCreateInput>
  }

  /**
   * TahunAjaran createMany
   */
  export type TahunAjaranCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TahunAjarans.
     */
    data: TahunAjaranCreateManyInput | TahunAjaranCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TahunAjaran createManyAndReturn
   */
  export type TahunAjaranCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TahunAjaran
     */
    select?: TahunAjaranSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TahunAjaran
     */
    omit?: TahunAjaranOmit<ExtArgs> | null
    /**
     * The data used to create many TahunAjarans.
     */
    data: TahunAjaranCreateManyInput | TahunAjaranCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TahunAjaran update
   */
  export type TahunAjaranUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TahunAjaran
     */
    select?: TahunAjaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TahunAjaran
     */
    omit?: TahunAjaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahunAjaranInclude<ExtArgs> | null
    /**
     * The data needed to update a TahunAjaran.
     */
    data: XOR<TahunAjaranUpdateInput, TahunAjaranUncheckedUpdateInput>
    /**
     * Choose, which TahunAjaran to update.
     */
    where: TahunAjaranWhereUniqueInput
  }

  /**
   * TahunAjaran updateMany
   */
  export type TahunAjaranUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TahunAjarans.
     */
    data: XOR<TahunAjaranUpdateManyMutationInput, TahunAjaranUncheckedUpdateManyInput>
    /**
     * Filter which TahunAjarans to update
     */
    where?: TahunAjaranWhereInput
    /**
     * Limit how many TahunAjarans to update.
     */
    limit?: number
  }

  /**
   * TahunAjaran updateManyAndReturn
   */
  export type TahunAjaranUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TahunAjaran
     */
    select?: TahunAjaranSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TahunAjaran
     */
    omit?: TahunAjaranOmit<ExtArgs> | null
    /**
     * The data used to update TahunAjarans.
     */
    data: XOR<TahunAjaranUpdateManyMutationInput, TahunAjaranUncheckedUpdateManyInput>
    /**
     * Filter which TahunAjarans to update
     */
    where?: TahunAjaranWhereInput
    /**
     * Limit how many TahunAjarans to update.
     */
    limit?: number
  }

  /**
   * TahunAjaran upsert
   */
  export type TahunAjaranUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TahunAjaran
     */
    select?: TahunAjaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TahunAjaran
     */
    omit?: TahunAjaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahunAjaranInclude<ExtArgs> | null
    /**
     * The filter to search for the TahunAjaran to update in case it exists.
     */
    where: TahunAjaranWhereUniqueInput
    /**
     * In case the TahunAjaran found by the `where` argument doesn't exist, create a new TahunAjaran with this data.
     */
    create: XOR<TahunAjaranCreateInput, TahunAjaranUncheckedCreateInput>
    /**
     * In case the TahunAjaran was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TahunAjaranUpdateInput, TahunAjaranUncheckedUpdateInput>
  }

  /**
   * TahunAjaran delete
   */
  export type TahunAjaranDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TahunAjaran
     */
    select?: TahunAjaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TahunAjaran
     */
    omit?: TahunAjaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahunAjaranInclude<ExtArgs> | null
    /**
     * Filter which TahunAjaran to delete.
     */
    where: TahunAjaranWhereUniqueInput
  }

  /**
   * TahunAjaran deleteMany
   */
  export type TahunAjaranDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TahunAjarans to delete
     */
    where?: TahunAjaranWhereInput
    /**
     * Limit how many TahunAjarans to delete.
     */
    limit?: number
  }

  /**
   * TahunAjaran.kelas
   */
  export type TahunAjaran$kelasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kelas
     */
    select?: KelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kelas
     */
    omit?: KelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KelasInclude<ExtArgs> | null
    where?: KelasWhereInput
    orderBy?: KelasOrderByWithRelationInput | KelasOrderByWithRelationInput[]
    cursor?: KelasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KelasScalarFieldEnum | KelasScalarFieldEnum[]
  }

  /**
   * TahunAjaran without action
   */
  export type TahunAjaranDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TahunAjaran
     */
    select?: TahunAjaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TahunAjaran
     */
    omit?: TahunAjaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahunAjaranInclude<ExtArgs> | null
  }


  /**
   * Model Kelas
   */

  export type AggregateKelas = {
    _count: KelasCountAggregateOutputType | null
    _avg: KelasAvgAggregateOutputType | null
    _sum: KelasSumAggregateOutputType | null
    _min: KelasMinAggregateOutputType | null
    _max: KelasMaxAggregateOutputType | null
  }

  export type KelasAvgAggregateOutputType = {
    id: number | null
    mata_kuliah_id: number | null
    tahun_ajaran_id: number | null
  }

  export type KelasSumAggregateOutputType = {
    id: number | null
    mata_kuliah_id: number | null
    tahun_ajaran_id: number | null
  }

  export type KelasMinAggregateOutputType = {
    id: number | null
    nama_kelas: string | null
    createdAt: Date | null
    updatedAt: Date | null
    mata_kuliah_id: number | null
    tahun_ajaran_id: number | null
  }

  export type KelasMaxAggregateOutputType = {
    id: number | null
    nama_kelas: string | null
    createdAt: Date | null
    updatedAt: Date | null
    mata_kuliah_id: number | null
    tahun_ajaran_id: number | null
  }

  export type KelasCountAggregateOutputType = {
    id: number
    nama_kelas: number
    createdAt: number
    updatedAt: number
    mata_kuliah_id: number
    tahun_ajaran_id: number
    _all: number
  }


  export type KelasAvgAggregateInputType = {
    id?: true
    mata_kuliah_id?: true
    tahun_ajaran_id?: true
  }

  export type KelasSumAggregateInputType = {
    id?: true
    mata_kuliah_id?: true
    tahun_ajaran_id?: true
  }

  export type KelasMinAggregateInputType = {
    id?: true
    nama_kelas?: true
    createdAt?: true
    updatedAt?: true
    mata_kuliah_id?: true
    tahun_ajaran_id?: true
  }

  export type KelasMaxAggregateInputType = {
    id?: true
    nama_kelas?: true
    createdAt?: true
    updatedAt?: true
    mata_kuliah_id?: true
    tahun_ajaran_id?: true
  }

  export type KelasCountAggregateInputType = {
    id?: true
    nama_kelas?: true
    createdAt?: true
    updatedAt?: true
    mata_kuliah_id?: true
    tahun_ajaran_id?: true
    _all?: true
  }

  export type KelasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kelas to aggregate.
     */
    where?: KelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kelas to fetch.
     */
    orderBy?: KelasOrderByWithRelationInput | KelasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kelas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kelas
    **/
    _count?: true | KelasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KelasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KelasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KelasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KelasMaxAggregateInputType
  }

  export type GetKelasAggregateType<T extends KelasAggregateArgs> = {
        [P in keyof T & keyof AggregateKelas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKelas[P]>
      : GetScalarType<T[P], AggregateKelas[P]>
  }




  export type KelasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KelasWhereInput
    orderBy?: KelasOrderByWithAggregationInput | KelasOrderByWithAggregationInput[]
    by: KelasScalarFieldEnum[] | KelasScalarFieldEnum
    having?: KelasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KelasCountAggregateInputType | true
    _avg?: KelasAvgAggregateInputType
    _sum?: KelasSumAggregateInputType
    _min?: KelasMinAggregateInputType
    _max?: KelasMaxAggregateInputType
  }

  export type KelasGroupByOutputType = {
    id: number
    nama_kelas: string
    createdAt: Date
    updatedAt: Date
    mata_kuliah_id: number
    tahun_ajaran_id: number
    _count: KelasCountAggregateOutputType | null
    _avg: KelasAvgAggregateOutputType | null
    _sum: KelasSumAggregateOutputType | null
    _min: KelasMinAggregateOutputType | null
    _max: KelasMaxAggregateOutputType | null
  }

  type GetKelasGroupByPayload<T extends KelasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KelasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KelasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KelasGroupByOutputType[P]>
            : GetScalarType<T[P], KelasGroupByOutputType[P]>
        }
      >
    >


  export type KelasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama_kelas?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mata_kuliah_id?: boolean
    tahun_ajaran_id?: boolean
    mataKuliah?: boolean | MataKuliahDefaultArgs<ExtArgs>
    tahunAjaran?: boolean | TahunAjaranDefaultArgs<ExtArgs>
    dosenPengampu?: boolean | Kelas$dosenPengampuArgs<ExtArgs>
    pesertaKelas?: boolean | Kelas$pesertaKelasArgs<ExtArgs>
    rps?: boolean | Kelas$rpsArgs<ExtArgs>
    cpmk?: boolean | Kelas$cpmkArgs<ExtArgs>
    _count?: boolean | KelasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kelas"]>

  export type KelasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama_kelas?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mata_kuliah_id?: boolean
    tahun_ajaran_id?: boolean
    mataKuliah?: boolean | MataKuliahDefaultArgs<ExtArgs>
    tahunAjaran?: boolean | TahunAjaranDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kelas"]>

  export type KelasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama_kelas?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mata_kuliah_id?: boolean
    tahun_ajaran_id?: boolean
    mataKuliah?: boolean | MataKuliahDefaultArgs<ExtArgs>
    tahunAjaran?: boolean | TahunAjaranDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kelas"]>

  export type KelasSelectScalar = {
    id?: boolean
    nama_kelas?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mata_kuliah_id?: boolean
    tahun_ajaran_id?: boolean
  }

  export type KelasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nama_kelas" | "createdAt" | "updatedAt" | "mata_kuliah_id" | "tahun_ajaran_id", ExtArgs["result"]["kelas"]>
  export type KelasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mataKuliah?: boolean | MataKuliahDefaultArgs<ExtArgs>
    tahunAjaran?: boolean | TahunAjaranDefaultArgs<ExtArgs>
    dosenPengampu?: boolean | Kelas$dosenPengampuArgs<ExtArgs>
    pesertaKelas?: boolean | Kelas$pesertaKelasArgs<ExtArgs>
    rps?: boolean | Kelas$rpsArgs<ExtArgs>
    cpmk?: boolean | Kelas$cpmkArgs<ExtArgs>
    _count?: boolean | KelasCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KelasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mataKuliah?: boolean | MataKuliahDefaultArgs<ExtArgs>
    tahunAjaran?: boolean | TahunAjaranDefaultArgs<ExtArgs>
  }
  export type KelasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mataKuliah?: boolean | MataKuliahDefaultArgs<ExtArgs>
    tahunAjaran?: boolean | TahunAjaranDefaultArgs<ExtArgs>
  }

  export type $KelasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Kelas"
    objects: {
      mataKuliah: Prisma.$MataKuliahPayload<ExtArgs>
      tahunAjaran: Prisma.$TahunAjaranPayload<ExtArgs>
      dosenPengampu: Prisma.$DosenPengampuPayload<ExtArgs>[]
      pesertaKelas: Prisma.$PesertaKelasPayload<ExtArgs>[]
      rps: Prisma.$RPSPayload<ExtArgs>[]
      cpmk: Prisma.$CPMKPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama_kelas: string
      createdAt: Date
      updatedAt: Date
      mata_kuliah_id: number
      tahun_ajaran_id: number
    }, ExtArgs["result"]["kelas"]>
    composites: {}
  }

  type KelasGetPayload<S extends boolean | null | undefined | KelasDefaultArgs> = $Result.GetResult<Prisma.$KelasPayload, S>

  type KelasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KelasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KelasCountAggregateInputType | true
    }

  export interface KelasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Kelas'], meta: { name: 'Kelas' } }
    /**
     * Find zero or one Kelas that matches the filter.
     * @param {KelasFindUniqueArgs} args - Arguments to find a Kelas
     * @example
     * // Get one Kelas
     * const kelas = await prisma.kelas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KelasFindUniqueArgs>(args: SelectSubset<T, KelasFindUniqueArgs<ExtArgs>>): Prisma__KelasClient<$Result.GetResult<Prisma.$KelasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Kelas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KelasFindUniqueOrThrowArgs} args - Arguments to find a Kelas
     * @example
     * // Get one Kelas
     * const kelas = await prisma.kelas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KelasFindUniqueOrThrowArgs>(args: SelectSubset<T, KelasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KelasClient<$Result.GetResult<Prisma.$KelasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kelas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KelasFindFirstArgs} args - Arguments to find a Kelas
     * @example
     * // Get one Kelas
     * const kelas = await prisma.kelas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KelasFindFirstArgs>(args?: SelectSubset<T, KelasFindFirstArgs<ExtArgs>>): Prisma__KelasClient<$Result.GetResult<Prisma.$KelasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kelas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KelasFindFirstOrThrowArgs} args - Arguments to find a Kelas
     * @example
     * // Get one Kelas
     * const kelas = await prisma.kelas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KelasFindFirstOrThrowArgs>(args?: SelectSubset<T, KelasFindFirstOrThrowArgs<ExtArgs>>): Prisma__KelasClient<$Result.GetResult<Prisma.$KelasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Kelas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KelasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kelas
     * const kelas = await prisma.kelas.findMany()
     * 
     * // Get first 10 Kelas
     * const kelas = await prisma.kelas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kelasWithIdOnly = await prisma.kelas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KelasFindManyArgs>(args?: SelectSubset<T, KelasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KelasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Kelas.
     * @param {KelasCreateArgs} args - Arguments to create a Kelas.
     * @example
     * // Create one Kelas
     * const Kelas = await prisma.kelas.create({
     *   data: {
     *     // ... data to create a Kelas
     *   }
     * })
     * 
     */
    create<T extends KelasCreateArgs>(args: SelectSubset<T, KelasCreateArgs<ExtArgs>>): Prisma__KelasClient<$Result.GetResult<Prisma.$KelasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Kelas.
     * @param {KelasCreateManyArgs} args - Arguments to create many Kelas.
     * @example
     * // Create many Kelas
     * const kelas = await prisma.kelas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KelasCreateManyArgs>(args?: SelectSubset<T, KelasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kelas and returns the data saved in the database.
     * @param {KelasCreateManyAndReturnArgs} args - Arguments to create many Kelas.
     * @example
     * // Create many Kelas
     * const kelas = await prisma.kelas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kelas and only return the `id`
     * const kelasWithIdOnly = await prisma.kelas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KelasCreateManyAndReturnArgs>(args?: SelectSubset<T, KelasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KelasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Kelas.
     * @param {KelasDeleteArgs} args - Arguments to delete one Kelas.
     * @example
     * // Delete one Kelas
     * const Kelas = await prisma.kelas.delete({
     *   where: {
     *     // ... filter to delete one Kelas
     *   }
     * })
     * 
     */
    delete<T extends KelasDeleteArgs>(args: SelectSubset<T, KelasDeleteArgs<ExtArgs>>): Prisma__KelasClient<$Result.GetResult<Prisma.$KelasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Kelas.
     * @param {KelasUpdateArgs} args - Arguments to update one Kelas.
     * @example
     * // Update one Kelas
     * const kelas = await prisma.kelas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KelasUpdateArgs>(args: SelectSubset<T, KelasUpdateArgs<ExtArgs>>): Prisma__KelasClient<$Result.GetResult<Prisma.$KelasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Kelas.
     * @param {KelasDeleteManyArgs} args - Arguments to filter Kelas to delete.
     * @example
     * // Delete a few Kelas
     * const { count } = await prisma.kelas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KelasDeleteManyArgs>(args?: SelectSubset<T, KelasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KelasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kelas
     * const kelas = await prisma.kelas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KelasUpdateManyArgs>(args: SelectSubset<T, KelasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kelas and returns the data updated in the database.
     * @param {KelasUpdateManyAndReturnArgs} args - Arguments to update many Kelas.
     * @example
     * // Update many Kelas
     * const kelas = await prisma.kelas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Kelas and only return the `id`
     * const kelasWithIdOnly = await prisma.kelas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KelasUpdateManyAndReturnArgs>(args: SelectSubset<T, KelasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KelasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Kelas.
     * @param {KelasUpsertArgs} args - Arguments to update or create a Kelas.
     * @example
     * // Update or create a Kelas
     * const kelas = await prisma.kelas.upsert({
     *   create: {
     *     // ... data to create a Kelas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kelas we want to update
     *   }
     * })
     */
    upsert<T extends KelasUpsertArgs>(args: SelectSubset<T, KelasUpsertArgs<ExtArgs>>): Prisma__KelasClient<$Result.GetResult<Prisma.$KelasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Kelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KelasCountArgs} args - Arguments to filter Kelas to count.
     * @example
     * // Count the number of Kelas
     * const count = await prisma.kelas.count({
     *   where: {
     *     // ... the filter for the Kelas we want to count
     *   }
     * })
    **/
    count<T extends KelasCountArgs>(
      args?: Subset<T, KelasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KelasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KelasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KelasAggregateArgs>(args: Subset<T, KelasAggregateArgs>): Prisma.PrismaPromise<GetKelasAggregateType<T>>

    /**
     * Group by Kelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KelasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KelasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KelasGroupByArgs['orderBy'] }
        : { orderBy?: KelasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KelasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKelasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Kelas model
   */
  readonly fields: KelasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Kelas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KelasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mataKuliah<T extends MataKuliahDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MataKuliahDefaultArgs<ExtArgs>>): Prisma__MataKuliahClient<$Result.GetResult<Prisma.$MataKuliahPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tahunAjaran<T extends TahunAjaranDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TahunAjaranDefaultArgs<ExtArgs>>): Prisma__TahunAjaranClient<$Result.GetResult<Prisma.$TahunAjaranPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dosenPengampu<T extends Kelas$dosenPengampuArgs<ExtArgs> = {}>(args?: Subset<T, Kelas$dosenPengampuArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DosenPengampuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pesertaKelas<T extends Kelas$pesertaKelasArgs<ExtArgs> = {}>(args?: Subset<T, Kelas$pesertaKelasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PesertaKelasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rps<T extends Kelas$rpsArgs<ExtArgs> = {}>(args?: Subset<T, Kelas$rpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RPSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cpmk<T extends Kelas$cpmkArgs<ExtArgs> = {}>(args?: Subset<T, Kelas$cpmkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CPMKPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Kelas model
   */
  interface KelasFieldRefs {
    readonly id: FieldRef<"Kelas", 'Int'>
    readonly nama_kelas: FieldRef<"Kelas", 'String'>
    readonly createdAt: FieldRef<"Kelas", 'DateTime'>
    readonly updatedAt: FieldRef<"Kelas", 'DateTime'>
    readonly mata_kuliah_id: FieldRef<"Kelas", 'Int'>
    readonly tahun_ajaran_id: FieldRef<"Kelas", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Kelas findUnique
   */
  export type KelasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kelas
     */
    select?: KelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kelas
     */
    omit?: KelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KelasInclude<ExtArgs> | null
    /**
     * Filter, which Kelas to fetch.
     */
    where: KelasWhereUniqueInput
  }

  /**
   * Kelas findUniqueOrThrow
   */
  export type KelasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kelas
     */
    select?: KelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kelas
     */
    omit?: KelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KelasInclude<ExtArgs> | null
    /**
     * Filter, which Kelas to fetch.
     */
    where: KelasWhereUniqueInput
  }

  /**
   * Kelas findFirst
   */
  export type KelasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kelas
     */
    select?: KelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kelas
     */
    omit?: KelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KelasInclude<ExtArgs> | null
    /**
     * Filter, which Kelas to fetch.
     */
    where?: KelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kelas to fetch.
     */
    orderBy?: KelasOrderByWithRelationInput | KelasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kelas.
     */
    cursor?: KelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kelas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kelas.
     */
    distinct?: KelasScalarFieldEnum | KelasScalarFieldEnum[]
  }

  /**
   * Kelas findFirstOrThrow
   */
  export type KelasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kelas
     */
    select?: KelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kelas
     */
    omit?: KelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KelasInclude<ExtArgs> | null
    /**
     * Filter, which Kelas to fetch.
     */
    where?: KelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kelas to fetch.
     */
    orderBy?: KelasOrderByWithRelationInput | KelasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kelas.
     */
    cursor?: KelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kelas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kelas.
     */
    distinct?: KelasScalarFieldEnum | KelasScalarFieldEnum[]
  }

  /**
   * Kelas findMany
   */
  export type KelasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kelas
     */
    select?: KelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kelas
     */
    omit?: KelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KelasInclude<ExtArgs> | null
    /**
     * Filter, which Kelas to fetch.
     */
    where?: KelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kelas to fetch.
     */
    orderBy?: KelasOrderByWithRelationInput | KelasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kelas.
     */
    cursor?: KelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kelas.
     */
    skip?: number
    distinct?: KelasScalarFieldEnum | KelasScalarFieldEnum[]
  }

  /**
   * Kelas create
   */
  export type KelasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kelas
     */
    select?: KelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kelas
     */
    omit?: KelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KelasInclude<ExtArgs> | null
    /**
     * The data needed to create a Kelas.
     */
    data: XOR<KelasCreateInput, KelasUncheckedCreateInput>
  }

  /**
   * Kelas createMany
   */
  export type KelasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Kelas.
     */
    data: KelasCreateManyInput | KelasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Kelas createManyAndReturn
   */
  export type KelasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kelas
     */
    select?: KelasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kelas
     */
    omit?: KelasOmit<ExtArgs> | null
    /**
     * The data used to create many Kelas.
     */
    data: KelasCreateManyInput | KelasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KelasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Kelas update
   */
  export type KelasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kelas
     */
    select?: KelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kelas
     */
    omit?: KelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KelasInclude<ExtArgs> | null
    /**
     * The data needed to update a Kelas.
     */
    data: XOR<KelasUpdateInput, KelasUncheckedUpdateInput>
    /**
     * Choose, which Kelas to update.
     */
    where: KelasWhereUniqueInput
  }

  /**
   * Kelas updateMany
   */
  export type KelasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Kelas.
     */
    data: XOR<KelasUpdateManyMutationInput, KelasUncheckedUpdateManyInput>
    /**
     * Filter which Kelas to update
     */
    where?: KelasWhereInput
    /**
     * Limit how many Kelas to update.
     */
    limit?: number
  }

  /**
   * Kelas updateManyAndReturn
   */
  export type KelasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kelas
     */
    select?: KelasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kelas
     */
    omit?: KelasOmit<ExtArgs> | null
    /**
     * The data used to update Kelas.
     */
    data: XOR<KelasUpdateManyMutationInput, KelasUncheckedUpdateManyInput>
    /**
     * Filter which Kelas to update
     */
    where?: KelasWhereInput
    /**
     * Limit how many Kelas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KelasIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Kelas upsert
   */
  export type KelasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kelas
     */
    select?: KelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kelas
     */
    omit?: KelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KelasInclude<ExtArgs> | null
    /**
     * The filter to search for the Kelas to update in case it exists.
     */
    where: KelasWhereUniqueInput
    /**
     * In case the Kelas found by the `where` argument doesn't exist, create a new Kelas with this data.
     */
    create: XOR<KelasCreateInput, KelasUncheckedCreateInput>
    /**
     * In case the Kelas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KelasUpdateInput, KelasUncheckedUpdateInput>
  }

  /**
   * Kelas delete
   */
  export type KelasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kelas
     */
    select?: KelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kelas
     */
    omit?: KelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KelasInclude<ExtArgs> | null
    /**
     * Filter which Kelas to delete.
     */
    where: KelasWhereUniqueInput
  }

  /**
   * Kelas deleteMany
   */
  export type KelasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kelas to delete
     */
    where?: KelasWhereInput
    /**
     * Limit how many Kelas to delete.
     */
    limit?: number
  }

  /**
   * Kelas.dosenPengampu
   */
  export type Kelas$dosenPengampuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DosenPengampu
     */
    select?: DosenPengampuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DosenPengampu
     */
    omit?: DosenPengampuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosenPengampuInclude<ExtArgs> | null
    where?: DosenPengampuWhereInput
    orderBy?: DosenPengampuOrderByWithRelationInput | DosenPengampuOrderByWithRelationInput[]
    cursor?: DosenPengampuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DosenPengampuScalarFieldEnum | DosenPengampuScalarFieldEnum[]
  }

  /**
   * Kelas.pesertaKelas
   */
  export type Kelas$pesertaKelasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PesertaKelas
     */
    select?: PesertaKelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PesertaKelas
     */
    omit?: PesertaKelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PesertaKelasInclude<ExtArgs> | null
    where?: PesertaKelasWhereInput
    orderBy?: PesertaKelasOrderByWithRelationInput | PesertaKelasOrderByWithRelationInput[]
    cursor?: PesertaKelasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PesertaKelasScalarFieldEnum | PesertaKelasScalarFieldEnum[]
  }

  /**
   * Kelas.rps
   */
  export type Kelas$rpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPS
     */
    select?: RPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RPS
     */
    omit?: RPSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPSInclude<ExtArgs> | null
    where?: RPSWhereInput
    orderBy?: RPSOrderByWithRelationInput | RPSOrderByWithRelationInput[]
    cursor?: RPSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RPSScalarFieldEnum | RPSScalarFieldEnum[]
  }

  /**
   * Kelas.cpmk
   */
  export type Kelas$cpmkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK
     */
    select?: CPMKSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK
     */
    omit?: CPMKOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMKInclude<ExtArgs> | null
    where?: CPMKWhereInput
    orderBy?: CPMKOrderByWithRelationInput | CPMKOrderByWithRelationInput[]
    cursor?: CPMKWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CPMKScalarFieldEnum | CPMKScalarFieldEnum[]
  }

  /**
   * Kelas without action
   */
  export type KelasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kelas
     */
    select?: KelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kelas
     */
    omit?: KelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KelasInclude<ExtArgs> | null
  }


  /**
   * Model DosenPengampu
   */

  export type AggregateDosenPengampu = {
    _count: DosenPengampuCountAggregateOutputType | null
    _avg: DosenPengampuAvgAggregateOutputType | null
    _sum: DosenPengampuSumAggregateOutputType | null
    _min: DosenPengampuMinAggregateOutputType | null
    _max: DosenPengampuMaxAggregateOutputType | null
  }

  export type DosenPengampuAvgAggregateOutputType = {
    id: number | null
    kelas_id: number | null
    dosen_id: number | null
  }

  export type DosenPengampuSumAggregateOutputType = {
    id: number | null
    kelas_id: number | null
    dosen_id: number | null
  }

  export type DosenPengampuMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    kelas_id: number | null
    dosen_id: number | null
  }

  export type DosenPengampuMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    kelas_id: number | null
    dosen_id: number | null
  }

  export type DosenPengampuCountAggregateOutputType = {
    id: number
    createdAt: number
    kelas_id: number
    dosen_id: number
    _all: number
  }


  export type DosenPengampuAvgAggregateInputType = {
    id?: true
    kelas_id?: true
    dosen_id?: true
  }

  export type DosenPengampuSumAggregateInputType = {
    id?: true
    kelas_id?: true
    dosen_id?: true
  }

  export type DosenPengampuMinAggregateInputType = {
    id?: true
    createdAt?: true
    kelas_id?: true
    dosen_id?: true
  }

  export type DosenPengampuMaxAggregateInputType = {
    id?: true
    createdAt?: true
    kelas_id?: true
    dosen_id?: true
  }

  export type DosenPengampuCountAggregateInputType = {
    id?: true
    createdAt?: true
    kelas_id?: true
    dosen_id?: true
    _all?: true
  }

  export type DosenPengampuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DosenPengampu to aggregate.
     */
    where?: DosenPengampuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DosenPengampus to fetch.
     */
    orderBy?: DosenPengampuOrderByWithRelationInput | DosenPengampuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DosenPengampuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DosenPengampus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DosenPengampus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DosenPengampus
    **/
    _count?: true | DosenPengampuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DosenPengampuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DosenPengampuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DosenPengampuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DosenPengampuMaxAggregateInputType
  }

  export type GetDosenPengampuAggregateType<T extends DosenPengampuAggregateArgs> = {
        [P in keyof T & keyof AggregateDosenPengampu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDosenPengampu[P]>
      : GetScalarType<T[P], AggregateDosenPengampu[P]>
  }




  export type DosenPengampuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DosenPengampuWhereInput
    orderBy?: DosenPengampuOrderByWithAggregationInput | DosenPengampuOrderByWithAggregationInput[]
    by: DosenPengampuScalarFieldEnum[] | DosenPengampuScalarFieldEnum
    having?: DosenPengampuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DosenPengampuCountAggregateInputType | true
    _avg?: DosenPengampuAvgAggregateInputType
    _sum?: DosenPengampuSumAggregateInputType
    _min?: DosenPengampuMinAggregateInputType
    _max?: DosenPengampuMaxAggregateInputType
  }

  export type DosenPengampuGroupByOutputType = {
    id: number
    createdAt: Date
    kelas_id: number
    dosen_id: number
    _count: DosenPengampuCountAggregateOutputType | null
    _avg: DosenPengampuAvgAggregateOutputType | null
    _sum: DosenPengampuSumAggregateOutputType | null
    _min: DosenPengampuMinAggregateOutputType | null
    _max: DosenPengampuMaxAggregateOutputType | null
  }

  type GetDosenPengampuGroupByPayload<T extends DosenPengampuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DosenPengampuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DosenPengampuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DosenPengampuGroupByOutputType[P]>
            : GetScalarType<T[P], DosenPengampuGroupByOutputType[P]>
        }
      >
    >


  export type DosenPengampuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    kelas_id?: boolean
    dosen_id?: boolean
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
    dosen?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dosenPengampu"]>

  export type DosenPengampuSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    kelas_id?: boolean
    dosen_id?: boolean
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
    dosen?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dosenPengampu"]>

  export type DosenPengampuSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    kelas_id?: boolean
    dosen_id?: boolean
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
    dosen?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dosenPengampu"]>

  export type DosenPengampuSelectScalar = {
    id?: boolean
    createdAt?: boolean
    kelas_id?: boolean
    dosen_id?: boolean
  }

  export type DosenPengampuOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "kelas_id" | "dosen_id", ExtArgs["result"]["dosenPengampu"]>
  export type DosenPengampuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
    dosen?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DosenPengampuIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
    dosen?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DosenPengampuIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
    dosen?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DosenPengampuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DosenPengampu"
    objects: {
      kelas: Prisma.$KelasPayload<ExtArgs>
      dosen: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      kelas_id: number
      dosen_id: number
    }, ExtArgs["result"]["dosenPengampu"]>
    composites: {}
  }

  type DosenPengampuGetPayload<S extends boolean | null | undefined | DosenPengampuDefaultArgs> = $Result.GetResult<Prisma.$DosenPengampuPayload, S>

  type DosenPengampuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DosenPengampuFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DosenPengampuCountAggregateInputType | true
    }

  export interface DosenPengampuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DosenPengampu'], meta: { name: 'DosenPengampu' } }
    /**
     * Find zero or one DosenPengampu that matches the filter.
     * @param {DosenPengampuFindUniqueArgs} args - Arguments to find a DosenPengampu
     * @example
     * // Get one DosenPengampu
     * const dosenPengampu = await prisma.dosenPengampu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DosenPengampuFindUniqueArgs>(args: SelectSubset<T, DosenPengampuFindUniqueArgs<ExtArgs>>): Prisma__DosenPengampuClient<$Result.GetResult<Prisma.$DosenPengampuPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DosenPengampu that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DosenPengampuFindUniqueOrThrowArgs} args - Arguments to find a DosenPengampu
     * @example
     * // Get one DosenPengampu
     * const dosenPengampu = await prisma.dosenPengampu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DosenPengampuFindUniqueOrThrowArgs>(args: SelectSubset<T, DosenPengampuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DosenPengampuClient<$Result.GetResult<Prisma.$DosenPengampuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DosenPengampu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DosenPengampuFindFirstArgs} args - Arguments to find a DosenPengampu
     * @example
     * // Get one DosenPengampu
     * const dosenPengampu = await prisma.dosenPengampu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DosenPengampuFindFirstArgs>(args?: SelectSubset<T, DosenPengampuFindFirstArgs<ExtArgs>>): Prisma__DosenPengampuClient<$Result.GetResult<Prisma.$DosenPengampuPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DosenPengampu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DosenPengampuFindFirstOrThrowArgs} args - Arguments to find a DosenPengampu
     * @example
     * // Get one DosenPengampu
     * const dosenPengampu = await prisma.dosenPengampu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DosenPengampuFindFirstOrThrowArgs>(args?: SelectSubset<T, DosenPengampuFindFirstOrThrowArgs<ExtArgs>>): Prisma__DosenPengampuClient<$Result.GetResult<Prisma.$DosenPengampuPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DosenPengampus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DosenPengampuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DosenPengampus
     * const dosenPengampus = await prisma.dosenPengampu.findMany()
     * 
     * // Get first 10 DosenPengampus
     * const dosenPengampus = await prisma.dosenPengampu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dosenPengampuWithIdOnly = await prisma.dosenPengampu.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DosenPengampuFindManyArgs>(args?: SelectSubset<T, DosenPengampuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DosenPengampuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DosenPengampu.
     * @param {DosenPengampuCreateArgs} args - Arguments to create a DosenPengampu.
     * @example
     * // Create one DosenPengampu
     * const DosenPengampu = await prisma.dosenPengampu.create({
     *   data: {
     *     // ... data to create a DosenPengampu
     *   }
     * })
     * 
     */
    create<T extends DosenPengampuCreateArgs>(args: SelectSubset<T, DosenPengampuCreateArgs<ExtArgs>>): Prisma__DosenPengampuClient<$Result.GetResult<Prisma.$DosenPengampuPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DosenPengampus.
     * @param {DosenPengampuCreateManyArgs} args - Arguments to create many DosenPengampus.
     * @example
     * // Create many DosenPengampus
     * const dosenPengampu = await prisma.dosenPengampu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DosenPengampuCreateManyArgs>(args?: SelectSubset<T, DosenPengampuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DosenPengampus and returns the data saved in the database.
     * @param {DosenPengampuCreateManyAndReturnArgs} args - Arguments to create many DosenPengampus.
     * @example
     * // Create many DosenPengampus
     * const dosenPengampu = await prisma.dosenPengampu.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DosenPengampus and only return the `id`
     * const dosenPengampuWithIdOnly = await prisma.dosenPengampu.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DosenPengampuCreateManyAndReturnArgs>(args?: SelectSubset<T, DosenPengampuCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DosenPengampuPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DosenPengampu.
     * @param {DosenPengampuDeleteArgs} args - Arguments to delete one DosenPengampu.
     * @example
     * // Delete one DosenPengampu
     * const DosenPengampu = await prisma.dosenPengampu.delete({
     *   where: {
     *     // ... filter to delete one DosenPengampu
     *   }
     * })
     * 
     */
    delete<T extends DosenPengampuDeleteArgs>(args: SelectSubset<T, DosenPengampuDeleteArgs<ExtArgs>>): Prisma__DosenPengampuClient<$Result.GetResult<Prisma.$DosenPengampuPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DosenPengampu.
     * @param {DosenPengampuUpdateArgs} args - Arguments to update one DosenPengampu.
     * @example
     * // Update one DosenPengampu
     * const dosenPengampu = await prisma.dosenPengampu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DosenPengampuUpdateArgs>(args: SelectSubset<T, DosenPengampuUpdateArgs<ExtArgs>>): Prisma__DosenPengampuClient<$Result.GetResult<Prisma.$DosenPengampuPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DosenPengampus.
     * @param {DosenPengampuDeleteManyArgs} args - Arguments to filter DosenPengampus to delete.
     * @example
     * // Delete a few DosenPengampus
     * const { count } = await prisma.dosenPengampu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DosenPengampuDeleteManyArgs>(args?: SelectSubset<T, DosenPengampuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DosenPengampus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DosenPengampuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DosenPengampus
     * const dosenPengampu = await prisma.dosenPengampu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DosenPengampuUpdateManyArgs>(args: SelectSubset<T, DosenPengampuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DosenPengampus and returns the data updated in the database.
     * @param {DosenPengampuUpdateManyAndReturnArgs} args - Arguments to update many DosenPengampus.
     * @example
     * // Update many DosenPengampus
     * const dosenPengampu = await prisma.dosenPengampu.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DosenPengampus and only return the `id`
     * const dosenPengampuWithIdOnly = await prisma.dosenPengampu.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DosenPengampuUpdateManyAndReturnArgs>(args: SelectSubset<T, DosenPengampuUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DosenPengampuPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DosenPengampu.
     * @param {DosenPengampuUpsertArgs} args - Arguments to update or create a DosenPengampu.
     * @example
     * // Update or create a DosenPengampu
     * const dosenPengampu = await prisma.dosenPengampu.upsert({
     *   create: {
     *     // ... data to create a DosenPengampu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DosenPengampu we want to update
     *   }
     * })
     */
    upsert<T extends DosenPengampuUpsertArgs>(args: SelectSubset<T, DosenPengampuUpsertArgs<ExtArgs>>): Prisma__DosenPengampuClient<$Result.GetResult<Prisma.$DosenPengampuPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DosenPengampus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DosenPengampuCountArgs} args - Arguments to filter DosenPengampus to count.
     * @example
     * // Count the number of DosenPengampus
     * const count = await prisma.dosenPengampu.count({
     *   where: {
     *     // ... the filter for the DosenPengampus we want to count
     *   }
     * })
    **/
    count<T extends DosenPengampuCountArgs>(
      args?: Subset<T, DosenPengampuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DosenPengampuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DosenPengampu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DosenPengampuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DosenPengampuAggregateArgs>(args: Subset<T, DosenPengampuAggregateArgs>): Prisma.PrismaPromise<GetDosenPengampuAggregateType<T>>

    /**
     * Group by DosenPengampu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DosenPengampuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DosenPengampuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DosenPengampuGroupByArgs['orderBy'] }
        : { orderBy?: DosenPengampuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DosenPengampuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDosenPengampuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DosenPengampu model
   */
  readonly fields: DosenPengampuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DosenPengampu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DosenPengampuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kelas<T extends KelasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KelasDefaultArgs<ExtArgs>>): Prisma__KelasClient<$Result.GetResult<Prisma.$KelasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dosen<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DosenPengampu model
   */
  interface DosenPengampuFieldRefs {
    readonly id: FieldRef<"DosenPengampu", 'Int'>
    readonly createdAt: FieldRef<"DosenPengampu", 'DateTime'>
    readonly kelas_id: FieldRef<"DosenPengampu", 'Int'>
    readonly dosen_id: FieldRef<"DosenPengampu", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DosenPengampu findUnique
   */
  export type DosenPengampuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DosenPengampu
     */
    select?: DosenPengampuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DosenPengampu
     */
    omit?: DosenPengampuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosenPengampuInclude<ExtArgs> | null
    /**
     * Filter, which DosenPengampu to fetch.
     */
    where: DosenPengampuWhereUniqueInput
  }

  /**
   * DosenPengampu findUniqueOrThrow
   */
  export type DosenPengampuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DosenPengampu
     */
    select?: DosenPengampuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DosenPengampu
     */
    omit?: DosenPengampuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosenPengampuInclude<ExtArgs> | null
    /**
     * Filter, which DosenPengampu to fetch.
     */
    where: DosenPengampuWhereUniqueInput
  }

  /**
   * DosenPengampu findFirst
   */
  export type DosenPengampuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DosenPengampu
     */
    select?: DosenPengampuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DosenPengampu
     */
    omit?: DosenPengampuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosenPengampuInclude<ExtArgs> | null
    /**
     * Filter, which DosenPengampu to fetch.
     */
    where?: DosenPengampuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DosenPengampus to fetch.
     */
    orderBy?: DosenPengampuOrderByWithRelationInput | DosenPengampuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DosenPengampus.
     */
    cursor?: DosenPengampuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DosenPengampus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DosenPengampus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DosenPengampus.
     */
    distinct?: DosenPengampuScalarFieldEnum | DosenPengampuScalarFieldEnum[]
  }

  /**
   * DosenPengampu findFirstOrThrow
   */
  export type DosenPengampuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DosenPengampu
     */
    select?: DosenPengampuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DosenPengampu
     */
    omit?: DosenPengampuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosenPengampuInclude<ExtArgs> | null
    /**
     * Filter, which DosenPengampu to fetch.
     */
    where?: DosenPengampuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DosenPengampus to fetch.
     */
    orderBy?: DosenPengampuOrderByWithRelationInput | DosenPengampuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DosenPengampus.
     */
    cursor?: DosenPengampuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DosenPengampus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DosenPengampus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DosenPengampus.
     */
    distinct?: DosenPengampuScalarFieldEnum | DosenPengampuScalarFieldEnum[]
  }

  /**
   * DosenPengampu findMany
   */
  export type DosenPengampuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DosenPengampu
     */
    select?: DosenPengampuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DosenPengampu
     */
    omit?: DosenPengampuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosenPengampuInclude<ExtArgs> | null
    /**
     * Filter, which DosenPengampus to fetch.
     */
    where?: DosenPengampuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DosenPengampus to fetch.
     */
    orderBy?: DosenPengampuOrderByWithRelationInput | DosenPengampuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DosenPengampus.
     */
    cursor?: DosenPengampuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DosenPengampus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DosenPengampus.
     */
    skip?: number
    distinct?: DosenPengampuScalarFieldEnum | DosenPengampuScalarFieldEnum[]
  }

  /**
   * DosenPengampu create
   */
  export type DosenPengampuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DosenPengampu
     */
    select?: DosenPengampuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DosenPengampu
     */
    omit?: DosenPengampuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosenPengampuInclude<ExtArgs> | null
    /**
     * The data needed to create a DosenPengampu.
     */
    data: XOR<DosenPengampuCreateInput, DosenPengampuUncheckedCreateInput>
  }

  /**
   * DosenPengampu createMany
   */
  export type DosenPengampuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DosenPengampus.
     */
    data: DosenPengampuCreateManyInput | DosenPengampuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DosenPengampu createManyAndReturn
   */
  export type DosenPengampuCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DosenPengampu
     */
    select?: DosenPengampuSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DosenPengampu
     */
    omit?: DosenPengampuOmit<ExtArgs> | null
    /**
     * The data used to create many DosenPengampus.
     */
    data: DosenPengampuCreateManyInput | DosenPengampuCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosenPengampuIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DosenPengampu update
   */
  export type DosenPengampuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DosenPengampu
     */
    select?: DosenPengampuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DosenPengampu
     */
    omit?: DosenPengampuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosenPengampuInclude<ExtArgs> | null
    /**
     * The data needed to update a DosenPengampu.
     */
    data: XOR<DosenPengampuUpdateInput, DosenPengampuUncheckedUpdateInput>
    /**
     * Choose, which DosenPengampu to update.
     */
    where: DosenPengampuWhereUniqueInput
  }

  /**
   * DosenPengampu updateMany
   */
  export type DosenPengampuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DosenPengampus.
     */
    data: XOR<DosenPengampuUpdateManyMutationInput, DosenPengampuUncheckedUpdateManyInput>
    /**
     * Filter which DosenPengampus to update
     */
    where?: DosenPengampuWhereInput
    /**
     * Limit how many DosenPengampus to update.
     */
    limit?: number
  }

  /**
   * DosenPengampu updateManyAndReturn
   */
  export type DosenPengampuUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DosenPengampu
     */
    select?: DosenPengampuSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DosenPengampu
     */
    omit?: DosenPengampuOmit<ExtArgs> | null
    /**
     * The data used to update DosenPengampus.
     */
    data: XOR<DosenPengampuUpdateManyMutationInput, DosenPengampuUncheckedUpdateManyInput>
    /**
     * Filter which DosenPengampus to update
     */
    where?: DosenPengampuWhereInput
    /**
     * Limit how many DosenPengampus to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosenPengampuIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DosenPengampu upsert
   */
  export type DosenPengampuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DosenPengampu
     */
    select?: DosenPengampuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DosenPengampu
     */
    omit?: DosenPengampuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosenPengampuInclude<ExtArgs> | null
    /**
     * The filter to search for the DosenPengampu to update in case it exists.
     */
    where: DosenPengampuWhereUniqueInput
    /**
     * In case the DosenPengampu found by the `where` argument doesn't exist, create a new DosenPengampu with this data.
     */
    create: XOR<DosenPengampuCreateInput, DosenPengampuUncheckedCreateInput>
    /**
     * In case the DosenPengampu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DosenPengampuUpdateInput, DosenPengampuUncheckedUpdateInput>
  }

  /**
   * DosenPengampu delete
   */
  export type DosenPengampuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DosenPengampu
     */
    select?: DosenPengampuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DosenPengampu
     */
    omit?: DosenPengampuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosenPengampuInclude<ExtArgs> | null
    /**
     * Filter which DosenPengampu to delete.
     */
    where: DosenPengampuWhereUniqueInput
  }

  /**
   * DosenPengampu deleteMany
   */
  export type DosenPengampuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DosenPengampus to delete
     */
    where?: DosenPengampuWhereInput
    /**
     * Limit how many DosenPengampus to delete.
     */
    limit?: number
  }

  /**
   * DosenPengampu without action
   */
  export type DosenPengampuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DosenPengampu
     */
    select?: DosenPengampuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DosenPengampu
     */
    omit?: DosenPengampuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DosenPengampuInclude<ExtArgs> | null
  }


  /**
   * Model PesertaKelas
   */

  export type AggregatePesertaKelas = {
    _count: PesertaKelasCountAggregateOutputType | null
    _avg: PesertaKelasAvgAggregateOutputType | null
    _sum: PesertaKelasSumAggregateOutputType | null
    _min: PesertaKelasMinAggregateOutputType | null
    _max: PesertaKelasMaxAggregateOutputType | null
  }

  export type PesertaKelasAvgAggregateOutputType = {
    id: number | null
    kelas_id: number | null
    mahasiswa_id: number | null
  }

  export type PesertaKelasSumAggregateOutputType = {
    id: number | null
    kelas_id: number | null
    mahasiswa_id: number | null
  }

  export type PesertaKelasMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    kelas_id: number | null
    mahasiswa_id: number | null
  }

  export type PesertaKelasMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    kelas_id: number | null
    mahasiswa_id: number | null
  }

  export type PesertaKelasCountAggregateOutputType = {
    id: number
    createdAt: number
    kelas_id: number
    mahasiswa_id: number
    _all: number
  }


  export type PesertaKelasAvgAggregateInputType = {
    id?: true
    kelas_id?: true
    mahasiswa_id?: true
  }

  export type PesertaKelasSumAggregateInputType = {
    id?: true
    kelas_id?: true
    mahasiswa_id?: true
  }

  export type PesertaKelasMinAggregateInputType = {
    id?: true
    createdAt?: true
    kelas_id?: true
    mahasiswa_id?: true
  }

  export type PesertaKelasMaxAggregateInputType = {
    id?: true
    createdAt?: true
    kelas_id?: true
    mahasiswa_id?: true
  }

  export type PesertaKelasCountAggregateInputType = {
    id?: true
    createdAt?: true
    kelas_id?: true
    mahasiswa_id?: true
    _all?: true
  }

  export type PesertaKelasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PesertaKelas to aggregate.
     */
    where?: PesertaKelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PesertaKelas to fetch.
     */
    orderBy?: PesertaKelasOrderByWithRelationInput | PesertaKelasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PesertaKelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PesertaKelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PesertaKelas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PesertaKelas
    **/
    _count?: true | PesertaKelasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PesertaKelasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PesertaKelasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PesertaKelasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PesertaKelasMaxAggregateInputType
  }

  export type GetPesertaKelasAggregateType<T extends PesertaKelasAggregateArgs> = {
        [P in keyof T & keyof AggregatePesertaKelas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePesertaKelas[P]>
      : GetScalarType<T[P], AggregatePesertaKelas[P]>
  }




  export type PesertaKelasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PesertaKelasWhereInput
    orderBy?: PesertaKelasOrderByWithAggregationInput | PesertaKelasOrderByWithAggregationInput[]
    by: PesertaKelasScalarFieldEnum[] | PesertaKelasScalarFieldEnum
    having?: PesertaKelasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PesertaKelasCountAggregateInputType | true
    _avg?: PesertaKelasAvgAggregateInputType
    _sum?: PesertaKelasSumAggregateInputType
    _min?: PesertaKelasMinAggregateInputType
    _max?: PesertaKelasMaxAggregateInputType
  }

  export type PesertaKelasGroupByOutputType = {
    id: number
    createdAt: Date
    kelas_id: number
    mahasiswa_id: number
    _count: PesertaKelasCountAggregateOutputType | null
    _avg: PesertaKelasAvgAggregateOutputType | null
    _sum: PesertaKelasSumAggregateOutputType | null
    _min: PesertaKelasMinAggregateOutputType | null
    _max: PesertaKelasMaxAggregateOutputType | null
  }

  type GetPesertaKelasGroupByPayload<T extends PesertaKelasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PesertaKelasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PesertaKelasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PesertaKelasGroupByOutputType[P]>
            : GetScalarType<T[P], PesertaKelasGroupByOutputType[P]>
        }
      >
    >


  export type PesertaKelasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    kelas_id?: boolean
    mahasiswa_id?: boolean
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
    mahasiswa?: boolean | UserDefaultArgs<ExtArgs>
    nilai?: boolean | PesertaKelas$nilaiArgs<ExtArgs>
    _count?: boolean | PesertaKelasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pesertaKelas"]>

  export type PesertaKelasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    kelas_id?: boolean
    mahasiswa_id?: boolean
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
    mahasiswa?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pesertaKelas"]>

  export type PesertaKelasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    kelas_id?: boolean
    mahasiswa_id?: boolean
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
    mahasiswa?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pesertaKelas"]>

  export type PesertaKelasSelectScalar = {
    id?: boolean
    createdAt?: boolean
    kelas_id?: boolean
    mahasiswa_id?: boolean
  }

  export type PesertaKelasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "kelas_id" | "mahasiswa_id", ExtArgs["result"]["pesertaKelas"]>
  export type PesertaKelasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
    mahasiswa?: boolean | UserDefaultArgs<ExtArgs>
    nilai?: boolean | PesertaKelas$nilaiArgs<ExtArgs>
    _count?: boolean | PesertaKelasCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PesertaKelasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
    mahasiswa?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PesertaKelasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
    mahasiswa?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PesertaKelasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PesertaKelas"
    objects: {
      kelas: Prisma.$KelasPayload<ExtArgs>
      mahasiswa: Prisma.$UserPayload<ExtArgs>
      nilai: Prisma.$NilaiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      kelas_id: number
      mahasiswa_id: number
    }, ExtArgs["result"]["pesertaKelas"]>
    composites: {}
  }

  type PesertaKelasGetPayload<S extends boolean | null | undefined | PesertaKelasDefaultArgs> = $Result.GetResult<Prisma.$PesertaKelasPayload, S>

  type PesertaKelasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PesertaKelasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PesertaKelasCountAggregateInputType | true
    }

  export interface PesertaKelasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PesertaKelas'], meta: { name: 'PesertaKelas' } }
    /**
     * Find zero or one PesertaKelas that matches the filter.
     * @param {PesertaKelasFindUniqueArgs} args - Arguments to find a PesertaKelas
     * @example
     * // Get one PesertaKelas
     * const pesertaKelas = await prisma.pesertaKelas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PesertaKelasFindUniqueArgs>(args: SelectSubset<T, PesertaKelasFindUniqueArgs<ExtArgs>>): Prisma__PesertaKelasClient<$Result.GetResult<Prisma.$PesertaKelasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PesertaKelas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PesertaKelasFindUniqueOrThrowArgs} args - Arguments to find a PesertaKelas
     * @example
     * // Get one PesertaKelas
     * const pesertaKelas = await prisma.pesertaKelas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PesertaKelasFindUniqueOrThrowArgs>(args: SelectSubset<T, PesertaKelasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PesertaKelasClient<$Result.GetResult<Prisma.$PesertaKelasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PesertaKelas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PesertaKelasFindFirstArgs} args - Arguments to find a PesertaKelas
     * @example
     * // Get one PesertaKelas
     * const pesertaKelas = await prisma.pesertaKelas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PesertaKelasFindFirstArgs>(args?: SelectSubset<T, PesertaKelasFindFirstArgs<ExtArgs>>): Prisma__PesertaKelasClient<$Result.GetResult<Prisma.$PesertaKelasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PesertaKelas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PesertaKelasFindFirstOrThrowArgs} args - Arguments to find a PesertaKelas
     * @example
     * // Get one PesertaKelas
     * const pesertaKelas = await prisma.pesertaKelas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PesertaKelasFindFirstOrThrowArgs>(args?: SelectSubset<T, PesertaKelasFindFirstOrThrowArgs<ExtArgs>>): Prisma__PesertaKelasClient<$Result.GetResult<Prisma.$PesertaKelasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PesertaKelas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PesertaKelasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PesertaKelas
     * const pesertaKelas = await prisma.pesertaKelas.findMany()
     * 
     * // Get first 10 PesertaKelas
     * const pesertaKelas = await prisma.pesertaKelas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pesertaKelasWithIdOnly = await prisma.pesertaKelas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PesertaKelasFindManyArgs>(args?: SelectSubset<T, PesertaKelasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PesertaKelasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PesertaKelas.
     * @param {PesertaKelasCreateArgs} args - Arguments to create a PesertaKelas.
     * @example
     * // Create one PesertaKelas
     * const PesertaKelas = await prisma.pesertaKelas.create({
     *   data: {
     *     // ... data to create a PesertaKelas
     *   }
     * })
     * 
     */
    create<T extends PesertaKelasCreateArgs>(args: SelectSubset<T, PesertaKelasCreateArgs<ExtArgs>>): Prisma__PesertaKelasClient<$Result.GetResult<Prisma.$PesertaKelasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PesertaKelas.
     * @param {PesertaKelasCreateManyArgs} args - Arguments to create many PesertaKelas.
     * @example
     * // Create many PesertaKelas
     * const pesertaKelas = await prisma.pesertaKelas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PesertaKelasCreateManyArgs>(args?: SelectSubset<T, PesertaKelasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PesertaKelas and returns the data saved in the database.
     * @param {PesertaKelasCreateManyAndReturnArgs} args - Arguments to create many PesertaKelas.
     * @example
     * // Create many PesertaKelas
     * const pesertaKelas = await prisma.pesertaKelas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PesertaKelas and only return the `id`
     * const pesertaKelasWithIdOnly = await prisma.pesertaKelas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PesertaKelasCreateManyAndReturnArgs>(args?: SelectSubset<T, PesertaKelasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PesertaKelasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PesertaKelas.
     * @param {PesertaKelasDeleteArgs} args - Arguments to delete one PesertaKelas.
     * @example
     * // Delete one PesertaKelas
     * const PesertaKelas = await prisma.pesertaKelas.delete({
     *   where: {
     *     // ... filter to delete one PesertaKelas
     *   }
     * })
     * 
     */
    delete<T extends PesertaKelasDeleteArgs>(args: SelectSubset<T, PesertaKelasDeleteArgs<ExtArgs>>): Prisma__PesertaKelasClient<$Result.GetResult<Prisma.$PesertaKelasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PesertaKelas.
     * @param {PesertaKelasUpdateArgs} args - Arguments to update one PesertaKelas.
     * @example
     * // Update one PesertaKelas
     * const pesertaKelas = await prisma.pesertaKelas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PesertaKelasUpdateArgs>(args: SelectSubset<T, PesertaKelasUpdateArgs<ExtArgs>>): Prisma__PesertaKelasClient<$Result.GetResult<Prisma.$PesertaKelasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PesertaKelas.
     * @param {PesertaKelasDeleteManyArgs} args - Arguments to filter PesertaKelas to delete.
     * @example
     * // Delete a few PesertaKelas
     * const { count } = await prisma.pesertaKelas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PesertaKelasDeleteManyArgs>(args?: SelectSubset<T, PesertaKelasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PesertaKelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PesertaKelasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PesertaKelas
     * const pesertaKelas = await prisma.pesertaKelas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PesertaKelasUpdateManyArgs>(args: SelectSubset<T, PesertaKelasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PesertaKelas and returns the data updated in the database.
     * @param {PesertaKelasUpdateManyAndReturnArgs} args - Arguments to update many PesertaKelas.
     * @example
     * // Update many PesertaKelas
     * const pesertaKelas = await prisma.pesertaKelas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PesertaKelas and only return the `id`
     * const pesertaKelasWithIdOnly = await prisma.pesertaKelas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PesertaKelasUpdateManyAndReturnArgs>(args: SelectSubset<T, PesertaKelasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PesertaKelasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PesertaKelas.
     * @param {PesertaKelasUpsertArgs} args - Arguments to update or create a PesertaKelas.
     * @example
     * // Update or create a PesertaKelas
     * const pesertaKelas = await prisma.pesertaKelas.upsert({
     *   create: {
     *     // ... data to create a PesertaKelas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PesertaKelas we want to update
     *   }
     * })
     */
    upsert<T extends PesertaKelasUpsertArgs>(args: SelectSubset<T, PesertaKelasUpsertArgs<ExtArgs>>): Prisma__PesertaKelasClient<$Result.GetResult<Prisma.$PesertaKelasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PesertaKelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PesertaKelasCountArgs} args - Arguments to filter PesertaKelas to count.
     * @example
     * // Count the number of PesertaKelas
     * const count = await prisma.pesertaKelas.count({
     *   where: {
     *     // ... the filter for the PesertaKelas we want to count
     *   }
     * })
    **/
    count<T extends PesertaKelasCountArgs>(
      args?: Subset<T, PesertaKelasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PesertaKelasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PesertaKelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PesertaKelasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PesertaKelasAggregateArgs>(args: Subset<T, PesertaKelasAggregateArgs>): Prisma.PrismaPromise<GetPesertaKelasAggregateType<T>>

    /**
     * Group by PesertaKelas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PesertaKelasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PesertaKelasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PesertaKelasGroupByArgs['orderBy'] }
        : { orderBy?: PesertaKelasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PesertaKelasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPesertaKelasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PesertaKelas model
   */
  readonly fields: PesertaKelasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PesertaKelas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PesertaKelasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kelas<T extends KelasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KelasDefaultArgs<ExtArgs>>): Prisma__KelasClient<$Result.GetResult<Prisma.$KelasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mahasiswa<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nilai<T extends PesertaKelas$nilaiArgs<ExtArgs> = {}>(args?: Subset<T, PesertaKelas$nilaiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NilaiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PesertaKelas model
   */
  interface PesertaKelasFieldRefs {
    readonly id: FieldRef<"PesertaKelas", 'Int'>
    readonly createdAt: FieldRef<"PesertaKelas", 'DateTime'>
    readonly kelas_id: FieldRef<"PesertaKelas", 'Int'>
    readonly mahasiswa_id: FieldRef<"PesertaKelas", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PesertaKelas findUnique
   */
  export type PesertaKelasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PesertaKelas
     */
    select?: PesertaKelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PesertaKelas
     */
    omit?: PesertaKelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PesertaKelasInclude<ExtArgs> | null
    /**
     * Filter, which PesertaKelas to fetch.
     */
    where: PesertaKelasWhereUniqueInput
  }

  /**
   * PesertaKelas findUniqueOrThrow
   */
  export type PesertaKelasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PesertaKelas
     */
    select?: PesertaKelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PesertaKelas
     */
    omit?: PesertaKelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PesertaKelasInclude<ExtArgs> | null
    /**
     * Filter, which PesertaKelas to fetch.
     */
    where: PesertaKelasWhereUniqueInput
  }

  /**
   * PesertaKelas findFirst
   */
  export type PesertaKelasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PesertaKelas
     */
    select?: PesertaKelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PesertaKelas
     */
    omit?: PesertaKelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PesertaKelasInclude<ExtArgs> | null
    /**
     * Filter, which PesertaKelas to fetch.
     */
    where?: PesertaKelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PesertaKelas to fetch.
     */
    orderBy?: PesertaKelasOrderByWithRelationInput | PesertaKelasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PesertaKelas.
     */
    cursor?: PesertaKelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PesertaKelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PesertaKelas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PesertaKelas.
     */
    distinct?: PesertaKelasScalarFieldEnum | PesertaKelasScalarFieldEnum[]
  }

  /**
   * PesertaKelas findFirstOrThrow
   */
  export type PesertaKelasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PesertaKelas
     */
    select?: PesertaKelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PesertaKelas
     */
    omit?: PesertaKelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PesertaKelasInclude<ExtArgs> | null
    /**
     * Filter, which PesertaKelas to fetch.
     */
    where?: PesertaKelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PesertaKelas to fetch.
     */
    orderBy?: PesertaKelasOrderByWithRelationInput | PesertaKelasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PesertaKelas.
     */
    cursor?: PesertaKelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PesertaKelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PesertaKelas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PesertaKelas.
     */
    distinct?: PesertaKelasScalarFieldEnum | PesertaKelasScalarFieldEnum[]
  }

  /**
   * PesertaKelas findMany
   */
  export type PesertaKelasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PesertaKelas
     */
    select?: PesertaKelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PesertaKelas
     */
    omit?: PesertaKelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PesertaKelasInclude<ExtArgs> | null
    /**
     * Filter, which PesertaKelas to fetch.
     */
    where?: PesertaKelasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PesertaKelas to fetch.
     */
    orderBy?: PesertaKelasOrderByWithRelationInput | PesertaKelasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PesertaKelas.
     */
    cursor?: PesertaKelasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PesertaKelas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PesertaKelas.
     */
    skip?: number
    distinct?: PesertaKelasScalarFieldEnum | PesertaKelasScalarFieldEnum[]
  }

  /**
   * PesertaKelas create
   */
  export type PesertaKelasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PesertaKelas
     */
    select?: PesertaKelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PesertaKelas
     */
    omit?: PesertaKelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PesertaKelasInclude<ExtArgs> | null
    /**
     * The data needed to create a PesertaKelas.
     */
    data: XOR<PesertaKelasCreateInput, PesertaKelasUncheckedCreateInput>
  }

  /**
   * PesertaKelas createMany
   */
  export type PesertaKelasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PesertaKelas.
     */
    data: PesertaKelasCreateManyInput | PesertaKelasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PesertaKelas createManyAndReturn
   */
  export type PesertaKelasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PesertaKelas
     */
    select?: PesertaKelasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PesertaKelas
     */
    omit?: PesertaKelasOmit<ExtArgs> | null
    /**
     * The data used to create many PesertaKelas.
     */
    data: PesertaKelasCreateManyInput | PesertaKelasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PesertaKelasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PesertaKelas update
   */
  export type PesertaKelasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PesertaKelas
     */
    select?: PesertaKelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PesertaKelas
     */
    omit?: PesertaKelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PesertaKelasInclude<ExtArgs> | null
    /**
     * The data needed to update a PesertaKelas.
     */
    data: XOR<PesertaKelasUpdateInput, PesertaKelasUncheckedUpdateInput>
    /**
     * Choose, which PesertaKelas to update.
     */
    where: PesertaKelasWhereUniqueInput
  }

  /**
   * PesertaKelas updateMany
   */
  export type PesertaKelasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PesertaKelas.
     */
    data: XOR<PesertaKelasUpdateManyMutationInput, PesertaKelasUncheckedUpdateManyInput>
    /**
     * Filter which PesertaKelas to update
     */
    where?: PesertaKelasWhereInput
    /**
     * Limit how many PesertaKelas to update.
     */
    limit?: number
  }

  /**
   * PesertaKelas updateManyAndReturn
   */
  export type PesertaKelasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PesertaKelas
     */
    select?: PesertaKelasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PesertaKelas
     */
    omit?: PesertaKelasOmit<ExtArgs> | null
    /**
     * The data used to update PesertaKelas.
     */
    data: XOR<PesertaKelasUpdateManyMutationInput, PesertaKelasUncheckedUpdateManyInput>
    /**
     * Filter which PesertaKelas to update
     */
    where?: PesertaKelasWhereInput
    /**
     * Limit how many PesertaKelas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PesertaKelasIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PesertaKelas upsert
   */
  export type PesertaKelasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PesertaKelas
     */
    select?: PesertaKelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PesertaKelas
     */
    omit?: PesertaKelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PesertaKelasInclude<ExtArgs> | null
    /**
     * The filter to search for the PesertaKelas to update in case it exists.
     */
    where: PesertaKelasWhereUniqueInput
    /**
     * In case the PesertaKelas found by the `where` argument doesn't exist, create a new PesertaKelas with this data.
     */
    create: XOR<PesertaKelasCreateInput, PesertaKelasUncheckedCreateInput>
    /**
     * In case the PesertaKelas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PesertaKelasUpdateInput, PesertaKelasUncheckedUpdateInput>
  }

  /**
   * PesertaKelas delete
   */
  export type PesertaKelasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PesertaKelas
     */
    select?: PesertaKelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PesertaKelas
     */
    omit?: PesertaKelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PesertaKelasInclude<ExtArgs> | null
    /**
     * Filter which PesertaKelas to delete.
     */
    where: PesertaKelasWhereUniqueInput
  }

  /**
   * PesertaKelas deleteMany
   */
  export type PesertaKelasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PesertaKelas to delete
     */
    where?: PesertaKelasWhereInput
    /**
     * Limit how many PesertaKelas to delete.
     */
    limit?: number
  }

  /**
   * PesertaKelas.nilai
   */
  export type PesertaKelas$nilaiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nilai
     */
    select?: NilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nilai
     */
    omit?: NilaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NilaiInclude<ExtArgs> | null
    where?: NilaiWhereInput
    orderBy?: NilaiOrderByWithRelationInput | NilaiOrderByWithRelationInput[]
    cursor?: NilaiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NilaiScalarFieldEnum | NilaiScalarFieldEnum[]
  }

  /**
   * PesertaKelas without action
   */
  export type PesertaKelasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PesertaKelas
     */
    select?: PesertaKelasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PesertaKelas
     */
    omit?: PesertaKelasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PesertaKelasInclude<ExtArgs> | null
  }


  /**
   * Model RPS
   */

  export type AggregateRPS = {
    _count: RPSCountAggregateOutputType | null
    _avg: RPSAvgAggregateOutputType | null
    _sum: RPSSumAggregateOutputType | null
    _min: RPSMinAggregateOutputType | null
    _max: RPSMaxAggregateOutputType | null
  }

  export type RPSAvgAggregateOutputType = {
    id: number | null
    kelas_id: number | null
  }

  export type RPSSumAggregateOutputType = {
    id: number | null
    kelas_id: number | null
  }

  export type RPSMinAggregateOutputType = {
    id: number | null
    file_path: string | null
    is_locked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    kelas_id: number | null
  }

  export type RPSMaxAggregateOutputType = {
    id: number | null
    file_path: string | null
    is_locked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    kelas_id: number | null
  }

  export type RPSCountAggregateOutputType = {
    id: number
    file_path: number
    is_locked: number
    createdAt: number
    updatedAt: number
    kelas_id: number
    _all: number
  }


  export type RPSAvgAggregateInputType = {
    id?: true
    kelas_id?: true
  }

  export type RPSSumAggregateInputType = {
    id?: true
    kelas_id?: true
  }

  export type RPSMinAggregateInputType = {
    id?: true
    file_path?: true
    is_locked?: true
    createdAt?: true
    updatedAt?: true
    kelas_id?: true
  }

  export type RPSMaxAggregateInputType = {
    id?: true
    file_path?: true
    is_locked?: true
    createdAt?: true
    updatedAt?: true
    kelas_id?: true
  }

  export type RPSCountAggregateInputType = {
    id?: true
    file_path?: true
    is_locked?: true
    createdAt?: true
    updatedAt?: true
    kelas_id?: true
    _all?: true
  }

  export type RPSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RPS to aggregate.
     */
    where?: RPSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RPS to fetch.
     */
    orderBy?: RPSOrderByWithRelationInput | RPSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RPSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RPS
    **/
    _count?: true | RPSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RPSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RPSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RPSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RPSMaxAggregateInputType
  }

  export type GetRPSAggregateType<T extends RPSAggregateArgs> = {
        [P in keyof T & keyof AggregateRPS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRPS[P]>
      : GetScalarType<T[P], AggregateRPS[P]>
  }




  export type RPSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RPSWhereInput
    orderBy?: RPSOrderByWithAggregationInput | RPSOrderByWithAggregationInput[]
    by: RPSScalarFieldEnum[] | RPSScalarFieldEnum
    having?: RPSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RPSCountAggregateInputType | true
    _avg?: RPSAvgAggregateInputType
    _sum?: RPSSumAggregateInputType
    _min?: RPSMinAggregateInputType
    _max?: RPSMaxAggregateInputType
  }

  export type RPSGroupByOutputType = {
    id: number
    file_path: string
    is_locked: boolean
    createdAt: Date
    updatedAt: Date
    kelas_id: number
    _count: RPSCountAggregateOutputType | null
    _avg: RPSAvgAggregateOutputType | null
    _sum: RPSSumAggregateOutputType | null
    _min: RPSMinAggregateOutputType | null
    _max: RPSMaxAggregateOutputType | null
  }

  type GetRPSGroupByPayload<T extends RPSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RPSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RPSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RPSGroupByOutputType[P]>
            : GetScalarType<T[P], RPSGroupByOutputType[P]>
        }
      >
    >


  export type RPSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file_path?: boolean
    is_locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kelas_id?: boolean
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rPS"]>

  export type RPSSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file_path?: boolean
    is_locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kelas_id?: boolean
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rPS"]>

  export type RPSSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file_path?: boolean
    is_locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kelas_id?: boolean
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rPS"]>

  export type RPSSelectScalar = {
    id?: boolean
    file_path?: boolean
    is_locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kelas_id?: boolean
  }

  export type RPSOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "file_path" | "is_locked" | "createdAt" | "updatedAt" | "kelas_id", ExtArgs["result"]["rPS"]>
  export type RPSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
  }
  export type RPSIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
  }
  export type RPSIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
  }

  export type $RPSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RPS"
    objects: {
      kelas: Prisma.$KelasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      file_path: string
      is_locked: boolean
      createdAt: Date
      updatedAt: Date
      kelas_id: number
    }, ExtArgs["result"]["rPS"]>
    composites: {}
  }

  type RPSGetPayload<S extends boolean | null | undefined | RPSDefaultArgs> = $Result.GetResult<Prisma.$RPSPayload, S>

  type RPSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RPSFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RPSCountAggregateInputType | true
    }

  export interface RPSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RPS'], meta: { name: 'RPS' } }
    /**
     * Find zero or one RPS that matches the filter.
     * @param {RPSFindUniqueArgs} args - Arguments to find a RPS
     * @example
     * // Get one RPS
     * const rPS = await prisma.rPS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RPSFindUniqueArgs>(args: SelectSubset<T, RPSFindUniqueArgs<ExtArgs>>): Prisma__RPSClient<$Result.GetResult<Prisma.$RPSPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RPS that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RPSFindUniqueOrThrowArgs} args - Arguments to find a RPS
     * @example
     * // Get one RPS
     * const rPS = await prisma.rPS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RPSFindUniqueOrThrowArgs>(args: SelectSubset<T, RPSFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RPSClient<$Result.GetResult<Prisma.$RPSPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RPSFindFirstArgs} args - Arguments to find a RPS
     * @example
     * // Get one RPS
     * const rPS = await prisma.rPS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RPSFindFirstArgs>(args?: SelectSubset<T, RPSFindFirstArgs<ExtArgs>>): Prisma__RPSClient<$Result.GetResult<Prisma.$RPSPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RPS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RPSFindFirstOrThrowArgs} args - Arguments to find a RPS
     * @example
     * // Get one RPS
     * const rPS = await prisma.rPS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RPSFindFirstOrThrowArgs>(args?: SelectSubset<T, RPSFindFirstOrThrowArgs<ExtArgs>>): Prisma__RPSClient<$Result.GetResult<Prisma.$RPSPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RPSFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RPS
     * const rPS = await prisma.rPS.findMany()
     * 
     * // Get first 10 RPS
     * const rPS = await prisma.rPS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rPSWithIdOnly = await prisma.rPS.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RPSFindManyArgs>(args?: SelectSubset<T, RPSFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RPSPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RPS.
     * @param {RPSCreateArgs} args - Arguments to create a RPS.
     * @example
     * // Create one RPS
     * const RPS = await prisma.rPS.create({
     *   data: {
     *     // ... data to create a RPS
     *   }
     * })
     * 
     */
    create<T extends RPSCreateArgs>(args: SelectSubset<T, RPSCreateArgs<ExtArgs>>): Prisma__RPSClient<$Result.GetResult<Prisma.$RPSPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RPS.
     * @param {RPSCreateManyArgs} args - Arguments to create many RPS.
     * @example
     * // Create many RPS
     * const rPS = await prisma.rPS.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RPSCreateManyArgs>(args?: SelectSubset<T, RPSCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RPS and returns the data saved in the database.
     * @param {RPSCreateManyAndReturnArgs} args - Arguments to create many RPS.
     * @example
     * // Create many RPS
     * const rPS = await prisma.rPS.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RPS and only return the `id`
     * const rPSWithIdOnly = await prisma.rPS.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RPSCreateManyAndReturnArgs>(args?: SelectSubset<T, RPSCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RPSPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RPS.
     * @param {RPSDeleteArgs} args - Arguments to delete one RPS.
     * @example
     * // Delete one RPS
     * const RPS = await prisma.rPS.delete({
     *   where: {
     *     // ... filter to delete one RPS
     *   }
     * })
     * 
     */
    delete<T extends RPSDeleteArgs>(args: SelectSubset<T, RPSDeleteArgs<ExtArgs>>): Prisma__RPSClient<$Result.GetResult<Prisma.$RPSPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RPS.
     * @param {RPSUpdateArgs} args - Arguments to update one RPS.
     * @example
     * // Update one RPS
     * const rPS = await prisma.rPS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RPSUpdateArgs>(args: SelectSubset<T, RPSUpdateArgs<ExtArgs>>): Prisma__RPSClient<$Result.GetResult<Prisma.$RPSPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RPS.
     * @param {RPSDeleteManyArgs} args - Arguments to filter RPS to delete.
     * @example
     * // Delete a few RPS
     * const { count } = await prisma.rPS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RPSDeleteManyArgs>(args?: SelectSubset<T, RPSDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RPSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RPS
     * const rPS = await prisma.rPS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RPSUpdateManyArgs>(args: SelectSubset<T, RPSUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RPS and returns the data updated in the database.
     * @param {RPSUpdateManyAndReturnArgs} args - Arguments to update many RPS.
     * @example
     * // Update many RPS
     * const rPS = await prisma.rPS.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RPS and only return the `id`
     * const rPSWithIdOnly = await prisma.rPS.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RPSUpdateManyAndReturnArgs>(args: SelectSubset<T, RPSUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RPSPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RPS.
     * @param {RPSUpsertArgs} args - Arguments to update or create a RPS.
     * @example
     * // Update or create a RPS
     * const rPS = await prisma.rPS.upsert({
     *   create: {
     *     // ... data to create a RPS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RPS we want to update
     *   }
     * })
     */
    upsert<T extends RPSUpsertArgs>(args: SelectSubset<T, RPSUpsertArgs<ExtArgs>>): Prisma__RPSClient<$Result.GetResult<Prisma.$RPSPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RPSCountArgs} args - Arguments to filter RPS to count.
     * @example
     * // Count the number of RPS
     * const count = await prisma.rPS.count({
     *   where: {
     *     // ... the filter for the RPS we want to count
     *   }
     * })
    **/
    count<T extends RPSCountArgs>(
      args?: Subset<T, RPSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RPSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RPSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RPSAggregateArgs>(args: Subset<T, RPSAggregateArgs>): Prisma.PrismaPromise<GetRPSAggregateType<T>>

    /**
     * Group by RPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RPSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RPSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RPSGroupByArgs['orderBy'] }
        : { orderBy?: RPSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RPSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRPSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RPS model
   */
  readonly fields: RPSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RPS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RPSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kelas<T extends KelasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KelasDefaultArgs<ExtArgs>>): Prisma__KelasClient<$Result.GetResult<Prisma.$KelasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RPS model
   */
  interface RPSFieldRefs {
    readonly id: FieldRef<"RPS", 'Int'>
    readonly file_path: FieldRef<"RPS", 'String'>
    readonly is_locked: FieldRef<"RPS", 'Boolean'>
    readonly createdAt: FieldRef<"RPS", 'DateTime'>
    readonly updatedAt: FieldRef<"RPS", 'DateTime'>
    readonly kelas_id: FieldRef<"RPS", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RPS findUnique
   */
  export type RPSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPS
     */
    select?: RPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RPS
     */
    omit?: RPSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPSInclude<ExtArgs> | null
    /**
     * Filter, which RPS to fetch.
     */
    where: RPSWhereUniqueInput
  }

  /**
   * RPS findUniqueOrThrow
   */
  export type RPSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPS
     */
    select?: RPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RPS
     */
    omit?: RPSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPSInclude<ExtArgs> | null
    /**
     * Filter, which RPS to fetch.
     */
    where: RPSWhereUniqueInput
  }

  /**
   * RPS findFirst
   */
  export type RPSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPS
     */
    select?: RPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RPS
     */
    omit?: RPSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPSInclude<ExtArgs> | null
    /**
     * Filter, which RPS to fetch.
     */
    where?: RPSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RPS to fetch.
     */
    orderBy?: RPSOrderByWithRelationInput | RPSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RPS.
     */
    cursor?: RPSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RPS.
     */
    distinct?: RPSScalarFieldEnum | RPSScalarFieldEnum[]
  }

  /**
   * RPS findFirstOrThrow
   */
  export type RPSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPS
     */
    select?: RPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RPS
     */
    omit?: RPSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPSInclude<ExtArgs> | null
    /**
     * Filter, which RPS to fetch.
     */
    where?: RPSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RPS to fetch.
     */
    orderBy?: RPSOrderByWithRelationInput | RPSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RPS.
     */
    cursor?: RPSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RPS.
     */
    distinct?: RPSScalarFieldEnum | RPSScalarFieldEnum[]
  }

  /**
   * RPS findMany
   */
  export type RPSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPS
     */
    select?: RPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RPS
     */
    omit?: RPSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPSInclude<ExtArgs> | null
    /**
     * Filter, which RPS to fetch.
     */
    where?: RPSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RPS to fetch.
     */
    orderBy?: RPSOrderByWithRelationInput | RPSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RPS.
     */
    cursor?: RPSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RPS.
     */
    skip?: number
    distinct?: RPSScalarFieldEnum | RPSScalarFieldEnum[]
  }

  /**
   * RPS create
   */
  export type RPSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPS
     */
    select?: RPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RPS
     */
    omit?: RPSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPSInclude<ExtArgs> | null
    /**
     * The data needed to create a RPS.
     */
    data: XOR<RPSCreateInput, RPSUncheckedCreateInput>
  }

  /**
   * RPS createMany
   */
  export type RPSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RPS.
     */
    data: RPSCreateManyInput | RPSCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RPS createManyAndReturn
   */
  export type RPSCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPS
     */
    select?: RPSSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RPS
     */
    omit?: RPSOmit<ExtArgs> | null
    /**
     * The data used to create many RPS.
     */
    data: RPSCreateManyInput | RPSCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPSIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RPS update
   */
  export type RPSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPS
     */
    select?: RPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RPS
     */
    omit?: RPSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPSInclude<ExtArgs> | null
    /**
     * The data needed to update a RPS.
     */
    data: XOR<RPSUpdateInput, RPSUncheckedUpdateInput>
    /**
     * Choose, which RPS to update.
     */
    where: RPSWhereUniqueInput
  }

  /**
   * RPS updateMany
   */
  export type RPSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RPS.
     */
    data: XOR<RPSUpdateManyMutationInput, RPSUncheckedUpdateManyInput>
    /**
     * Filter which RPS to update
     */
    where?: RPSWhereInput
    /**
     * Limit how many RPS to update.
     */
    limit?: number
  }

  /**
   * RPS updateManyAndReturn
   */
  export type RPSUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPS
     */
    select?: RPSSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RPS
     */
    omit?: RPSOmit<ExtArgs> | null
    /**
     * The data used to update RPS.
     */
    data: XOR<RPSUpdateManyMutationInput, RPSUncheckedUpdateManyInput>
    /**
     * Filter which RPS to update
     */
    where?: RPSWhereInput
    /**
     * Limit how many RPS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPSIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RPS upsert
   */
  export type RPSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPS
     */
    select?: RPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RPS
     */
    omit?: RPSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPSInclude<ExtArgs> | null
    /**
     * The filter to search for the RPS to update in case it exists.
     */
    where: RPSWhereUniqueInput
    /**
     * In case the RPS found by the `where` argument doesn't exist, create a new RPS with this data.
     */
    create: XOR<RPSCreateInput, RPSUncheckedCreateInput>
    /**
     * In case the RPS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RPSUpdateInput, RPSUncheckedUpdateInput>
  }

  /**
   * RPS delete
   */
  export type RPSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPS
     */
    select?: RPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RPS
     */
    omit?: RPSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPSInclude<ExtArgs> | null
    /**
     * Filter which RPS to delete.
     */
    where: RPSWhereUniqueInput
  }

  /**
   * RPS deleteMany
   */
  export type RPSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RPS to delete
     */
    where?: RPSWhereInput
    /**
     * Limit how many RPS to delete.
     */
    limit?: number
  }

  /**
   * RPS without action
   */
  export type RPSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RPS
     */
    select?: RPSSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RPS
     */
    omit?: RPSOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RPSInclude<ExtArgs> | null
  }


  /**
   * Model CPMK
   */

  export type AggregateCPMK = {
    _count: CPMKCountAggregateOutputType | null
    _avg: CPMKAvgAggregateOutputType | null
    _sum: CPMKSumAggregateOutputType | null
    _min: CPMKMinAggregateOutputType | null
    _max: CPMKMaxAggregateOutputType | null
  }

  export type CPMKAvgAggregateOutputType = {
    id: number | null
    kelas_id: number | null
  }

  export type CPMKSumAggregateOutputType = {
    id: number | null
    kelas_id: number | null
  }

  export type CPMKMinAggregateOutputType = {
    id: number | null
    kode_cpmk: string | null
    is_locked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    kelas_id: number | null
  }

  export type CPMKMaxAggregateOutputType = {
    id: number | null
    kode_cpmk: string | null
    is_locked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    kelas_id: number | null
  }

  export type CPMKCountAggregateOutputType = {
    id: number
    kode_cpmk: number
    is_locked: number
    createdAt: number
    updatedAt: number
    kelas_id: number
    _all: number
  }


  export type CPMKAvgAggregateInputType = {
    id?: true
    kelas_id?: true
  }

  export type CPMKSumAggregateInputType = {
    id?: true
    kelas_id?: true
  }

  export type CPMKMinAggregateInputType = {
    id?: true
    kode_cpmk?: true
    is_locked?: true
    createdAt?: true
    updatedAt?: true
    kelas_id?: true
  }

  export type CPMKMaxAggregateInputType = {
    id?: true
    kode_cpmk?: true
    is_locked?: true
    createdAt?: true
    updatedAt?: true
    kelas_id?: true
  }

  export type CPMKCountAggregateInputType = {
    id?: true
    kode_cpmk?: true
    is_locked?: true
    createdAt?: true
    updatedAt?: true
    kelas_id?: true
    _all?: true
  }

  export type CPMKAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CPMK to aggregate.
     */
    where?: CPMKWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CPMKS to fetch.
     */
    orderBy?: CPMKOrderByWithRelationInput | CPMKOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CPMKWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CPMKS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CPMKS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CPMKS
    **/
    _count?: true | CPMKCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CPMKAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CPMKSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CPMKMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CPMKMaxAggregateInputType
  }

  export type GetCPMKAggregateType<T extends CPMKAggregateArgs> = {
        [P in keyof T & keyof AggregateCPMK]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCPMK[P]>
      : GetScalarType<T[P], AggregateCPMK[P]>
  }




  export type CPMKGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CPMKWhereInput
    orderBy?: CPMKOrderByWithAggregationInput | CPMKOrderByWithAggregationInput[]
    by: CPMKScalarFieldEnum[] | CPMKScalarFieldEnum
    having?: CPMKScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CPMKCountAggregateInputType | true
    _avg?: CPMKAvgAggregateInputType
    _sum?: CPMKSumAggregateInputType
    _min?: CPMKMinAggregateInputType
    _max?: CPMKMaxAggregateInputType
  }

  export type CPMKGroupByOutputType = {
    id: number
    kode_cpmk: string
    is_locked: boolean
    createdAt: Date
    updatedAt: Date
    kelas_id: number
    _count: CPMKCountAggregateOutputType | null
    _avg: CPMKAvgAggregateOutputType | null
    _sum: CPMKSumAggregateOutputType | null
    _min: CPMKMinAggregateOutputType | null
    _max: CPMKMaxAggregateOutputType | null
  }

  type GetCPMKGroupByPayload<T extends CPMKGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CPMKGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CPMKGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CPMKGroupByOutputType[P]>
            : GetScalarType<T[P], CPMKGroupByOutputType[P]>
        }
      >
    >


  export type CPMKSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode_cpmk?: boolean
    is_locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kelas_id?: boolean
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
    komponenPenilaian?: boolean | CPMK$komponenPenilaianArgs<ExtArgs>
    piMap?: boolean | CPMK$piMapArgs<ExtArgs>
    _count?: boolean | CPMKCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cPMK"]>

  export type CPMKSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode_cpmk?: boolean
    is_locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kelas_id?: boolean
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cPMK"]>

  export type CPMKSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode_cpmk?: boolean
    is_locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kelas_id?: boolean
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cPMK"]>

  export type CPMKSelectScalar = {
    id?: boolean
    kode_cpmk?: boolean
    is_locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kelas_id?: boolean
  }

  export type CPMKOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kode_cpmk" | "is_locked" | "createdAt" | "updatedAt" | "kelas_id", ExtArgs["result"]["cPMK"]>
  export type CPMKInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
    komponenPenilaian?: boolean | CPMK$komponenPenilaianArgs<ExtArgs>
    piMap?: boolean | CPMK$piMapArgs<ExtArgs>
    _count?: boolean | CPMKCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CPMKIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
  }
  export type CPMKIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kelas?: boolean | KelasDefaultArgs<ExtArgs>
  }

  export type $CPMKPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CPMK"
    objects: {
      kelas: Prisma.$KelasPayload<ExtArgs>
      komponenPenilaian: Prisma.$KomponenPenilaianPayload<ExtArgs>[]
      piMap: Prisma.$CPMK_PI_MapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kode_cpmk: string
      is_locked: boolean
      createdAt: Date
      updatedAt: Date
      kelas_id: number
    }, ExtArgs["result"]["cPMK"]>
    composites: {}
  }

  type CPMKGetPayload<S extends boolean | null | undefined | CPMKDefaultArgs> = $Result.GetResult<Prisma.$CPMKPayload, S>

  type CPMKCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CPMKFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CPMKCountAggregateInputType | true
    }

  export interface CPMKDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CPMK'], meta: { name: 'CPMK' } }
    /**
     * Find zero or one CPMK that matches the filter.
     * @param {CPMKFindUniqueArgs} args - Arguments to find a CPMK
     * @example
     * // Get one CPMK
     * const cPMK = await prisma.cPMK.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CPMKFindUniqueArgs>(args: SelectSubset<T, CPMKFindUniqueArgs<ExtArgs>>): Prisma__CPMKClient<$Result.GetResult<Prisma.$CPMKPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CPMK that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CPMKFindUniqueOrThrowArgs} args - Arguments to find a CPMK
     * @example
     * // Get one CPMK
     * const cPMK = await prisma.cPMK.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CPMKFindUniqueOrThrowArgs>(args: SelectSubset<T, CPMKFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CPMKClient<$Result.GetResult<Prisma.$CPMKPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CPMK that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMKFindFirstArgs} args - Arguments to find a CPMK
     * @example
     * // Get one CPMK
     * const cPMK = await prisma.cPMK.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CPMKFindFirstArgs>(args?: SelectSubset<T, CPMKFindFirstArgs<ExtArgs>>): Prisma__CPMKClient<$Result.GetResult<Prisma.$CPMKPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CPMK that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMKFindFirstOrThrowArgs} args - Arguments to find a CPMK
     * @example
     * // Get one CPMK
     * const cPMK = await prisma.cPMK.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CPMKFindFirstOrThrowArgs>(args?: SelectSubset<T, CPMKFindFirstOrThrowArgs<ExtArgs>>): Prisma__CPMKClient<$Result.GetResult<Prisma.$CPMKPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CPMKS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMKFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CPMKS
     * const cPMKS = await prisma.cPMK.findMany()
     * 
     * // Get first 10 CPMKS
     * const cPMKS = await prisma.cPMK.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cPMKWithIdOnly = await prisma.cPMK.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CPMKFindManyArgs>(args?: SelectSubset<T, CPMKFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CPMKPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CPMK.
     * @param {CPMKCreateArgs} args - Arguments to create a CPMK.
     * @example
     * // Create one CPMK
     * const CPMK = await prisma.cPMK.create({
     *   data: {
     *     // ... data to create a CPMK
     *   }
     * })
     * 
     */
    create<T extends CPMKCreateArgs>(args: SelectSubset<T, CPMKCreateArgs<ExtArgs>>): Prisma__CPMKClient<$Result.GetResult<Prisma.$CPMKPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CPMKS.
     * @param {CPMKCreateManyArgs} args - Arguments to create many CPMKS.
     * @example
     * // Create many CPMKS
     * const cPMK = await prisma.cPMK.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CPMKCreateManyArgs>(args?: SelectSubset<T, CPMKCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CPMKS and returns the data saved in the database.
     * @param {CPMKCreateManyAndReturnArgs} args - Arguments to create many CPMKS.
     * @example
     * // Create many CPMKS
     * const cPMK = await prisma.cPMK.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CPMKS and only return the `id`
     * const cPMKWithIdOnly = await prisma.cPMK.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CPMKCreateManyAndReturnArgs>(args?: SelectSubset<T, CPMKCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CPMKPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CPMK.
     * @param {CPMKDeleteArgs} args - Arguments to delete one CPMK.
     * @example
     * // Delete one CPMK
     * const CPMK = await prisma.cPMK.delete({
     *   where: {
     *     // ... filter to delete one CPMK
     *   }
     * })
     * 
     */
    delete<T extends CPMKDeleteArgs>(args: SelectSubset<T, CPMKDeleteArgs<ExtArgs>>): Prisma__CPMKClient<$Result.GetResult<Prisma.$CPMKPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CPMK.
     * @param {CPMKUpdateArgs} args - Arguments to update one CPMK.
     * @example
     * // Update one CPMK
     * const cPMK = await prisma.cPMK.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CPMKUpdateArgs>(args: SelectSubset<T, CPMKUpdateArgs<ExtArgs>>): Prisma__CPMKClient<$Result.GetResult<Prisma.$CPMKPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CPMKS.
     * @param {CPMKDeleteManyArgs} args - Arguments to filter CPMKS to delete.
     * @example
     * // Delete a few CPMKS
     * const { count } = await prisma.cPMK.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CPMKDeleteManyArgs>(args?: SelectSubset<T, CPMKDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CPMKS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMKUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CPMKS
     * const cPMK = await prisma.cPMK.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CPMKUpdateManyArgs>(args: SelectSubset<T, CPMKUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CPMKS and returns the data updated in the database.
     * @param {CPMKUpdateManyAndReturnArgs} args - Arguments to update many CPMKS.
     * @example
     * // Update many CPMKS
     * const cPMK = await prisma.cPMK.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CPMKS and only return the `id`
     * const cPMKWithIdOnly = await prisma.cPMK.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CPMKUpdateManyAndReturnArgs>(args: SelectSubset<T, CPMKUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CPMKPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CPMK.
     * @param {CPMKUpsertArgs} args - Arguments to update or create a CPMK.
     * @example
     * // Update or create a CPMK
     * const cPMK = await prisma.cPMK.upsert({
     *   create: {
     *     // ... data to create a CPMK
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CPMK we want to update
     *   }
     * })
     */
    upsert<T extends CPMKUpsertArgs>(args: SelectSubset<T, CPMKUpsertArgs<ExtArgs>>): Prisma__CPMKClient<$Result.GetResult<Prisma.$CPMKPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CPMKS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMKCountArgs} args - Arguments to filter CPMKS to count.
     * @example
     * // Count the number of CPMKS
     * const count = await prisma.cPMK.count({
     *   where: {
     *     // ... the filter for the CPMKS we want to count
     *   }
     * })
    **/
    count<T extends CPMKCountArgs>(
      args?: Subset<T, CPMKCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CPMKCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CPMK.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMKAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CPMKAggregateArgs>(args: Subset<T, CPMKAggregateArgs>): Prisma.PrismaPromise<GetCPMKAggregateType<T>>

    /**
     * Group by CPMK.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMKGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CPMKGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CPMKGroupByArgs['orderBy'] }
        : { orderBy?: CPMKGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CPMKGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCPMKGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CPMK model
   */
  readonly fields: CPMKFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CPMK.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CPMKClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kelas<T extends KelasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KelasDefaultArgs<ExtArgs>>): Prisma__KelasClient<$Result.GetResult<Prisma.$KelasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    komponenPenilaian<T extends CPMK$komponenPenilaianArgs<ExtArgs> = {}>(args?: Subset<T, CPMK$komponenPenilaianArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KomponenPenilaianPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    piMap<T extends CPMK$piMapArgs<ExtArgs> = {}>(args?: Subset<T, CPMK$piMapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CPMK_PI_MapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CPMK model
   */
  interface CPMKFieldRefs {
    readonly id: FieldRef<"CPMK", 'Int'>
    readonly kode_cpmk: FieldRef<"CPMK", 'String'>
    readonly is_locked: FieldRef<"CPMK", 'Boolean'>
    readonly createdAt: FieldRef<"CPMK", 'DateTime'>
    readonly updatedAt: FieldRef<"CPMK", 'DateTime'>
    readonly kelas_id: FieldRef<"CPMK", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CPMK findUnique
   */
  export type CPMKFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK
     */
    select?: CPMKSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK
     */
    omit?: CPMKOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMKInclude<ExtArgs> | null
    /**
     * Filter, which CPMK to fetch.
     */
    where: CPMKWhereUniqueInput
  }

  /**
   * CPMK findUniqueOrThrow
   */
  export type CPMKFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK
     */
    select?: CPMKSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK
     */
    omit?: CPMKOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMKInclude<ExtArgs> | null
    /**
     * Filter, which CPMK to fetch.
     */
    where: CPMKWhereUniqueInput
  }

  /**
   * CPMK findFirst
   */
  export type CPMKFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK
     */
    select?: CPMKSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK
     */
    omit?: CPMKOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMKInclude<ExtArgs> | null
    /**
     * Filter, which CPMK to fetch.
     */
    where?: CPMKWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CPMKS to fetch.
     */
    orderBy?: CPMKOrderByWithRelationInput | CPMKOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CPMKS.
     */
    cursor?: CPMKWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CPMKS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CPMKS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CPMKS.
     */
    distinct?: CPMKScalarFieldEnum | CPMKScalarFieldEnum[]
  }

  /**
   * CPMK findFirstOrThrow
   */
  export type CPMKFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK
     */
    select?: CPMKSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK
     */
    omit?: CPMKOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMKInclude<ExtArgs> | null
    /**
     * Filter, which CPMK to fetch.
     */
    where?: CPMKWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CPMKS to fetch.
     */
    orderBy?: CPMKOrderByWithRelationInput | CPMKOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CPMKS.
     */
    cursor?: CPMKWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CPMKS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CPMKS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CPMKS.
     */
    distinct?: CPMKScalarFieldEnum | CPMKScalarFieldEnum[]
  }

  /**
   * CPMK findMany
   */
  export type CPMKFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK
     */
    select?: CPMKSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK
     */
    omit?: CPMKOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMKInclude<ExtArgs> | null
    /**
     * Filter, which CPMKS to fetch.
     */
    where?: CPMKWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CPMKS to fetch.
     */
    orderBy?: CPMKOrderByWithRelationInput | CPMKOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CPMKS.
     */
    cursor?: CPMKWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CPMKS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CPMKS.
     */
    skip?: number
    distinct?: CPMKScalarFieldEnum | CPMKScalarFieldEnum[]
  }

  /**
   * CPMK create
   */
  export type CPMKCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK
     */
    select?: CPMKSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK
     */
    omit?: CPMKOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMKInclude<ExtArgs> | null
    /**
     * The data needed to create a CPMK.
     */
    data: XOR<CPMKCreateInput, CPMKUncheckedCreateInput>
  }

  /**
   * CPMK createMany
   */
  export type CPMKCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CPMKS.
     */
    data: CPMKCreateManyInput | CPMKCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CPMK createManyAndReturn
   */
  export type CPMKCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK
     */
    select?: CPMKSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK
     */
    omit?: CPMKOmit<ExtArgs> | null
    /**
     * The data used to create many CPMKS.
     */
    data: CPMKCreateManyInput | CPMKCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMKIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CPMK update
   */
  export type CPMKUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK
     */
    select?: CPMKSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK
     */
    omit?: CPMKOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMKInclude<ExtArgs> | null
    /**
     * The data needed to update a CPMK.
     */
    data: XOR<CPMKUpdateInput, CPMKUncheckedUpdateInput>
    /**
     * Choose, which CPMK to update.
     */
    where: CPMKWhereUniqueInput
  }

  /**
   * CPMK updateMany
   */
  export type CPMKUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CPMKS.
     */
    data: XOR<CPMKUpdateManyMutationInput, CPMKUncheckedUpdateManyInput>
    /**
     * Filter which CPMKS to update
     */
    where?: CPMKWhereInput
    /**
     * Limit how many CPMKS to update.
     */
    limit?: number
  }

  /**
   * CPMK updateManyAndReturn
   */
  export type CPMKUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK
     */
    select?: CPMKSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK
     */
    omit?: CPMKOmit<ExtArgs> | null
    /**
     * The data used to update CPMKS.
     */
    data: XOR<CPMKUpdateManyMutationInput, CPMKUncheckedUpdateManyInput>
    /**
     * Filter which CPMKS to update
     */
    where?: CPMKWhereInput
    /**
     * Limit how many CPMKS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMKIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CPMK upsert
   */
  export type CPMKUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK
     */
    select?: CPMKSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK
     */
    omit?: CPMKOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMKInclude<ExtArgs> | null
    /**
     * The filter to search for the CPMK to update in case it exists.
     */
    where: CPMKWhereUniqueInput
    /**
     * In case the CPMK found by the `where` argument doesn't exist, create a new CPMK with this data.
     */
    create: XOR<CPMKCreateInput, CPMKUncheckedCreateInput>
    /**
     * In case the CPMK was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CPMKUpdateInput, CPMKUncheckedUpdateInput>
  }

  /**
   * CPMK delete
   */
  export type CPMKDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK
     */
    select?: CPMKSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK
     */
    omit?: CPMKOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMKInclude<ExtArgs> | null
    /**
     * Filter which CPMK to delete.
     */
    where: CPMKWhereUniqueInput
  }

  /**
   * CPMK deleteMany
   */
  export type CPMKDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CPMKS to delete
     */
    where?: CPMKWhereInput
    /**
     * Limit how many CPMKS to delete.
     */
    limit?: number
  }

  /**
   * CPMK.komponenPenilaian
   */
  export type CPMK$komponenPenilaianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomponenPenilaian
     */
    select?: KomponenPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomponenPenilaian
     */
    omit?: KomponenPenilaianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomponenPenilaianInclude<ExtArgs> | null
    where?: KomponenPenilaianWhereInput
    orderBy?: KomponenPenilaianOrderByWithRelationInput | KomponenPenilaianOrderByWithRelationInput[]
    cursor?: KomponenPenilaianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KomponenPenilaianScalarFieldEnum | KomponenPenilaianScalarFieldEnum[]
  }

  /**
   * CPMK.piMap
   */
  export type CPMK$piMapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK_PI_Map
     */
    select?: CPMK_PI_MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK_PI_Map
     */
    omit?: CPMK_PI_MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMK_PI_MapInclude<ExtArgs> | null
    where?: CPMK_PI_MapWhereInput
    orderBy?: CPMK_PI_MapOrderByWithRelationInput | CPMK_PI_MapOrderByWithRelationInput[]
    cursor?: CPMK_PI_MapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CPMK_PI_MapScalarFieldEnum | CPMK_PI_MapScalarFieldEnum[]
  }

  /**
   * CPMK without action
   */
  export type CPMKDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK
     */
    select?: CPMKSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK
     */
    omit?: CPMKOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMKInclude<ExtArgs> | null
  }


  /**
   * Model CPMK_PI_Map
   */

  export type AggregateCPMK_PI_Map = {
    _count: CPMK_PI_MapCountAggregateOutputType | null
    _avg: CPMK_PI_MapAvgAggregateOutputType | null
    _sum: CPMK_PI_MapSumAggregateOutputType | null
    _min: CPMK_PI_MapMinAggregateOutputType | null
    _max: CPMK_PI_MapMaxAggregateOutputType | null
  }

  export type CPMK_PI_MapAvgAggregateOutputType = {
    cpmk_id: number | null
    pi_id: number | null
  }

  export type CPMK_PI_MapSumAggregateOutputType = {
    cpmk_id: number | null
    pi_id: number | null
  }

  export type CPMK_PI_MapMinAggregateOutputType = {
    cpmk_id: number | null
    pi_id: number | null
  }

  export type CPMK_PI_MapMaxAggregateOutputType = {
    cpmk_id: number | null
    pi_id: number | null
  }

  export type CPMK_PI_MapCountAggregateOutputType = {
    cpmk_id: number
    pi_id: number
    _all: number
  }


  export type CPMK_PI_MapAvgAggregateInputType = {
    cpmk_id?: true
    pi_id?: true
  }

  export type CPMK_PI_MapSumAggregateInputType = {
    cpmk_id?: true
    pi_id?: true
  }

  export type CPMK_PI_MapMinAggregateInputType = {
    cpmk_id?: true
    pi_id?: true
  }

  export type CPMK_PI_MapMaxAggregateInputType = {
    cpmk_id?: true
    pi_id?: true
  }

  export type CPMK_PI_MapCountAggregateInputType = {
    cpmk_id?: true
    pi_id?: true
    _all?: true
  }

  export type CPMK_PI_MapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CPMK_PI_Map to aggregate.
     */
    where?: CPMK_PI_MapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CPMK_PI_Maps to fetch.
     */
    orderBy?: CPMK_PI_MapOrderByWithRelationInput | CPMK_PI_MapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CPMK_PI_MapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CPMK_PI_Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CPMK_PI_Maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CPMK_PI_Maps
    **/
    _count?: true | CPMK_PI_MapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CPMK_PI_MapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CPMK_PI_MapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CPMK_PI_MapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CPMK_PI_MapMaxAggregateInputType
  }

  export type GetCPMK_PI_MapAggregateType<T extends CPMK_PI_MapAggregateArgs> = {
        [P in keyof T & keyof AggregateCPMK_PI_Map]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCPMK_PI_Map[P]>
      : GetScalarType<T[P], AggregateCPMK_PI_Map[P]>
  }




  export type CPMK_PI_MapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CPMK_PI_MapWhereInput
    orderBy?: CPMK_PI_MapOrderByWithAggregationInput | CPMK_PI_MapOrderByWithAggregationInput[]
    by: CPMK_PI_MapScalarFieldEnum[] | CPMK_PI_MapScalarFieldEnum
    having?: CPMK_PI_MapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CPMK_PI_MapCountAggregateInputType | true
    _avg?: CPMK_PI_MapAvgAggregateInputType
    _sum?: CPMK_PI_MapSumAggregateInputType
    _min?: CPMK_PI_MapMinAggregateInputType
    _max?: CPMK_PI_MapMaxAggregateInputType
  }

  export type CPMK_PI_MapGroupByOutputType = {
    cpmk_id: number
    pi_id: number
    _count: CPMK_PI_MapCountAggregateOutputType | null
    _avg: CPMK_PI_MapAvgAggregateOutputType | null
    _sum: CPMK_PI_MapSumAggregateOutputType | null
    _min: CPMK_PI_MapMinAggregateOutputType | null
    _max: CPMK_PI_MapMaxAggregateOutputType | null
  }

  type GetCPMK_PI_MapGroupByPayload<T extends CPMK_PI_MapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CPMK_PI_MapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CPMK_PI_MapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CPMK_PI_MapGroupByOutputType[P]>
            : GetScalarType<T[P], CPMK_PI_MapGroupByOutputType[P]>
        }
      >
    >


  export type CPMK_PI_MapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cpmk_id?: boolean
    pi_id?: boolean
    cpmk?: boolean | CPMKDefaultArgs<ExtArgs>
    pi?: boolean | PerformanceIndicatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cPMK_PI_Map"]>

  export type CPMK_PI_MapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cpmk_id?: boolean
    pi_id?: boolean
    cpmk?: boolean | CPMKDefaultArgs<ExtArgs>
    pi?: boolean | PerformanceIndicatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cPMK_PI_Map"]>

  export type CPMK_PI_MapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cpmk_id?: boolean
    pi_id?: boolean
    cpmk?: boolean | CPMKDefaultArgs<ExtArgs>
    pi?: boolean | PerformanceIndicatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cPMK_PI_Map"]>

  export type CPMK_PI_MapSelectScalar = {
    cpmk_id?: boolean
    pi_id?: boolean
  }

  export type CPMK_PI_MapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cpmk_id" | "pi_id", ExtArgs["result"]["cPMK_PI_Map"]>
  export type CPMK_PI_MapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cpmk?: boolean | CPMKDefaultArgs<ExtArgs>
    pi?: boolean | PerformanceIndicatorDefaultArgs<ExtArgs>
  }
  export type CPMK_PI_MapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cpmk?: boolean | CPMKDefaultArgs<ExtArgs>
    pi?: boolean | PerformanceIndicatorDefaultArgs<ExtArgs>
  }
  export type CPMK_PI_MapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cpmk?: boolean | CPMKDefaultArgs<ExtArgs>
    pi?: boolean | PerformanceIndicatorDefaultArgs<ExtArgs>
  }

  export type $CPMK_PI_MapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CPMK_PI_Map"
    objects: {
      cpmk: Prisma.$CPMKPayload<ExtArgs>
      pi: Prisma.$PerformanceIndicatorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cpmk_id: number
      pi_id: number
    }, ExtArgs["result"]["cPMK_PI_Map"]>
    composites: {}
  }

  type CPMK_PI_MapGetPayload<S extends boolean | null | undefined | CPMK_PI_MapDefaultArgs> = $Result.GetResult<Prisma.$CPMK_PI_MapPayload, S>

  type CPMK_PI_MapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CPMK_PI_MapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CPMK_PI_MapCountAggregateInputType | true
    }

  export interface CPMK_PI_MapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CPMK_PI_Map'], meta: { name: 'CPMK_PI_Map' } }
    /**
     * Find zero or one CPMK_PI_Map that matches the filter.
     * @param {CPMK_PI_MapFindUniqueArgs} args - Arguments to find a CPMK_PI_Map
     * @example
     * // Get one CPMK_PI_Map
     * const cPMK_PI_Map = await prisma.cPMK_PI_Map.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CPMK_PI_MapFindUniqueArgs>(args: SelectSubset<T, CPMK_PI_MapFindUniqueArgs<ExtArgs>>): Prisma__CPMK_PI_MapClient<$Result.GetResult<Prisma.$CPMK_PI_MapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CPMK_PI_Map that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CPMK_PI_MapFindUniqueOrThrowArgs} args - Arguments to find a CPMK_PI_Map
     * @example
     * // Get one CPMK_PI_Map
     * const cPMK_PI_Map = await prisma.cPMK_PI_Map.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CPMK_PI_MapFindUniqueOrThrowArgs>(args: SelectSubset<T, CPMK_PI_MapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CPMK_PI_MapClient<$Result.GetResult<Prisma.$CPMK_PI_MapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CPMK_PI_Map that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMK_PI_MapFindFirstArgs} args - Arguments to find a CPMK_PI_Map
     * @example
     * // Get one CPMK_PI_Map
     * const cPMK_PI_Map = await prisma.cPMK_PI_Map.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CPMK_PI_MapFindFirstArgs>(args?: SelectSubset<T, CPMK_PI_MapFindFirstArgs<ExtArgs>>): Prisma__CPMK_PI_MapClient<$Result.GetResult<Prisma.$CPMK_PI_MapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CPMK_PI_Map that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMK_PI_MapFindFirstOrThrowArgs} args - Arguments to find a CPMK_PI_Map
     * @example
     * // Get one CPMK_PI_Map
     * const cPMK_PI_Map = await prisma.cPMK_PI_Map.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CPMK_PI_MapFindFirstOrThrowArgs>(args?: SelectSubset<T, CPMK_PI_MapFindFirstOrThrowArgs<ExtArgs>>): Prisma__CPMK_PI_MapClient<$Result.GetResult<Prisma.$CPMK_PI_MapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CPMK_PI_Maps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMK_PI_MapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CPMK_PI_Maps
     * const cPMK_PI_Maps = await prisma.cPMK_PI_Map.findMany()
     * 
     * // Get first 10 CPMK_PI_Maps
     * const cPMK_PI_Maps = await prisma.cPMK_PI_Map.findMany({ take: 10 })
     * 
     * // Only select the `cpmk_id`
     * const cPMK_PI_MapWithCpmk_idOnly = await prisma.cPMK_PI_Map.findMany({ select: { cpmk_id: true } })
     * 
     */
    findMany<T extends CPMK_PI_MapFindManyArgs>(args?: SelectSubset<T, CPMK_PI_MapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CPMK_PI_MapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CPMK_PI_Map.
     * @param {CPMK_PI_MapCreateArgs} args - Arguments to create a CPMK_PI_Map.
     * @example
     * // Create one CPMK_PI_Map
     * const CPMK_PI_Map = await prisma.cPMK_PI_Map.create({
     *   data: {
     *     // ... data to create a CPMK_PI_Map
     *   }
     * })
     * 
     */
    create<T extends CPMK_PI_MapCreateArgs>(args: SelectSubset<T, CPMK_PI_MapCreateArgs<ExtArgs>>): Prisma__CPMK_PI_MapClient<$Result.GetResult<Prisma.$CPMK_PI_MapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CPMK_PI_Maps.
     * @param {CPMK_PI_MapCreateManyArgs} args - Arguments to create many CPMK_PI_Maps.
     * @example
     * // Create many CPMK_PI_Maps
     * const cPMK_PI_Map = await prisma.cPMK_PI_Map.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CPMK_PI_MapCreateManyArgs>(args?: SelectSubset<T, CPMK_PI_MapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CPMK_PI_Maps and returns the data saved in the database.
     * @param {CPMK_PI_MapCreateManyAndReturnArgs} args - Arguments to create many CPMK_PI_Maps.
     * @example
     * // Create many CPMK_PI_Maps
     * const cPMK_PI_Map = await prisma.cPMK_PI_Map.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CPMK_PI_Maps and only return the `cpmk_id`
     * const cPMK_PI_MapWithCpmk_idOnly = await prisma.cPMK_PI_Map.createManyAndReturn({
     *   select: { cpmk_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CPMK_PI_MapCreateManyAndReturnArgs>(args?: SelectSubset<T, CPMK_PI_MapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CPMK_PI_MapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CPMK_PI_Map.
     * @param {CPMK_PI_MapDeleteArgs} args - Arguments to delete one CPMK_PI_Map.
     * @example
     * // Delete one CPMK_PI_Map
     * const CPMK_PI_Map = await prisma.cPMK_PI_Map.delete({
     *   where: {
     *     // ... filter to delete one CPMK_PI_Map
     *   }
     * })
     * 
     */
    delete<T extends CPMK_PI_MapDeleteArgs>(args: SelectSubset<T, CPMK_PI_MapDeleteArgs<ExtArgs>>): Prisma__CPMK_PI_MapClient<$Result.GetResult<Prisma.$CPMK_PI_MapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CPMK_PI_Map.
     * @param {CPMK_PI_MapUpdateArgs} args - Arguments to update one CPMK_PI_Map.
     * @example
     * // Update one CPMK_PI_Map
     * const cPMK_PI_Map = await prisma.cPMK_PI_Map.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CPMK_PI_MapUpdateArgs>(args: SelectSubset<T, CPMK_PI_MapUpdateArgs<ExtArgs>>): Prisma__CPMK_PI_MapClient<$Result.GetResult<Prisma.$CPMK_PI_MapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CPMK_PI_Maps.
     * @param {CPMK_PI_MapDeleteManyArgs} args - Arguments to filter CPMK_PI_Maps to delete.
     * @example
     * // Delete a few CPMK_PI_Maps
     * const { count } = await prisma.cPMK_PI_Map.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CPMK_PI_MapDeleteManyArgs>(args?: SelectSubset<T, CPMK_PI_MapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CPMK_PI_Maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMK_PI_MapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CPMK_PI_Maps
     * const cPMK_PI_Map = await prisma.cPMK_PI_Map.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CPMK_PI_MapUpdateManyArgs>(args: SelectSubset<T, CPMK_PI_MapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CPMK_PI_Maps and returns the data updated in the database.
     * @param {CPMK_PI_MapUpdateManyAndReturnArgs} args - Arguments to update many CPMK_PI_Maps.
     * @example
     * // Update many CPMK_PI_Maps
     * const cPMK_PI_Map = await prisma.cPMK_PI_Map.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CPMK_PI_Maps and only return the `cpmk_id`
     * const cPMK_PI_MapWithCpmk_idOnly = await prisma.cPMK_PI_Map.updateManyAndReturn({
     *   select: { cpmk_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CPMK_PI_MapUpdateManyAndReturnArgs>(args: SelectSubset<T, CPMK_PI_MapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CPMK_PI_MapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CPMK_PI_Map.
     * @param {CPMK_PI_MapUpsertArgs} args - Arguments to update or create a CPMK_PI_Map.
     * @example
     * // Update or create a CPMK_PI_Map
     * const cPMK_PI_Map = await prisma.cPMK_PI_Map.upsert({
     *   create: {
     *     // ... data to create a CPMK_PI_Map
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CPMK_PI_Map we want to update
     *   }
     * })
     */
    upsert<T extends CPMK_PI_MapUpsertArgs>(args: SelectSubset<T, CPMK_PI_MapUpsertArgs<ExtArgs>>): Prisma__CPMK_PI_MapClient<$Result.GetResult<Prisma.$CPMK_PI_MapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CPMK_PI_Maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMK_PI_MapCountArgs} args - Arguments to filter CPMK_PI_Maps to count.
     * @example
     * // Count the number of CPMK_PI_Maps
     * const count = await prisma.cPMK_PI_Map.count({
     *   where: {
     *     // ... the filter for the CPMK_PI_Maps we want to count
     *   }
     * })
    **/
    count<T extends CPMK_PI_MapCountArgs>(
      args?: Subset<T, CPMK_PI_MapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CPMK_PI_MapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CPMK_PI_Map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMK_PI_MapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CPMK_PI_MapAggregateArgs>(args: Subset<T, CPMK_PI_MapAggregateArgs>): Prisma.PrismaPromise<GetCPMK_PI_MapAggregateType<T>>

    /**
     * Group by CPMK_PI_Map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMK_PI_MapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CPMK_PI_MapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CPMK_PI_MapGroupByArgs['orderBy'] }
        : { orderBy?: CPMK_PI_MapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CPMK_PI_MapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCPMK_PI_MapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CPMK_PI_Map model
   */
  readonly fields: CPMK_PI_MapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CPMK_PI_Map.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CPMK_PI_MapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cpmk<T extends CPMKDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CPMKDefaultArgs<ExtArgs>>): Prisma__CPMKClient<$Result.GetResult<Prisma.$CPMKPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pi<T extends PerformanceIndicatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PerformanceIndicatorDefaultArgs<ExtArgs>>): Prisma__PerformanceIndicatorClient<$Result.GetResult<Prisma.$PerformanceIndicatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CPMK_PI_Map model
   */
  interface CPMK_PI_MapFieldRefs {
    readonly cpmk_id: FieldRef<"CPMK_PI_Map", 'Int'>
    readonly pi_id: FieldRef<"CPMK_PI_Map", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CPMK_PI_Map findUnique
   */
  export type CPMK_PI_MapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK_PI_Map
     */
    select?: CPMK_PI_MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK_PI_Map
     */
    omit?: CPMK_PI_MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMK_PI_MapInclude<ExtArgs> | null
    /**
     * Filter, which CPMK_PI_Map to fetch.
     */
    where: CPMK_PI_MapWhereUniqueInput
  }

  /**
   * CPMK_PI_Map findUniqueOrThrow
   */
  export type CPMK_PI_MapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK_PI_Map
     */
    select?: CPMK_PI_MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK_PI_Map
     */
    omit?: CPMK_PI_MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMK_PI_MapInclude<ExtArgs> | null
    /**
     * Filter, which CPMK_PI_Map to fetch.
     */
    where: CPMK_PI_MapWhereUniqueInput
  }

  /**
   * CPMK_PI_Map findFirst
   */
  export type CPMK_PI_MapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK_PI_Map
     */
    select?: CPMK_PI_MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK_PI_Map
     */
    omit?: CPMK_PI_MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMK_PI_MapInclude<ExtArgs> | null
    /**
     * Filter, which CPMK_PI_Map to fetch.
     */
    where?: CPMK_PI_MapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CPMK_PI_Maps to fetch.
     */
    orderBy?: CPMK_PI_MapOrderByWithRelationInput | CPMK_PI_MapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CPMK_PI_Maps.
     */
    cursor?: CPMK_PI_MapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CPMK_PI_Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CPMK_PI_Maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CPMK_PI_Maps.
     */
    distinct?: CPMK_PI_MapScalarFieldEnum | CPMK_PI_MapScalarFieldEnum[]
  }

  /**
   * CPMK_PI_Map findFirstOrThrow
   */
  export type CPMK_PI_MapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK_PI_Map
     */
    select?: CPMK_PI_MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK_PI_Map
     */
    omit?: CPMK_PI_MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMK_PI_MapInclude<ExtArgs> | null
    /**
     * Filter, which CPMK_PI_Map to fetch.
     */
    where?: CPMK_PI_MapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CPMK_PI_Maps to fetch.
     */
    orderBy?: CPMK_PI_MapOrderByWithRelationInput | CPMK_PI_MapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CPMK_PI_Maps.
     */
    cursor?: CPMK_PI_MapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CPMK_PI_Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CPMK_PI_Maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CPMK_PI_Maps.
     */
    distinct?: CPMK_PI_MapScalarFieldEnum | CPMK_PI_MapScalarFieldEnum[]
  }

  /**
   * CPMK_PI_Map findMany
   */
  export type CPMK_PI_MapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK_PI_Map
     */
    select?: CPMK_PI_MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK_PI_Map
     */
    omit?: CPMK_PI_MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMK_PI_MapInclude<ExtArgs> | null
    /**
     * Filter, which CPMK_PI_Maps to fetch.
     */
    where?: CPMK_PI_MapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CPMK_PI_Maps to fetch.
     */
    orderBy?: CPMK_PI_MapOrderByWithRelationInput | CPMK_PI_MapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CPMK_PI_Maps.
     */
    cursor?: CPMK_PI_MapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CPMK_PI_Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CPMK_PI_Maps.
     */
    skip?: number
    distinct?: CPMK_PI_MapScalarFieldEnum | CPMK_PI_MapScalarFieldEnum[]
  }

  /**
   * CPMK_PI_Map create
   */
  export type CPMK_PI_MapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK_PI_Map
     */
    select?: CPMK_PI_MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK_PI_Map
     */
    omit?: CPMK_PI_MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMK_PI_MapInclude<ExtArgs> | null
    /**
     * The data needed to create a CPMK_PI_Map.
     */
    data: XOR<CPMK_PI_MapCreateInput, CPMK_PI_MapUncheckedCreateInput>
  }

  /**
   * CPMK_PI_Map createMany
   */
  export type CPMK_PI_MapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CPMK_PI_Maps.
     */
    data: CPMK_PI_MapCreateManyInput | CPMK_PI_MapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CPMK_PI_Map createManyAndReturn
   */
  export type CPMK_PI_MapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK_PI_Map
     */
    select?: CPMK_PI_MapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK_PI_Map
     */
    omit?: CPMK_PI_MapOmit<ExtArgs> | null
    /**
     * The data used to create many CPMK_PI_Maps.
     */
    data: CPMK_PI_MapCreateManyInput | CPMK_PI_MapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMK_PI_MapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CPMK_PI_Map update
   */
  export type CPMK_PI_MapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK_PI_Map
     */
    select?: CPMK_PI_MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK_PI_Map
     */
    omit?: CPMK_PI_MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMK_PI_MapInclude<ExtArgs> | null
    /**
     * The data needed to update a CPMK_PI_Map.
     */
    data: XOR<CPMK_PI_MapUpdateInput, CPMK_PI_MapUncheckedUpdateInput>
    /**
     * Choose, which CPMK_PI_Map to update.
     */
    where: CPMK_PI_MapWhereUniqueInput
  }

  /**
   * CPMK_PI_Map updateMany
   */
  export type CPMK_PI_MapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CPMK_PI_Maps.
     */
    data: XOR<CPMK_PI_MapUpdateManyMutationInput, CPMK_PI_MapUncheckedUpdateManyInput>
    /**
     * Filter which CPMK_PI_Maps to update
     */
    where?: CPMK_PI_MapWhereInput
    /**
     * Limit how many CPMK_PI_Maps to update.
     */
    limit?: number
  }

  /**
   * CPMK_PI_Map updateManyAndReturn
   */
  export type CPMK_PI_MapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK_PI_Map
     */
    select?: CPMK_PI_MapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK_PI_Map
     */
    omit?: CPMK_PI_MapOmit<ExtArgs> | null
    /**
     * The data used to update CPMK_PI_Maps.
     */
    data: XOR<CPMK_PI_MapUpdateManyMutationInput, CPMK_PI_MapUncheckedUpdateManyInput>
    /**
     * Filter which CPMK_PI_Maps to update
     */
    where?: CPMK_PI_MapWhereInput
    /**
     * Limit how many CPMK_PI_Maps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMK_PI_MapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CPMK_PI_Map upsert
   */
  export type CPMK_PI_MapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK_PI_Map
     */
    select?: CPMK_PI_MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK_PI_Map
     */
    omit?: CPMK_PI_MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMK_PI_MapInclude<ExtArgs> | null
    /**
     * The filter to search for the CPMK_PI_Map to update in case it exists.
     */
    where: CPMK_PI_MapWhereUniqueInput
    /**
     * In case the CPMK_PI_Map found by the `where` argument doesn't exist, create a new CPMK_PI_Map with this data.
     */
    create: XOR<CPMK_PI_MapCreateInput, CPMK_PI_MapUncheckedCreateInput>
    /**
     * In case the CPMK_PI_Map was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CPMK_PI_MapUpdateInput, CPMK_PI_MapUncheckedUpdateInput>
  }

  /**
   * CPMK_PI_Map delete
   */
  export type CPMK_PI_MapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK_PI_Map
     */
    select?: CPMK_PI_MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK_PI_Map
     */
    omit?: CPMK_PI_MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMK_PI_MapInclude<ExtArgs> | null
    /**
     * Filter which CPMK_PI_Map to delete.
     */
    where: CPMK_PI_MapWhereUniqueInput
  }

  /**
   * CPMK_PI_Map deleteMany
   */
  export type CPMK_PI_MapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CPMK_PI_Maps to delete
     */
    where?: CPMK_PI_MapWhereInput
    /**
     * Limit how many CPMK_PI_Maps to delete.
     */
    limit?: number
  }

  /**
   * CPMK_PI_Map without action
   */
  export type CPMK_PI_MapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMK_PI_Map
     */
    select?: CPMK_PI_MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMK_PI_Map
     */
    omit?: CPMK_PI_MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMK_PI_MapInclude<ExtArgs> | null
  }


  /**
   * Model KomponenPenilaian
   */

  export type AggregateKomponenPenilaian = {
    _count: KomponenPenilaianCountAggregateOutputType | null
    _avg: KomponenPenilaianAvgAggregateOutputType | null
    _sum: KomponenPenilaianSumAggregateOutputType | null
    _min: KomponenPenilaianMinAggregateOutputType | null
    _max: KomponenPenilaianMaxAggregateOutputType | null
  }

  export type KomponenPenilaianAvgAggregateOutputType = {
    id: number | null
    bobot: number | null
    cpmk_id: number | null
  }

  export type KomponenPenilaianSumAggregateOutputType = {
    id: number | null
    bobot: number | null
    cpmk_id: number | null
  }

  export type KomponenPenilaianMinAggregateOutputType = {
    id: number | null
    nama: string | null
    bobot: number | null
    createdAt: Date | null
    updatedAt: Date | null
    cpmk_id: number | null
  }

  export type KomponenPenilaianMaxAggregateOutputType = {
    id: number | null
    nama: string | null
    bobot: number | null
    createdAt: Date | null
    updatedAt: Date | null
    cpmk_id: number | null
  }

  export type KomponenPenilaianCountAggregateOutputType = {
    id: number
    nama: number
    bobot: number
    createdAt: number
    updatedAt: number
    cpmk_id: number
    _all: number
  }


  export type KomponenPenilaianAvgAggregateInputType = {
    id?: true
    bobot?: true
    cpmk_id?: true
  }

  export type KomponenPenilaianSumAggregateInputType = {
    id?: true
    bobot?: true
    cpmk_id?: true
  }

  export type KomponenPenilaianMinAggregateInputType = {
    id?: true
    nama?: true
    bobot?: true
    createdAt?: true
    updatedAt?: true
    cpmk_id?: true
  }

  export type KomponenPenilaianMaxAggregateInputType = {
    id?: true
    nama?: true
    bobot?: true
    createdAt?: true
    updatedAt?: true
    cpmk_id?: true
  }

  export type KomponenPenilaianCountAggregateInputType = {
    id?: true
    nama?: true
    bobot?: true
    createdAt?: true
    updatedAt?: true
    cpmk_id?: true
    _all?: true
  }

  export type KomponenPenilaianAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KomponenPenilaian to aggregate.
     */
    where?: KomponenPenilaianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KomponenPenilaians to fetch.
     */
    orderBy?: KomponenPenilaianOrderByWithRelationInput | KomponenPenilaianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KomponenPenilaianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KomponenPenilaians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KomponenPenilaians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KomponenPenilaians
    **/
    _count?: true | KomponenPenilaianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KomponenPenilaianAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KomponenPenilaianSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KomponenPenilaianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KomponenPenilaianMaxAggregateInputType
  }

  export type GetKomponenPenilaianAggregateType<T extends KomponenPenilaianAggregateArgs> = {
        [P in keyof T & keyof AggregateKomponenPenilaian]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKomponenPenilaian[P]>
      : GetScalarType<T[P], AggregateKomponenPenilaian[P]>
  }




  export type KomponenPenilaianGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KomponenPenilaianWhereInput
    orderBy?: KomponenPenilaianOrderByWithAggregationInput | KomponenPenilaianOrderByWithAggregationInput[]
    by: KomponenPenilaianScalarFieldEnum[] | KomponenPenilaianScalarFieldEnum
    having?: KomponenPenilaianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KomponenPenilaianCountAggregateInputType | true
    _avg?: KomponenPenilaianAvgAggregateInputType
    _sum?: KomponenPenilaianSumAggregateInputType
    _min?: KomponenPenilaianMinAggregateInputType
    _max?: KomponenPenilaianMaxAggregateInputType
  }

  export type KomponenPenilaianGroupByOutputType = {
    id: number
    nama: string
    bobot: number
    createdAt: Date
    updatedAt: Date
    cpmk_id: number
    _count: KomponenPenilaianCountAggregateOutputType | null
    _avg: KomponenPenilaianAvgAggregateOutputType | null
    _sum: KomponenPenilaianSumAggregateOutputType | null
    _min: KomponenPenilaianMinAggregateOutputType | null
    _max: KomponenPenilaianMaxAggregateOutputType | null
  }

  type GetKomponenPenilaianGroupByPayload<T extends KomponenPenilaianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KomponenPenilaianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KomponenPenilaianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KomponenPenilaianGroupByOutputType[P]>
            : GetScalarType<T[P], KomponenPenilaianGroupByOutputType[P]>
        }
      >
    >


  export type KomponenPenilaianSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    bobot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cpmk_id?: boolean
    cpmk?: boolean | CPMKDefaultArgs<ExtArgs>
    nilai?: boolean | KomponenPenilaian$nilaiArgs<ExtArgs>
    _count?: boolean | KomponenPenilaianCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["komponenPenilaian"]>

  export type KomponenPenilaianSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    bobot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cpmk_id?: boolean
    cpmk?: boolean | CPMKDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["komponenPenilaian"]>

  export type KomponenPenilaianSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    bobot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cpmk_id?: boolean
    cpmk?: boolean | CPMKDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["komponenPenilaian"]>

  export type KomponenPenilaianSelectScalar = {
    id?: boolean
    nama?: boolean
    bobot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cpmk_id?: boolean
  }

  export type KomponenPenilaianOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nama" | "bobot" | "createdAt" | "updatedAt" | "cpmk_id", ExtArgs["result"]["komponenPenilaian"]>
  export type KomponenPenilaianInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cpmk?: boolean | CPMKDefaultArgs<ExtArgs>
    nilai?: boolean | KomponenPenilaian$nilaiArgs<ExtArgs>
    _count?: boolean | KomponenPenilaianCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KomponenPenilaianIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cpmk?: boolean | CPMKDefaultArgs<ExtArgs>
  }
  export type KomponenPenilaianIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cpmk?: boolean | CPMKDefaultArgs<ExtArgs>
  }

  export type $KomponenPenilaianPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KomponenPenilaian"
    objects: {
      cpmk: Prisma.$CPMKPayload<ExtArgs>
      nilai: Prisma.$NilaiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama: string
      bobot: number
      createdAt: Date
      updatedAt: Date
      cpmk_id: number
    }, ExtArgs["result"]["komponenPenilaian"]>
    composites: {}
  }

  type KomponenPenilaianGetPayload<S extends boolean | null | undefined | KomponenPenilaianDefaultArgs> = $Result.GetResult<Prisma.$KomponenPenilaianPayload, S>

  type KomponenPenilaianCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KomponenPenilaianFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KomponenPenilaianCountAggregateInputType | true
    }

  export interface KomponenPenilaianDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KomponenPenilaian'], meta: { name: 'KomponenPenilaian' } }
    /**
     * Find zero or one KomponenPenilaian that matches the filter.
     * @param {KomponenPenilaianFindUniqueArgs} args - Arguments to find a KomponenPenilaian
     * @example
     * // Get one KomponenPenilaian
     * const komponenPenilaian = await prisma.komponenPenilaian.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KomponenPenilaianFindUniqueArgs>(args: SelectSubset<T, KomponenPenilaianFindUniqueArgs<ExtArgs>>): Prisma__KomponenPenilaianClient<$Result.GetResult<Prisma.$KomponenPenilaianPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KomponenPenilaian that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KomponenPenilaianFindUniqueOrThrowArgs} args - Arguments to find a KomponenPenilaian
     * @example
     * // Get one KomponenPenilaian
     * const komponenPenilaian = await prisma.komponenPenilaian.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KomponenPenilaianFindUniqueOrThrowArgs>(args: SelectSubset<T, KomponenPenilaianFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KomponenPenilaianClient<$Result.GetResult<Prisma.$KomponenPenilaianPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KomponenPenilaian that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KomponenPenilaianFindFirstArgs} args - Arguments to find a KomponenPenilaian
     * @example
     * // Get one KomponenPenilaian
     * const komponenPenilaian = await prisma.komponenPenilaian.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KomponenPenilaianFindFirstArgs>(args?: SelectSubset<T, KomponenPenilaianFindFirstArgs<ExtArgs>>): Prisma__KomponenPenilaianClient<$Result.GetResult<Prisma.$KomponenPenilaianPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KomponenPenilaian that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KomponenPenilaianFindFirstOrThrowArgs} args - Arguments to find a KomponenPenilaian
     * @example
     * // Get one KomponenPenilaian
     * const komponenPenilaian = await prisma.komponenPenilaian.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KomponenPenilaianFindFirstOrThrowArgs>(args?: SelectSubset<T, KomponenPenilaianFindFirstOrThrowArgs<ExtArgs>>): Prisma__KomponenPenilaianClient<$Result.GetResult<Prisma.$KomponenPenilaianPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KomponenPenilaians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KomponenPenilaianFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KomponenPenilaians
     * const komponenPenilaians = await prisma.komponenPenilaian.findMany()
     * 
     * // Get first 10 KomponenPenilaians
     * const komponenPenilaians = await prisma.komponenPenilaian.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const komponenPenilaianWithIdOnly = await prisma.komponenPenilaian.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KomponenPenilaianFindManyArgs>(args?: SelectSubset<T, KomponenPenilaianFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KomponenPenilaianPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KomponenPenilaian.
     * @param {KomponenPenilaianCreateArgs} args - Arguments to create a KomponenPenilaian.
     * @example
     * // Create one KomponenPenilaian
     * const KomponenPenilaian = await prisma.komponenPenilaian.create({
     *   data: {
     *     // ... data to create a KomponenPenilaian
     *   }
     * })
     * 
     */
    create<T extends KomponenPenilaianCreateArgs>(args: SelectSubset<T, KomponenPenilaianCreateArgs<ExtArgs>>): Prisma__KomponenPenilaianClient<$Result.GetResult<Prisma.$KomponenPenilaianPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KomponenPenilaians.
     * @param {KomponenPenilaianCreateManyArgs} args - Arguments to create many KomponenPenilaians.
     * @example
     * // Create many KomponenPenilaians
     * const komponenPenilaian = await prisma.komponenPenilaian.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KomponenPenilaianCreateManyArgs>(args?: SelectSubset<T, KomponenPenilaianCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KomponenPenilaians and returns the data saved in the database.
     * @param {KomponenPenilaianCreateManyAndReturnArgs} args - Arguments to create many KomponenPenilaians.
     * @example
     * // Create many KomponenPenilaians
     * const komponenPenilaian = await prisma.komponenPenilaian.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KomponenPenilaians and only return the `id`
     * const komponenPenilaianWithIdOnly = await prisma.komponenPenilaian.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KomponenPenilaianCreateManyAndReturnArgs>(args?: SelectSubset<T, KomponenPenilaianCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KomponenPenilaianPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KomponenPenilaian.
     * @param {KomponenPenilaianDeleteArgs} args - Arguments to delete one KomponenPenilaian.
     * @example
     * // Delete one KomponenPenilaian
     * const KomponenPenilaian = await prisma.komponenPenilaian.delete({
     *   where: {
     *     // ... filter to delete one KomponenPenilaian
     *   }
     * })
     * 
     */
    delete<T extends KomponenPenilaianDeleteArgs>(args: SelectSubset<T, KomponenPenilaianDeleteArgs<ExtArgs>>): Prisma__KomponenPenilaianClient<$Result.GetResult<Prisma.$KomponenPenilaianPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KomponenPenilaian.
     * @param {KomponenPenilaianUpdateArgs} args - Arguments to update one KomponenPenilaian.
     * @example
     * // Update one KomponenPenilaian
     * const komponenPenilaian = await prisma.komponenPenilaian.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KomponenPenilaianUpdateArgs>(args: SelectSubset<T, KomponenPenilaianUpdateArgs<ExtArgs>>): Prisma__KomponenPenilaianClient<$Result.GetResult<Prisma.$KomponenPenilaianPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KomponenPenilaians.
     * @param {KomponenPenilaianDeleteManyArgs} args - Arguments to filter KomponenPenilaians to delete.
     * @example
     * // Delete a few KomponenPenilaians
     * const { count } = await prisma.komponenPenilaian.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KomponenPenilaianDeleteManyArgs>(args?: SelectSubset<T, KomponenPenilaianDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KomponenPenilaians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KomponenPenilaianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KomponenPenilaians
     * const komponenPenilaian = await prisma.komponenPenilaian.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KomponenPenilaianUpdateManyArgs>(args: SelectSubset<T, KomponenPenilaianUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KomponenPenilaians and returns the data updated in the database.
     * @param {KomponenPenilaianUpdateManyAndReturnArgs} args - Arguments to update many KomponenPenilaians.
     * @example
     * // Update many KomponenPenilaians
     * const komponenPenilaian = await prisma.komponenPenilaian.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KomponenPenilaians and only return the `id`
     * const komponenPenilaianWithIdOnly = await prisma.komponenPenilaian.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KomponenPenilaianUpdateManyAndReturnArgs>(args: SelectSubset<T, KomponenPenilaianUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KomponenPenilaianPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KomponenPenilaian.
     * @param {KomponenPenilaianUpsertArgs} args - Arguments to update or create a KomponenPenilaian.
     * @example
     * // Update or create a KomponenPenilaian
     * const komponenPenilaian = await prisma.komponenPenilaian.upsert({
     *   create: {
     *     // ... data to create a KomponenPenilaian
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KomponenPenilaian we want to update
     *   }
     * })
     */
    upsert<T extends KomponenPenilaianUpsertArgs>(args: SelectSubset<T, KomponenPenilaianUpsertArgs<ExtArgs>>): Prisma__KomponenPenilaianClient<$Result.GetResult<Prisma.$KomponenPenilaianPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KomponenPenilaians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KomponenPenilaianCountArgs} args - Arguments to filter KomponenPenilaians to count.
     * @example
     * // Count the number of KomponenPenilaians
     * const count = await prisma.komponenPenilaian.count({
     *   where: {
     *     // ... the filter for the KomponenPenilaians we want to count
     *   }
     * })
    **/
    count<T extends KomponenPenilaianCountArgs>(
      args?: Subset<T, KomponenPenilaianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KomponenPenilaianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KomponenPenilaian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KomponenPenilaianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KomponenPenilaianAggregateArgs>(args: Subset<T, KomponenPenilaianAggregateArgs>): Prisma.PrismaPromise<GetKomponenPenilaianAggregateType<T>>

    /**
     * Group by KomponenPenilaian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KomponenPenilaianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KomponenPenilaianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KomponenPenilaianGroupByArgs['orderBy'] }
        : { orderBy?: KomponenPenilaianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KomponenPenilaianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKomponenPenilaianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KomponenPenilaian model
   */
  readonly fields: KomponenPenilaianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KomponenPenilaian.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KomponenPenilaianClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cpmk<T extends CPMKDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CPMKDefaultArgs<ExtArgs>>): Prisma__CPMKClient<$Result.GetResult<Prisma.$CPMKPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nilai<T extends KomponenPenilaian$nilaiArgs<ExtArgs> = {}>(args?: Subset<T, KomponenPenilaian$nilaiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NilaiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KomponenPenilaian model
   */
  interface KomponenPenilaianFieldRefs {
    readonly id: FieldRef<"KomponenPenilaian", 'Int'>
    readonly nama: FieldRef<"KomponenPenilaian", 'String'>
    readonly bobot: FieldRef<"KomponenPenilaian", 'Float'>
    readonly createdAt: FieldRef<"KomponenPenilaian", 'DateTime'>
    readonly updatedAt: FieldRef<"KomponenPenilaian", 'DateTime'>
    readonly cpmk_id: FieldRef<"KomponenPenilaian", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * KomponenPenilaian findUnique
   */
  export type KomponenPenilaianFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomponenPenilaian
     */
    select?: KomponenPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomponenPenilaian
     */
    omit?: KomponenPenilaianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomponenPenilaianInclude<ExtArgs> | null
    /**
     * Filter, which KomponenPenilaian to fetch.
     */
    where: KomponenPenilaianWhereUniqueInput
  }

  /**
   * KomponenPenilaian findUniqueOrThrow
   */
  export type KomponenPenilaianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomponenPenilaian
     */
    select?: KomponenPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomponenPenilaian
     */
    omit?: KomponenPenilaianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomponenPenilaianInclude<ExtArgs> | null
    /**
     * Filter, which KomponenPenilaian to fetch.
     */
    where: KomponenPenilaianWhereUniqueInput
  }

  /**
   * KomponenPenilaian findFirst
   */
  export type KomponenPenilaianFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomponenPenilaian
     */
    select?: KomponenPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomponenPenilaian
     */
    omit?: KomponenPenilaianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomponenPenilaianInclude<ExtArgs> | null
    /**
     * Filter, which KomponenPenilaian to fetch.
     */
    where?: KomponenPenilaianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KomponenPenilaians to fetch.
     */
    orderBy?: KomponenPenilaianOrderByWithRelationInput | KomponenPenilaianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KomponenPenilaians.
     */
    cursor?: KomponenPenilaianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KomponenPenilaians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KomponenPenilaians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KomponenPenilaians.
     */
    distinct?: KomponenPenilaianScalarFieldEnum | KomponenPenilaianScalarFieldEnum[]
  }

  /**
   * KomponenPenilaian findFirstOrThrow
   */
  export type KomponenPenilaianFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomponenPenilaian
     */
    select?: KomponenPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomponenPenilaian
     */
    omit?: KomponenPenilaianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomponenPenilaianInclude<ExtArgs> | null
    /**
     * Filter, which KomponenPenilaian to fetch.
     */
    where?: KomponenPenilaianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KomponenPenilaians to fetch.
     */
    orderBy?: KomponenPenilaianOrderByWithRelationInput | KomponenPenilaianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KomponenPenilaians.
     */
    cursor?: KomponenPenilaianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KomponenPenilaians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KomponenPenilaians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KomponenPenilaians.
     */
    distinct?: KomponenPenilaianScalarFieldEnum | KomponenPenilaianScalarFieldEnum[]
  }

  /**
   * KomponenPenilaian findMany
   */
  export type KomponenPenilaianFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomponenPenilaian
     */
    select?: KomponenPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomponenPenilaian
     */
    omit?: KomponenPenilaianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomponenPenilaianInclude<ExtArgs> | null
    /**
     * Filter, which KomponenPenilaians to fetch.
     */
    where?: KomponenPenilaianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KomponenPenilaians to fetch.
     */
    orderBy?: KomponenPenilaianOrderByWithRelationInput | KomponenPenilaianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KomponenPenilaians.
     */
    cursor?: KomponenPenilaianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KomponenPenilaians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KomponenPenilaians.
     */
    skip?: number
    distinct?: KomponenPenilaianScalarFieldEnum | KomponenPenilaianScalarFieldEnum[]
  }

  /**
   * KomponenPenilaian create
   */
  export type KomponenPenilaianCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomponenPenilaian
     */
    select?: KomponenPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomponenPenilaian
     */
    omit?: KomponenPenilaianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomponenPenilaianInclude<ExtArgs> | null
    /**
     * The data needed to create a KomponenPenilaian.
     */
    data: XOR<KomponenPenilaianCreateInput, KomponenPenilaianUncheckedCreateInput>
  }

  /**
   * KomponenPenilaian createMany
   */
  export type KomponenPenilaianCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KomponenPenilaians.
     */
    data: KomponenPenilaianCreateManyInput | KomponenPenilaianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KomponenPenilaian createManyAndReturn
   */
  export type KomponenPenilaianCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomponenPenilaian
     */
    select?: KomponenPenilaianSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KomponenPenilaian
     */
    omit?: KomponenPenilaianOmit<ExtArgs> | null
    /**
     * The data used to create many KomponenPenilaians.
     */
    data: KomponenPenilaianCreateManyInput | KomponenPenilaianCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomponenPenilaianIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KomponenPenilaian update
   */
  export type KomponenPenilaianUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomponenPenilaian
     */
    select?: KomponenPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomponenPenilaian
     */
    omit?: KomponenPenilaianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomponenPenilaianInclude<ExtArgs> | null
    /**
     * The data needed to update a KomponenPenilaian.
     */
    data: XOR<KomponenPenilaianUpdateInput, KomponenPenilaianUncheckedUpdateInput>
    /**
     * Choose, which KomponenPenilaian to update.
     */
    where: KomponenPenilaianWhereUniqueInput
  }

  /**
   * KomponenPenilaian updateMany
   */
  export type KomponenPenilaianUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KomponenPenilaians.
     */
    data: XOR<KomponenPenilaianUpdateManyMutationInput, KomponenPenilaianUncheckedUpdateManyInput>
    /**
     * Filter which KomponenPenilaians to update
     */
    where?: KomponenPenilaianWhereInput
    /**
     * Limit how many KomponenPenilaians to update.
     */
    limit?: number
  }

  /**
   * KomponenPenilaian updateManyAndReturn
   */
  export type KomponenPenilaianUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomponenPenilaian
     */
    select?: KomponenPenilaianSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KomponenPenilaian
     */
    omit?: KomponenPenilaianOmit<ExtArgs> | null
    /**
     * The data used to update KomponenPenilaians.
     */
    data: XOR<KomponenPenilaianUpdateManyMutationInput, KomponenPenilaianUncheckedUpdateManyInput>
    /**
     * Filter which KomponenPenilaians to update
     */
    where?: KomponenPenilaianWhereInput
    /**
     * Limit how many KomponenPenilaians to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomponenPenilaianIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KomponenPenilaian upsert
   */
  export type KomponenPenilaianUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomponenPenilaian
     */
    select?: KomponenPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomponenPenilaian
     */
    omit?: KomponenPenilaianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomponenPenilaianInclude<ExtArgs> | null
    /**
     * The filter to search for the KomponenPenilaian to update in case it exists.
     */
    where: KomponenPenilaianWhereUniqueInput
    /**
     * In case the KomponenPenilaian found by the `where` argument doesn't exist, create a new KomponenPenilaian with this data.
     */
    create: XOR<KomponenPenilaianCreateInput, KomponenPenilaianUncheckedCreateInput>
    /**
     * In case the KomponenPenilaian was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KomponenPenilaianUpdateInput, KomponenPenilaianUncheckedUpdateInput>
  }

  /**
   * KomponenPenilaian delete
   */
  export type KomponenPenilaianDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomponenPenilaian
     */
    select?: KomponenPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomponenPenilaian
     */
    omit?: KomponenPenilaianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomponenPenilaianInclude<ExtArgs> | null
    /**
     * Filter which KomponenPenilaian to delete.
     */
    where: KomponenPenilaianWhereUniqueInput
  }

  /**
   * KomponenPenilaian deleteMany
   */
  export type KomponenPenilaianDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KomponenPenilaians to delete
     */
    where?: KomponenPenilaianWhereInput
    /**
     * Limit how many KomponenPenilaians to delete.
     */
    limit?: number
  }

  /**
   * KomponenPenilaian.nilai
   */
  export type KomponenPenilaian$nilaiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nilai
     */
    select?: NilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nilai
     */
    omit?: NilaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NilaiInclude<ExtArgs> | null
    where?: NilaiWhereInput
    orderBy?: NilaiOrderByWithRelationInput | NilaiOrderByWithRelationInput[]
    cursor?: NilaiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NilaiScalarFieldEnum | NilaiScalarFieldEnum[]
  }

  /**
   * KomponenPenilaian without action
   */
  export type KomponenPenilaianDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomponenPenilaian
     */
    select?: KomponenPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomponenPenilaian
     */
    omit?: KomponenPenilaianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomponenPenilaianInclude<ExtArgs> | null
  }


  /**
   * Model Nilai
   */

  export type AggregateNilai = {
    _count: NilaiCountAggregateOutputType | null
    _avg: NilaiAvgAggregateOutputType | null
    _sum: NilaiSumAggregateOutputType | null
    _min: NilaiMinAggregateOutputType | null
    _max: NilaiMaxAggregateOutputType | null
  }

  export type NilaiAvgAggregateOutputType = {
    id: number | null
    nilai_angka: number | null
    peserta_kelas_id: number | null
    komponen_penilaian_id: number | null
  }

  export type NilaiSumAggregateOutputType = {
    id: number | null
    nilai_angka: number | null
    peserta_kelas_id: number | null
    komponen_penilaian_id: number | null
  }

  export type NilaiMinAggregateOutputType = {
    id: number | null
    nilai_angka: number | null
    createdAt: Date | null
    updatedAt: Date | null
    peserta_kelas_id: number | null
    komponen_penilaian_id: number | null
  }

  export type NilaiMaxAggregateOutputType = {
    id: number | null
    nilai_angka: number | null
    createdAt: Date | null
    updatedAt: Date | null
    peserta_kelas_id: number | null
    komponen_penilaian_id: number | null
  }

  export type NilaiCountAggregateOutputType = {
    id: number
    nilai_angka: number
    createdAt: number
    updatedAt: number
    peserta_kelas_id: number
    komponen_penilaian_id: number
    _all: number
  }


  export type NilaiAvgAggregateInputType = {
    id?: true
    nilai_angka?: true
    peserta_kelas_id?: true
    komponen_penilaian_id?: true
  }

  export type NilaiSumAggregateInputType = {
    id?: true
    nilai_angka?: true
    peserta_kelas_id?: true
    komponen_penilaian_id?: true
  }

  export type NilaiMinAggregateInputType = {
    id?: true
    nilai_angka?: true
    createdAt?: true
    updatedAt?: true
    peserta_kelas_id?: true
    komponen_penilaian_id?: true
  }

  export type NilaiMaxAggregateInputType = {
    id?: true
    nilai_angka?: true
    createdAt?: true
    updatedAt?: true
    peserta_kelas_id?: true
    komponen_penilaian_id?: true
  }

  export type NilaiCountAggregateInputType = {
    id?: true
    nilai_angka?: true
    createdAt?: true
    updatedAt?: true
    peserta_kelas_id?: true
    komponen_penilaian_id?: true
    _all?: true
  }

  export type NilaiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nilai to aggregate.
     */
    where?: NilaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nilais to fetch.
     */
    orderBy?: NilaiOrderByWithRelationInput | NilaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NilaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nilais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nilais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Nilais
    **/
    _count?: true | NilaiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NilaiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NilaiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NilaiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NilaiMaxAggregateInputType
  }

  export type GetNilaiAggregateType<T extends NilaiAggregateArgs> = {
        [P in keyof T & keyof AggregateNilai]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNilai[P]>
      : GetScalarType<T[P], AggregateNilai[P]>
  }




  export type NilaiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NilaiWhereInput
    orderBy?: NilaiOrderByWithAggregationInput | NilaiOrderByWithAggregationInput[]
    by: NilaiScalarFieldEnum[] | NilaiScalarFieldEnum
    having?: NilaiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NilaiCountAggregateInputType | true
    _avg?: NilaiAvgAggregateInputType
    _sum?: NilaiSumAggregateInputType
    _min?: NilaiMinAggregateInputType
    _max?: NilaiMaxAggregateInputType
  }

  export type NilaiGroupByOutputType = {
    id: number
    nilai_angka: number
    createdAt: Date
    updatedAt: Date
    peserta_kelas_id: number
    komponen_penilaian_id: number
    _count: NilaiCountAggregateOutputType | null
    _avg: NilaiAvgAggregateOutputType | null
    _sum: NilaiSumAggregateOutputType | null
    _min: NilaiMinAggregateOutputType | null
    _max: NilaiMaxAggregateOutputType | null
  }

  type GetNilaiGroupByPayload<T extends NilaiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NilaiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NilaiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NilaiGroupByOutputType[P]>
            : GetScalarType<T[P], NilaiGroupByOutputType[P]>
        }
      >
    >


  export type NilaiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nilai_angka?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    peserta_kelas_id?: boolean
    komponen_penilaian_id?: boolean
    pesertaKelas?: boolean | PesertaKelasDefaultArgs<ExtArgs>
    komponenPenilaian?: boolean | KomponenPenilaianDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nilai"]>

  export type NilaiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nilai_angka?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    peserta_kelas_id?: boolean
    komponen_penilaian_id?: boolean
    pesertaKelas?: boolean | PesertaKelasDefaultArgs<ExtArgs>
    komponenPenilaian?: boolean | KomponenPenilaianDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nilai"]>

  export type NilaiSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nilai_angka?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    peserta_kelas_id?: boolean
    komponen_penilaian_id?: boolean
    pesertaKelas?: boolean | PesertaKelasDefaultArgs<ExtArgs>
    komponenPenilaian?: boolean | KomponenPenilaianDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nilai"]>

  export type NilaiSelectScalar = {
    id?: boolean
    nilai_angka?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    peserta_kelas_id?: boolean
    komponen_penilaian_id?: boolean
  }

  export type NilaiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nilai_angka" | "createdAt" | "updatedAt" | "peserta_kelas_id" | "komponen_penilaian_id", ExtArgs["result"]["nilai"]>
  export type NilaiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pesertaKelas?: boolean | PesertaKelasDefaultArgs<ExtArgs>
    komponenPenilaian?: boolean | KomponenPenilaianDefaultArgs<ExtArgs>
  }
  export type NilaiIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pesertaKelas?: boolean | PesertaKelasDefaultArgs<ExtArgs>
    komponenPenilaian?: boolean | KomponenPenilaianDefaultArgs<ExtArgs>
  }
  export type NilaiIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pesertaKelas?: boolean | PesertaKelasDefaultArgs<ExtArgs>
    komponenPenilaian?: boolean | KomponenPenilaianDefaultArgs<ExtArgs>
  }

  export type $NilaiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Nilai"
    objects: {
      pesertaKelas: Prisma.$PesertaKelasPayload<ExtArgs>
      komponenPenilaian: Prisma.$KomponenPenilaianPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nilai_angka: number
      createdAt: Date
      updatedAt: Date
      peserta_kelas_id: number
      komponen_penilaian_id: number
    }, ExtArgs["result"]["nilai"]>
    composites: {}
  }

  type NilaiGetPayload<S extends boolean | null | undefined | NilaiDefaultArgs> = $Result.GetResult<Prisma.$NilaiPayload, S>

  type NilaiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NilaiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NilaiCountAggregateInputType | true
    }

  export interface NilaiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Nilai'], meta: { name: 'Nilai' } }
    /**
     * Find zero or one Nilai that matches the filter.
     * @param {NilaiFindUniqueArgs} args - Arguments to find a Nilai
     * @example
     * // Get one Nilai
     * const nilai = await prisma.nilai.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NilaiFindUniqueArgs>(args: SelectSubset<T, NilaiFindUniqueArgs<ExtArgs>>): Prisma__NilaiClient<$Result.GetResult<Prisma.$NilaiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Nilai that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NilaiFindUniqueOrThrowArgs} args - Arguments to find a Nilai
     * @example
     * // Get one Nilai
     * const nilai = await prisma.nilai.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NilaiFindUniqueOrThrowArgs>(args: SelectSubset<T, NilaiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NilaiClient<$Result.GetResult<Prisma.$NilaiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Nilai that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NilaiFindFirstArgs} args - Arguments to find a Nilai
     * @example
     * // Get one Nilai
     * const nilai = await prisma.nilai.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NilaiFindFirstArgs>(args?: SelectSubset<T, NilaiFindFirstArgs<ExtArgs>>): Prisma__NilaiClient<$Result.GetResult<Prisma.$NilaiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Nilai that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NilaiFindFirstOrThrowArgs} args - Arguments to find a Nilai
     * @example
     * // Get one Nilai
     * const nilai = await prisma.nilai.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NilaiFindFirstOrThrowArgs>(args?: SelectSubset<T, NilaiFindFirstOrThrowArgs<ExtArgs>>): Prisma__NilaiClient<$Result.GetResult<Prisma.$NilaiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Nilais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NilaiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nilais
     * const nilais = await prisma.nilai.findMany()
     * 
     * // Get first 10 Nilais
     * const nilais = await prisma.nilai.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nilaiWithIdOnly = await prisma.nilai.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NilaiFindManyArgs>(args?: SelectSubset<T, NilaiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NilaiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Nilai.
     * @param {NilaiCreateArgs} args - Arguments to create a Nilai.
     * @example
     * // Create one Nilai
     * const Nilai = await prisma.nilai.create({
     *   data: {
     *     // ... data to create a Nilai
     *   }
     * })
     * 
     */
    create<T extends NilaiCreateArgs>(args: SelectSubset<T, NilaiCreateArgs<ExtArgs>>): Prisma__NilaiClient<$Result.GetResult<Prisma.$NilaiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Nilais.
     * @param {NilaiCreateManyArgs} args - Arguments to create many Nilais.
     * @example
     * // Create many Nilais
     * const nilai = await prisma.nilai.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NilaiCreateManyArgs>(args?: SelectSubset<T, NilaiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Nilais and returns the data saved in the database.
     * @param {NilaiCreateManyAndReturnArgs} args - Arguments to create many Nilais.
     * @example
     * // Create many Nilais
     * const nilai = await prisma.nilai.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Nilais and only return the `id`
     * const nilaiWithIdOnly = await prisma.nilai.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NilaiCreateManyAndReturnArgs>(args?: SelectSubset<T, NilaiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NilaiPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Nilai.
     * @param {NilaiDeleteArgs} args - Arguments to delete one Nilai.
     * @example
     * // Delete one Nilai
     * const Nilai = await prisma.nilai.delete({
     *   where: {
     *     // ... filter to delete one Nilai
     *   }
     * })
     * 
     */
    delete<T extends NilaiDeleteArgs>(args: SelectSubset<T, NilaiDeleteArgs<ExtArgs>>): Prisma__NilaiClient<$Result.GetResult<Prisma.$NilaiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Nilai.
     * @param {NilaiUpdateArgs} args - Arguments to update one Nilai.
     * @example
     * // Update one Nilai
     * const nilai = await prisma.nilai.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NilaiUpdateArgs>(args: SelectSubset<T, NilaiUpdateArgs<ExtArgs>>): Prisma__NilaiClient<$Result.GetResult<Prisma.$NilaiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Nilais.
     * @param {NilaiDeleteManyArgs} args - Arguments to filter Nilais to delete.
     * @example
     * // Delete a few Nilais
     * const { count } = await prisma.nilai.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NilaiDeleteManyArgs>(args?: SelectSubset<T, NilaiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nilais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NilaiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nilais
     * const nilai = await prisma.nilai.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NilaiUpdateManyArgs>(args: SelectSubset<T, NilaiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nilais and returns the data updated in the database.
     * @param {NilaiUpdateManyAndReturnArgs} args - Arguments to update many Nilais.
     * @example
     * // Update many Nilais
     * const nilai = await prisma.nilai.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Nilais and only return the `id`
     * const nilaiWithIdOnly = await prisma.nilai.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NilaiUpdateManyAndReturnArgs>(args: SelectSubset<T, NilaiUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NilaiPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Nilai.
     * @param {NilaiUpsertArgs} args - Arguments to update or create a Nilai.
     * @example
     * // Update or create a Nilai
     * const nilai = await prisma.nilai.upsert({
     *   create: {
     *     // ... data to create a Nilai
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nilai we want to update
     *   }
     * })
     */
    upsert<T extends NilaiUpsertArgs>(args: SelectSubset<T, NilaiUpsertArgs<ExtArgs>>): Prisma__NilaiClient<$Result.GetResult<Prisma.$NilaiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Nilais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NilaiCountArgs} args - Arguments to filter Nilais to count.
     * @example
     * // Count the number of Nilais
     * const count = await prisma.nilai.count({
     *   where: {
     *     // ... the filter for the Nilais we want to count
     *   }
     * })
    **/
    count<T extends NilaiCountArgs>(
      args?: Subset<T, NilaiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NilaiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Nilai.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NilaiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NilaiAggregateArgs>(args: Subset<T, NilaiAggregateArgs>): Prisma.PrismaPromise<GetNilaiAggregateType<T>>

    /**
     * Group by Nilai.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NilaiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NilaiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NilaiGroupByArgs['orderBy'] }
        : { orderBy?: NilaiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NilaiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNilaiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Nilai model
   */
  readonly fields: NilaiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Nilai.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NilaiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pesertaKelas<T extends PesertaKelasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PesertaKelasDefaultArgs<ExtArgs>>): Prisma__PesertaKelasClient<$Result.GetResult<Prisma.$PesertaKelasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    komponenPenilaian<T extends KomponenPenilaianDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KomponenPenilaianDefaultArgs<ExtArgs>>): Prisma__KomponenPenilaianClient<$Result.GetResult<Prisma.$KomponenPenilaianPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Nilai model
   */
  interface NilaiFieldRefs {
    readonly id: FieldRef<"Nilai", 'Int'>
    readonly nilai_angka: FieldRef<"Nilai", 'Float'>
    readonly createdAt: FieldRef<"Nilai", 'DateTime'>
    readonly updatedAt: FieldRef<"Nilai", 'DateTime'>
    readonly peserta_kelas_id: FieldRef<"Nilai", 'Int'>
    readonly komponen_penilaian_id: FieldRef<"Nilai", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Nilai findUnique
   */
  export type NilaiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nilai
     */
    select?: NilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nilai
     */
    omit?: NilaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NilaiInclude<ExtArgs> | null
    /**
     * Filter, which Nilai to fetch.
     */
    where: NilaiWhereUniqueInput
  }

  /**
   * Nilai findUniqueOrThrow
   */
  export type NilaiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nilai
     */
    select?: NilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nilai
     */
    omit?: NilaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NilaiInclude<ExtArgs> | null
    /**
     * Filter, which Nilai to fetch.
     */
    where: NilaiWhereUniqueInput
  }

  /**
   * Nilai findFirst
   */
  export type NilaiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nilai
     */
    select?: NilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nilai
     */
    omit?: NilaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NilaiInclude<ExtArgs> | null
    /**
     * Filter, which Nilai to fetch.
     */
    where?: NilaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nilais to fetch.
     */
    orderBy?: NilaiOrderByWithRelationInput | NilaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nilais.
     */
    cursor?: NilaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nilais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nilais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nilais.
     */
    distinct?: NilaiScalarFieldEnum | NilaiScalarFieldEnum[]
  }

  /**
   * Nilai findFirstOrThrow
   */
  export type NilaiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nilai
     */
    select?: NilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nilai
     */
    omit?: NilaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NilaiInclude<ExtArgs> | null
    /**
     * Filter, which Nilai to fetch.
     */
    where?: NilaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nilais to fetch.
     */
    orderBy?: NilaiOrderByWithRelationInput | NilaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nilais.
     */
    cursor?: NilaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nilais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nilais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nilais.
     */
    distinct?: NilaiScalarFieldEnum | NilaiScalarFieldEnum[]
  }

  /**
   * Nilai findMany
   */
  export type NilaiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nilai
     */
    select?: NilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nilai
     */
    omit?: NilaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NilaiInclude<ExtArgs> | null
    /**
     * Filter, which Nilais to fetch.
     */
    where?: NilaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nilais to fetch.
     */
    orderBy?: NilaiOrderByWithRelationInput | NilaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Nilais.
     */
    cursor?: NilaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nilais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nilais.
     */
    skip?: number
    distinct?: NilaiScalarFieldEnum | NilaiScalarFieldEnum[]
  }

  /**
   * Nilai create
   */
  export type NilaiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nilai
     */
    select?: NilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nilai
     */
    omit?: NilaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NilaiInclude<ExtArgs> | null
    /**
     * The data needed to create a Nilai.
     */
    data: XOR<NilaiCreateInput, NilaiUncheckedCreateInput>
  }

  /**
   * Nilai createMany
   */
  export type NilaiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Nilais.
     */
    data: NilaiCreateManyInput | NilaiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Nilai createManyAndReturn
   */
  export type NilaiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nilai
     */
    select?: NilaiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Nilai
     */
    omit?: NilaiOmit<ExtArgs> | null
    /**
     * The data used to create many Nilais.
     */
    data: NilaiCreateManyInput | NilaiCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NilaiIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Nilai update
   */
  export type NilaiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nilai
     */
    select?: NilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nilai
     */
    omit?: NilaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NilaiInclude<ExtArgs> | null
    /**
     * The data needed to update a Nilai.
     */
    data: XOR<NilaiUpdateInput, NilaiUncheckedUpdateInput>
    /**
     * Choose, which Nilai to update.
     */
    where: NilaiWhereUniqueInput
  }

  /**
   * Nilai updateMany
   */
  export type NilaiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Nilais.
     */
    data: XOR<NilaiUpdateManyMutationInput, NilaiUncheckedUpdateManyInput>
    /**
     * Filter which Nilais to update
     */
    where?: NilaiWhereInput
    /**
     * Limit how many Nilais to update.
     */
    limit?: number
  }

  /**
   * Nilai updateManyAndReturn
   */
  export type NilaiUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nilai
     */
    select?: NilaiSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Nilai
     */
    omit?: NilaiOmit<ExtArgs> | null
    /**
     * The data used to update Nilais.
     */
    data: XOR<NilaiUpdateManyMutationInput, NilaiUncheckedUpdateManyInput>
    /**
     * Filter which Nilais to update
     */
    where?: NilaiWhereInput
    /**
     * Limit how many Nilais to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NilaiIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Nilai upsert
   */
  export type NilaiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nilai
     */
    select?: NilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nilai
     */
    omit?: NilaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NilaiInclude<ExtArgs> | null
    /**
     * The filter to search for the Nilai to update in case it exists.
     */
    where: NilaiWhereUniqueInput
    /**
     * In case the Nilai found by the `where` argument doesn't exist, create a new Nilai with this data.
     */
    create: XOR<NilaiCreateInput, NilaiUncheckedCreateInput>
    /**
     * In case the Nilai was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NilaiUpdateInput, NilaiUncheckedUpdateInput>
  }

  /**
   * Nilai delete
   */
  export type NilaiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nilai
     */
    select?: NilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nilai
     */
    omit?: NilaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NilaiInclude<ExtArgs> | null
    /**
     * Filter which Nilai to delete.
     */
    where: NilaiWhereUniqueInput
  }

  /**
   * Nilai deleteMany
   */
  export type NilaiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nilais to delete
     */
    where?: NilaiWhereInput
    /**
     * Limit how many Nilais to delete.
     */
    limit?: number
  }

  /**
   * Nilai without action
   */
  export type NilaiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nilai
     */
    select?: NilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nilai
     */
    omit?: NilaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NilaiInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProgramStudiScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    jenjang: 'jenjang',
    total_sks_lulus: 'total_sks_lulus'
  };

  export type ProgramStudiScalarFieldEnum = (typeof ProgramStudiScalarFieldEnum)[keyof typeof ProgramStudiScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password_hash: 'password_hash',
    nama: 'nama',
    role: 'role',
    program_studi_id: 'program_studi_id'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const KurikulumScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    tahun: 'tahun',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    program_studi_id: 'program_studi_id'
  };

  export type KurikulumScalarFieldEnum = (typeof KurikulumScalarFieldEnum)[keyof typeof KurikulumScalarFieldEnum]


  export const MataKuliahScalarFieldEnum: {
    id: 'id',
    kode_mk: 'kode_mk',
    nama: 'nama',
    sks: 'sks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    kurikulum_id: 'kurikulum_id'
  };

  export type MataKuliahScalarFieldEnum = (typeof MataKuliahScalarFieldEnum)[keyof typeof MataKuliahScalarFieldEnum]


  export const PIGroupScalarFieldEnum: {
    id: 'id',
    kode_grup: 'kode_grup',
    nama_grup: 'nama_grup',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    kurikulum_id: 'kurikulum_id'
  };

  export type PIGroupScalarFieldEnum = (typeof PIGroupScalarFieldEnum)[keyof typeof PIGroupScalarFieldEnum]


  export const PerformanceIndicatorScalarFieldEnum: {
    id: 'id',
    kode_pi: 'kode_pi',
    deskripsi: 'deskripsi',
    is_locked: 'is_locked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    pi_group_id: 'pi_group_id'
  };

  export type PerformanceIndicatorScalarFieldEnum = (typeof PerformanceIndicatorScalarFieldEnum)[keyof typeof PerformanceIndicatorScalarFieldEnum]


  export const CPLScalarFieldEnum: {
    id: 'id',
    kode_cpl: 'kode_cpl',
    deskripsi: 'deskripsi',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    kurikulum_id: 'kurikulum_id',
    pi_group_id: 'pi_group_id'
  };

  export type CPLScalarFieldEnum = (typeof CPLScalarFieldEnum)[keyof typeof CPLScalarFieldEnum]


  export const TahunAjaranScalarFieldEnum: {
    id: 'id',
    tahun: 'tahun',
    semester: 'semester'
  };

  export type TahunAjaranScalarFieldEnum = (typeof TahunAjaranScalarFieldEnum)[keyof typeof TahunAjaranScalarFieldEnum]


  export const KelasScalarFieldEnum: {
    id: 'id',
    nama_kelas: 'nama_kelas',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    mata_kuliah_id: 'mata_kuliah_id',
    tahun_ajaran_id: 'tahun_ajaran_id'
  };

  export type KelasScalarFieldEnum = (typeof KelasScalarFieldEnum)[keyof typeof KelasScalarFieldEnum]


  export const DosenPengampuScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    kelas_id: 'kelas_id',
    dosen_id: 'dosen_id'
  };

  export type DosenPengampuScalarFieldEnum = (typeof DosenPengampuScalarFieldEnum)[keyof typeof DosenPengampuScalarFieldEnum]


  export const PesertaKelasScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    kelas_id: 'kelas_id',
    mahasiswa_id: 'mahasiswa_id'
  };

  export type PesertaKelasScalarFieldEnum = (typeof PesertaKelasScalarFieldEnum)[keyof typeof PesertaKelasScalarFieldEnum]


  export const RPSScalarFieldEnum: {
    id: 'id',
    file_path: 'file_path',
    is_locked: 'is_locked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    kelas_id: 'kelas_id'
  };

  export type RPSScalarFieldEnum = (typeof RPSScalarFieldEnum)[keyof typeof RPSScalarFieldEnum]


  export const CPMKScalarFieldEnum: {
    id: 'id',
    kode_cpmk: 'kode_cpmk',
    is_locked: 'is_locked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    kelas_id: 'kelas_id'
  };

  export type CPMKScalarFieldEnum = (typeof CPMKScalarFieldEnum)[keyof typeof CPMKScalarFieldEnum]


  export const CPMK_PI_MapScalarFieldEnum: {
    cpmk_id: 'cpmk_id',
    pi_id: 'pi_id'
  };

  export type CPMK_PI_MapScalarFieldEnum = (typeof CPMK_PI_MapScalarFieldEnum)[keyof typeof CPMK_PI_MapScalarFieldEnum]


  export const KomponenPenilaianScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    bobot: 'bobot',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    cpmk_id: 'cpmk_id'
  };

  export type KomponenPenilaianScalarFieldEnum = (typeof KomponenPenilaianScalarFieldEnum)[keyof typeof KomponenPenilaianScalarFieldEnum]


  export const NilaiScalarFieldEnum: {
    id: 'id',
    nilai_angka: 'nilai_angka',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    peserta_kelas_id: 'peserta_kelas_id',
    komponen_penilaian_id: 'komponen_penilaian_id'
  };

  export type NilaiScalarFieldEnum = (typeof NilaiScalarFieldEnum)[keyof typeof NilaiScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Semester'
   */
  export type EnumSemesterFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Semester'>
    


  /**
   * Reference to a field of type 'Semester[]'
   */
  export type ListEnumSemesterFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Semester[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ProgramStudiWhereInput = {
    AND?: ProgramStudiWhereInput | ProgramStudiWhereInput[]
    OR?: ProgramStudiWhereInput[]
    NOT?: ProgramStudiWhereInput | ProgramStudiWhereInput[]
    id?: IntFilter<"ProgramStudi"> | number
    nama?: StringFilter<"ProgramStudi"> | string
    jenjang?: StringFilter<"ProgramStudi"> | string
    total_sks_lulus?: IntFilter<"ProgramStudi"> | number
    users?: UserListRelationFilter
    kurikulum?: KurikulumListRelationFilter
  }

  export type ProgramStudiOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrder
    jenjang?: SortOrder
    total_sks_lulus?: SortOrder
    users?: UserOrderByRelationAggregateInput
    kurikulum?: KurikulumOrderByRelationAggregateInput
  }

  export type ProgramStudiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nama?: string
    AND?: ProgramStudiWhereInput | ProgramStudiWhereInput[]
    OR?: ProgramStudiWhereInput[]
    NOT?: ProgramStudiWhereInput | ProgramStudiWhereInput[]
    jenjang?: StringFilter<"ProgramStudi"> | string
    total_sks_lulus?: IntFilter<"ProgramStudi"> | number
    users?: UserListRelationFilter
    kurikulum?: KurikulumListRelationFilter
  }, "id" | "nama">

  export type ProgramStudiOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrder
    jenjang?: SortOrder
    total_sks_lulus?: SortOrder
    _count?: ProgramStudiCountOrderByAggregateInput
    _avg?: ProgramStudiAvgOrderByAggregateInput
    _max?: ProgramStudiMaxOrderByAggregateInput
    _min?: ProgramStudiMinOrderByAggregateInput
    _sum?: ProgramStudiSumOrderByAggregateInput
  }

  export type ProgramStudiScalarWhereWithAggregatesInput = {
    AND?: ProgramStudiScalarWhereWithAggregatesInput | ProgramStudiScalarWhereWithAggregatesInput[]
    OR?: ProgramStudiScalarWhereWithAggregatesInput[]
    NOT?: ProgramStudiScalarWhereWithAggregatesInput | ProgramStudiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProgramStudi"> | number
    nama?: StringWithAggregatesFilter<"ProgramStudi"> | string
    jenjang?: StringWithAggregatesFilter<"ProgramStudi"> | string
    total_sks_lulus?: IntWithAggregatesFilter<"ProgramStudi"> | number
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password_hash?: StringFilter<"User"> | string
    nama?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    program_studi_id?: IntFilter<"User"> | number
    programStudi?: XOR<ProgramStudiScalarRelationFilter, ProgramStudiWhereInput>
    dosenPengampu?: DosenPengampuListRelationFilter
    pesertaKelas?: PesertaKelasListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    nama?: SortOrder
    role?: SortOrder
    program_studi_id?: SortOrder
    programStudi?: ProgramStudiOrderByWithRelationInput
    dosenPengampu?: DosenPengampuOrderByRelationAggregateInput
    pesertaKelas?: PesertaKelasOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password_hash?: StringFilter<"User"> | string
    nama?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    program_studi_id?: IntFilter<"User"> | number
    programStudi?: XOR<ProgramStudiScalarRelationFilter, ProgramStudiWhereInput>
    dosenPengampu?: DosenPengampuListRelationFilter
    pesertaKelas?: PesertaKelasListRelationFilter
  }, "id" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    nama?: SortOrder
    role?: SortOrder
    program_studi_id?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password_hash?: StringWithAggregatesFilter<"User"> | string
    nama?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    program_studi_id?: IntWithAggregatesFilter<"User"> | number
  }

  export type KurikulumWhereInput = {
    AND?: KurikulumWhereInput | KurikulumWhereInput[]
    OR?: KurikulumWhereInput[]
    NOT?: KurikulumWhereInput | KurikulumWhereInput[]
    id?: IntFilter<"Kurikulum"> | number
    nama?: StringFilter<"Kurikulum"> | string
    tahun?: IntFilter<"Kurikulum"> | number
    createdAt?: DateTimeFilter<"Kurikulum"> | Date | string
    updatedAt?: DateTimeFilter<"Kurikulum"> | Date | string
    program_studi_id?: IntFilter<"Kurikulum"> | number
    programStudi?: XOR<ProgramStudiScalarRelationFilter, ProgramStudiWhereInput>
    mataKuliah?: MataKuliahListRelationFilter
    cpl?: CPLListRelationFilter
    piGroups?: PIGroupListRelationFilter
  }

  export type KurikulumOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrder
    tahun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    program_studi_id?: SortOrder
    programStudi?: ProgramStudiOrderByWithRelationInput
    mataKuliah?: MataKuliahOrderByRelationAggregateInput
    cpl?: CPLOrderByRelationAggregateInput
    piGroups?: PIGroupOrderByRelationAggregateInput
  }

  export type KurikulumWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: KurikulumWhereInput | KurikulumWhereInput[]
    OR?: KurikulumWhereInput[]
    NOT?: KurikulumWhereInput | KurikulumWhereInput[]
    nama?: StringFilter<"Kurikulum"> | string
    tahun?: IntFilter<"Kurikulum"> | number
    createdAt?: DateTimeFilter<"Kurikulum"> | Date | string
    updatedAt?: DateTimeFilter<"Kurikulum"> | Date | string
    program_studi_id?: IntFilter<"Kurikulum"> | number
    programStudi?: XOR<ProgramStudiScalarRelationFilter, ProgramStudiWhereInput>
    mataKuliah?: MataKuliahListRelationFilter
    cpl?: CPLListRelationFilter
    piGroups?: PIGroupListRelationFilter
  }, "id">

  export type KurikulumOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrder
    tahun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    program_studi_id?: SortOrder
    _count?: KurikulumCountOrderByAggregateInput
    _avg?: KurikulumAvgOrderByAggregateInput
    _max?: KurikulumMaxOrderByAggregateInput
    _min?: KurikulumMinOrderByAggregateInput
    _sum?: KurikulumSumOrderByAggregateInput
  }

  export type KurikulumScalarWhereWithAggregatesInput = {
    AND?: KurikulumScalarWhereWithAggregatesInput | KurikulumScalarWhereWithAggregatesInput[]
    OR?: KurikulumScalarWhereWithAggregatesInput[]
    NOT?: KurikulumScalarWhereWithAggregatesInput | KurikulumScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Kurikulum"> | number
    nama?: StringWithAggregatesFilter<"Kurikulum"> | string
    tahun?: IntWithAggregatesFilter<"Kurikulum"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Kurikulum"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Kurikulum"> | Date | string
    program_studi_id?: IntWithAggregatesFilter<"Kurikulum"> | number
  }

  export type MataKuliahWhereInput = {
    AND?: MataKuliahWhereInput | MataKuliahWhereInput[]
    OR?: MataKuliahWhereInput[]
    NOT?: MataKuliahWhereInput | MataKuliahWhereInput[]
    id?: IntFilter<"MataKuliah"> | number
    kode_mk?: StringFilter<"MataKuliah"> | string
    nama?: StringFilter<"MataKuliah"> | string
    sks?: IntFilter<"MataKuliah"> | number
    createdAt?: DateTimeFilter<"MataKuliah"> | Date | string
    updatedAt?: DateTimeFilter<"MataKuliah"> | Date | string
    kurikulum_id?: IntFilter<"MataKuliah"> | number
    kurikulum?: XOR<KurikulumScalarRelationFilter, KurikulumWhereInput>
    kelas?: KelasListRelationFilter
  }

  export type MataKuliahOrderByWithRelationInput = {
    id?: SortOrder
    kode_mk?: SortOrder
    nama?: SortOrder
    sks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kurikulum_id?: SortOrder
    kurikulum?: KurikulumOrderByWithRelationInput
    kelas?: KelasOrderByRelationAggregateInput
  }

  export type MataKuliahWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    kode_mk?: string
    AND?: MataKuliahWhereInput | MataKuliahWhereInput[]
    OR?: MataKuliahWhereInput[]
    NOT?: MataKuliahWhereInput | MataKuliahWhereInput[]
    nama?: StringFilter<"MataKuliah"> | string
    sks?: IntFilter<"MataKuliah"> | number
    createdAt?: DateTimeFilter<"MataKuliah"> | Date | string
    updatedAt?: DateTimeFilter<"MataKuliah"> | Date | string
    kurikulum_id?: IntFilter<"MataKuliah"> | number
    kurikulum?: XOR<KurikulumScalarRelationFilter, KurikulumWhereInput>
    kelas?: KelasListRelationFilter
  }, "id" | "kode_mk">

  export type MataKuliahOrderByWithAggregationInput = {
    id?: SortOrder
    kode_mk?: SortOrder
    nama?: SortOrder
    sks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kurikulum_id?: SortOrder
    _count?: MataKuliahCountOrderByAggregateInput
    _avg?: MataKuliahAvgOrderByAggregateInput
    _max?: MataKuliahMaxOrderByAggregateInput
    _min?: MataKuliahMinOrderByAggregateInput
    _sum?: MataKuliahSumOrderByAggregateInput
  }

  export type MataKuliahScalarWhereWithAggregatesInput = {
    AND?: MataKuliahScalarWhereWithAggregatesInput | MataKuliahScalarWhereWithAggregatesInput[]
    OR?: MataKuliahScalarWhereWithAggregatesInput[]
    NOT?: MataKuliahScalarWhereWithAggregatesInput | MataKuliahScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MataKuliah"> | number
    kode_mk?: StringWithAggregatesFilter<"MataKuliah"> | string
    nama?: StringWithAggregatesFilter<"MataKuliah"> | string
    sks?: IntWithAggregatesFilter<"MataKuliah"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MataKuliah"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MataKuliah"> | Date | string
    kurikulum_id?: IntWithAggregatesFilter<"MataKuliah"> | number
  }

  export type PIGroupWhereInput = {
    AND?: PIGroupWhereInput | PIGroupWhereInput[]
    OR?: PIGroupWhereInput[]
    NOT?: PIGroupWhereInput | PIGroupWhereInput[]
    id?: IntFilter<"PIGroup"> | number
    kode_grup?: StringFilter<"PIGroup"> | string
    nama_grup?: StringFilter<"PIGroup"> | string
    createdAt?: DateTimeFilter<"PIGroup"> | Date | string
    updatedAt?: DateTimeFilter<"PIGroup"> | Date | string
    kurikulum_id?: IntFilter<"PIGroup"> | number
    kurikulum?: XOR<KurikulumScalarRelationFilter, KurikulumWhereInput>
    indicators?: PerformanceIndicatorListRelationFilter
    cpl?: CPLListRelationFilter
  }

  export type PIGroupOrderByWithRelationInput = {
    id?: SortOrder
    kode_grup?: SortOrder
    nama_grup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kurikulum_id?: SortOrder
    kurikulum?: KurikulumOrderByWithRelationInput
    indicators?: PerformanceIndicatorOrderByRelationAggregateInput
    cpl?: CPLOrderByRelationAggregateInput
  }

  export type PIGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PIGroupWhereInput | PIGroupWhereInput[]
    OR?: PIGroupWhereInput[]
    NOT?: PIGroupWhereInput | PIGroupWhereInput[]
    kode_grup?: StringFilter<"PIGroup"> | string
    nama_grup?: StringFilter<"PIGroup"> | string
    createdAt?: DateTimeFilter<"PIGroup"> | Date | string
    updatedAt?: DateTimeFilter<"PIGroup"> | Date | string
    kurikulum_id?: IntFilter<"PIGroup"> | number
    kurikulum?: XOR<KurikulumScalarRelationFilter, KurikulumWhereInput>
    indicators?: PerformanceIndicatorListRelationFilter
    cpl?: CPLListRelationFilter
  }, "id">

  export type PIGroupOrderByWithAggregationInput = {
    id?: SortOrder
    kode_grup?: SortOrder
    nama_grup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kurikulum_id?: SortOrder
    _count?: PIGroupCountOrderByAggregateInput
    _avg?: PIGroupAvgOrderByAggregateInput
    _max?: PIGroupMaxOrderByAggregateInput
    _min?: PIGroupMinOrderByAggregateInput
    _sum?: PIGroupSumOrderByAggregateInput
  }

  export type PIGroupScalarWhereWithAggregatesInput = {
    AND?: PIGroupScalarWhereWithAggregatesInput | PIGroupScalarWhereWithAggregatesInput[]
    OR?: PIGroupScalarWhereWithAggregatesInput[]
    NOT?: PIGroupScalarWhereWithAggregatesInput | PIGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PIGroup"> | number
    kode_grup?: StringWithAggregatesFilter<"PIGroup"> | string
    nama_grup?: StringWithAggregatesFilter<"PIGroup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PIGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PIGroup"> | Date | string
    kurikulum_id?: IntWithAggregatesFilter<"PIGroup"> | number
  }

  export type PerformanceIndicatorWhereInput = {
    AND?: PerformanceIndicatorWhereInput | PerformanceIndicatorWhereInput[]
    OR?: PerformanceIndicatorWhereInput[]
    NOT?: PerformanceIndicatorWhereInput | PerformanceIndicatorWhereInput[]
    id?: IntFilter<"PerformanceIndicator"> | number
    kode_pi?: StringFilter<"PerformanceIndicator"> | string
    deskripsi?: StringFilter<"PerformanceIndicator"> | string
    is_locked?: BoolFilter<"PerformanceIndicator"> | boolean
    createdAt?: DateTimeFilter<"PerformanceIndicator"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceIndicator"> | Date | string
    pi_group_id?: IntFilter<"PerformanceIndicator"> | number
    piGroup?: XOR<PIGroupScalarRelationFilter, PIGroupWhereInput>
    cpmkMap?: CPMK_PI_MapListRelationFilter
  }

  export type PerformanceIndicatorOrderByWithRelationInput = {
    id?: SortOrder
    kode_pi?: SortOrder
    deskripsi?: SortOrder
    is_locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pi_group_id?: SortOrder
    piGroup?: PIGroupOrderByWithRelationInput
    cpmkMap?: CPMK_PI_MapOrderByRelationAggregateInput
  }

  export type PerformanceIndicatorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PerformanceIndicatorWhereInput | PerformanceIndicatorWhereInput[]
    OR?: PerformanceIndicatorWhereInput[]
    NOT?: PerformanceIndicatorWhereInput | PerformanceIndicatorWhereInput[]
    kode_pi?: StringFilter<"PerformanceIndicator"> | string
    deskripsi?: StringFilter<"PerformanceIndicator"> | string
    is_locked?: BoolFilter<"PerformanceIndicator"> | boolean
    createdAt?: DateTimeFilter<"PerformanceIndicator"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceIndicator"> | Date | string
    pi_group_id?: IntFilter<"PerformanceIndicator"> | number
    piGroup?: XOR<PIGroupScalarRelationFilter, PIGroupWhereInput>
    cpmkMap?: CPMK_PI_MapListRelationFilter
  }, "id">

  export type PerformanceIndicatorOrderByWithAggregationInput = {
    id?: SortOrder
    kode_pi?: SortOrder
    deskripsi?: SortOrder
    is_locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pi_group_id?: SortOrder
    _count?: PerformanceIndicatorCountOrderByAggregateInput
    _avg?: PerformanceIndicatorAvgOrderByAggregateInput
    _max?: PerformanceIndicatorMaxOrderByAggregateInput
    _min?: PerformanceIndicatorMinOrderByAggregateInput
    _sum?: PerformanceIndicatorSumOrderByAggregateInput
  }

  export type PerformanceIndicatorScalarWhereWithAggregatesInput = {
    AND?: PerformanceIndicatorScalarWhereWithAggregatesInput | PerformanceIndicatorScalarWhereWithAggregatesInput[]
    OR?: PerformanceIndicatorScalarWhereWithAggregatesInput[]
    NOT?: PerformanceIndicatorScalarWhereWithAggregatesInput | PerformanceIndicatorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PerformanceIndicator"> | number
    kode_pi?: StringWithAggregatesFilter<"PerformanceIndicator"> | string
    deskripsi?: StringWithAggregatesFilter<"PerformanceIndicator"> | string
    is_locked?: BoolWithAggregatesFilter<"PerformanceIndicator"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PerformanceIndicator"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PerformanceIndicator"> | Date | string
    pi_group_id?: IntWithAggregatesFilter<"PerformanceIndicator"> | number
  }

  export type CPLWhereInput = {
    AND?: CPLWhereInput | CPLWhereInput[]
    OR?: CPLWhereInput[]
    NOT?: CPLWhereInput | CPLWhereInput[]
    id?: IntFilter<"CPL"> | number
    kode_cpl?: StringFilter<"CPL"> | string
    deskripsi?: StringFilter<"CPL"> | string
    createdAt?: DateTimeFilter<"CPL"> | Date | string
    updatedAt?: DateTimeFilter<"CPL"> | Date | string
    kurikulum_id?: IntFilter<"CPL"> | number
    pi_group_id?: IntFilter<"CPL"> | number
    kurikulum?: XOR<KurikulumScalarRelationFilter, KurikulumWhereInput>
    piGroup?: XOR<PIGroupScalarRelationFilter, PIGroupWhereInput>
  }

  export type CPLOrderByWithRelationInput = {
    id?: SortOrder
    kode_cpl?: SortOrder
    deskripsi?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kurikulum_id?: SortOrder
    pi_group_id?: SortOrder
    kurikulum?: KurikulumOrderByWithRelationInput
    piGroup?: PIGroupOrderByWithRelationInput
  }

  export type CPLWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CPLWhereInput | CPLWhereInput[]
    OR?: CPLWhereInput[]
    NOT?: CPLWhereInput | CPLWhereInput[]
    kode_cpl?: StringFilter<"CPL"> | string
    deskripsi?: StringFilter<"CPL"> | string
    createdAt?: DateTimeFilter<"CPL"> | Date | string
    updatedAt?: DateTimeFilter<"CPL"> | Date | string
    kurikulum_id?: IntFilter<"CPL"> | number
    pi_group_id?: IntFilter<"CPL"> | number
    kurikulum?: XOR<KurikulumScalarRelationFilter, KurikulumWhereInput>
    piGroup?: XOR<PIGroupScalarRelationFilter, PIGroupWhereInput>
  }, "id">

  export type CPLOrderByWithAggregationInput = {
    id?: SortOrder
    kode_cpl?: SortOrder
    deskripsi?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kurikulum_id?: SortOrder
    pi_group_id?: SortOrder
    _count?: CPLCountOrderByAggregateInput
    _avg?: CPLAvgOrderByAggregateInput
    _max?: CPLMaxOrderByAggregateInput
    _min?: CPLMinOrderByAggregateInput
    _sum?: CPLSumOrderByAggregateInput
  }

  export type CPLScalarWhereWithAggregatesInput = {
    AND?: CPLScalarWhereWithAggregatesInput | CPLScalarWhereWithAggregatesInput[]
    OR?: CPLScalarWhereWithAggregatesInput[]
    NOT?: CPLScalarWhereWithAggregatesInput | CPLScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CPL"> | number
    kode_cpl?: StringWithAggregatesFilter<"CPL"> | string
    deskripsi?: StringWithAggregatesFilter<"CPL"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CPL"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CPL"> | Date | string
    kurikulum_id?: IntWithAggregatesFilter<"CPL"> | number
    pi_group_id?: IntWithAggregatesFilter<"CPL"> | number
  }

  export type TahunAjaranWhereInput = {
    AND?: TahunAjaranWhereInput | TahunAjaranWhereInput[]
    OR?: TahunAjaranWhereInput[]
    NOT?: TahunAjaranWhereInput | TahunAjaranWhereInput[]
    id?: IntFilter<"TahunAjaran"> | number
    tahun?: StringFilter<"TahunAjaran"> | string
    semester?: EnumSemesterFilter<"TahunAjaran"> | $Enums.Semester
    kelas?: KelasListRelationFilter
  }

  export type TahunAjaranOrderByWithRelationInput = {
    id?: SortOrder
    tahun?: SortOrder
    semester?: SortOrder
    kelas?: KelasOrderByRelationAggregateInput
  }

  export type TahunAjaranWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    tahun_semester?: TahunAjaranTahunSemesterCompoundUniqueInput
    AND?: TahunAjaranWhereInput | TahunAjaranWhereInput[]
    OR?: TahunAjaranWhereInput[]
    NOT?: TahunAjaranWhereInput | TahunAjaranWhereInput[]
    tahun?: StringFilter<"TahunAjaran"> | string
    semester?: EnumSemesterFilter<"TahunAjaran"> | $Enums.Semester
    kelas?: KelasListRelationFilter
  }, "id" | "tahun_semester">

  export type TahunAjaranOrderByWithAggregationInput = {
    id?: SortOrder
    tahun?: SortOrder
    semester?: SortOrder
    _count?: TahunAjaranCountOrderByAggregateInput
    _avg?: TahunAjaranAvgOrderByAggregateInput
    _max?: TahunAjaranMaxOrderByAggregateInput
    _min?: TahunAjaranMinOrderByAggregateInput
    _sum?: TahunAjaranSumOrderByAggregateInput
  }

  export type TahunAjaranScalarWhereWithAggregatesInput = {
    AND?: TahunAjaranScalarWhereWithAggregatesInput | TahunAjaranScalarWhereWithAggregatesInput[]
    OR?: TahunAjaranScalarWhereWithAggregatesInput[]
    NOT?: TahunAjaranScalarWhereWithAggregatesInput | TahunAjaranScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TahunAjaran"> | number
    tahun?: StringWithAggregatesFilter<"TahunAjaran"> | string
    semester?: EnumSemesterWithAggregatesFilter<"TahunAjaran"> | $Enums.Semester
  }

  export type KelasWhereInput = {
    AND?: KelasWhereInput | KelasWhereInput[]
    OR?: KelasWhereInput[]
    NOT?: KelasWhereInput | KelasWhereInput[]
    id?: IntFilter<"Kelas"> | number
    nama_kelas?: StringFilter<"Kelas"> | string
    createdAt?: DateTimeFilter<"Kelas"> | Date | string
    updatedAt?: DateTimeFilter<"Kelas"> | Date | string
    mata_kuliah_id?: IntFilter<"Kelas"> | number
    tahun_ajaran_id?: IntFilter<"Kelas"> | number
    mataKuliah?: XOR<MataKuliahScalarRelationFilter, MataKuliahWhereInput>
    tahunAjaran?: XOR<TahunAjaranScalarRelationFilter, TahunAjaranWhereInput>
    dosenPengampu?: DosenPengampuListRelationFilter
    pesertaKelas?: PesertaKelasListRelationFilter
    rps?: RPSListRelationFilter
    cpmk?: CPMKListRelationFilter
  }

  export type KelasOrderByWithRelationInput = {
    id?: SortOrder
    nama_kelas?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mata_kuliah_id?: SortOrder
    tahun_ajaran_id?: SortOrder
    mataKuliah?: MataKuliahOrderByWithRelationInput
    tahunAjaran?: TahunAjaranOrderByWithRelationInput
    dosenPengampu?: DosenPengampuOrderByRelationAggregateInput
    pesertaKelas?: PesertaKelasOrderByRelationAggregateInput
    rps?: RPSOrderByRelationAggregateInput
    cpmk?: CPMKOrderByRelationAggregateInput
  }

  export type KelasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: KelasWhereInput | KelasWhereInput[]
    OR?: KelasWhereInput[]
    NOT?: KelasWhereInput | KelasWhereInput[]
    nama_kelas?: StringFilter<"Kelas"> | string
    createdAt?: DateTimeFilter<"Kelas"> | Date | string
    updatedAt?: DateTimeFilter<"Kelas"> | Date | string
    mata_kuliah_id?: IntFilter<"Kelas"> | number
    tahun_ajaran_id?: IntFilter<"Kelas"> | number
    mataKuliah?: XOR<MataKuliahScalarRelationFilter, MataKuliahWhereInput>
    tahunAjaran?: XOR<TahunAjaranScalarRelationFilter, TahunAjaranWhereInput>
    dosenPengampu?: DosenPengampuListRelationFilter
    pesertaKelas?: PesertaKelasListRelationFilter
    rps?: RPSListRelationFilter
    cpmk?: CPMKListRelationFilter
  }, "id">

  export type KelasOrderByWithAggregationInput = {
    id?: SortOrder
    nama_kelas?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mata_kuliah_id?: SortOrder
    tahun_ajaran_id?: SortOrder
    _count?: KelasCountOrderByAggregateInput
    _avg?: KelasAvgOrderByAggregateInput
    _max?: KelasMaxOrderByAggregateInput
    _min?: KelasMinOrderByAggregateInput
    _sum?: KelasSumOrderByAggregateInput
  }

  export type KelasScalarWhereWithAggregatesInput = {
    AND?: KelasScalarWhereWithAggregatesInput | KelasScalarWhereWithAggregatesInput[]
    OR?: KelasScalarWhereWithAggregatesInput[]
    NOT?: KelasScalarWhereWithAggregatesInput | KelasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Kelas"> | number
    nama_kelas?: StringWithAggregatesFilter<"Kelas"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Kelas"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Kelas"> | Date | string
    mata_kuliah_id?: IntWithAggregatesFilter<"Kelas"> | number
    tahun_ajaran_id?: IntWithAggregatesFilter<"Kelas"> | number
  }

  export type DosenPengampuWhereInput = {
    AND?: DosenPengampuWhereInput | DosenPengampuWhereInput[]
    OR?: DosenPengampuWhereInput[]
    NOT?: DosenPengampuWhereInput | DosenPengampuWhereInput[]
    id?: IntFilter<"DosenPengampu"> | number
    createdAt?: DateTimeFilter<"DosenPengampu"> | Date | string
    kelas_id?: IntFilter<"DosenPengampu"> | number
    dosen_id?: IntFilter<"DosenPengampu"> | number
    kelas?: XOR<KelasScalarRelationFilter, KelasWhereInput>
    dosen?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DosenPengampuOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    kelas_id?: SortOrder
    dosen_id?: SortOrder
    kelas?: KelasOrderByWithRelationInput
    dosen?: UserOrderByWithRelationInput
  }

  export type DosenPengampuWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    kelas_id_dosen_id?: DosenPengampuKelas_idDosen_idCompoundUniqueInput
    AND?: DosenPengampuWhereInput | DosenPengampuWhereInput[]
    OR?: DosenPengampuWhereInput[]
    NOT?: DosenPengampuWhereInput | DosenPengampuWhereInput[]
    createdAt?: DateTimeFilter<"DosenPengampu"> | Date | string
    kelas_id?: IntFilter<"DosenPengampu"> | number
    dosen_id?: IntFilter<"DosenPengampu"> | number
    kelas?: XOR<KelasScalarRelationFilter, KelasWhereInput>
    dosen?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "kelas_id_dosen_id">

  export type DosenPengampuOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    kelas_id?: SortOrder
    dosen_id?: SortOrder
    _count?: DosenPengampuCountOrderByAggregateInput
    _avg?: DosenPengampuAvgOrderByAggregateInput
    _max?: DosenPengampuMaxOrderByAggregateInput
    _min?: DosenPengampuMinOrderByAggregateInput
    _sum?: DosenPengampuSumOrderByAggregateInput
  }

  export type DosenPengampuScalarWhereWithAggregatesInput = {
    AND?: DosenPengampuScalarWhereWithAggregatesInput | DosenPengampuScalarWhereWithAggregatesInput[]
    OR?: DosenPengampuScalarWhereWithAggregatesInput[]
    NOT?: DosenPengampuScalarWhereWithAggregatesInput | DosenPengampuScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DosenPengampu"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DosenPengampu"> | Date | string
    kelas_id?: IntWithAggregatesFilter<"DosenPengampu"> | number
    dosen_id?: IntWithAggregatesFilter<"DosenPengampu"> | number
  }

  export type PesertaKelasWhereInput = {
    AND?: PesertaKelasWhereInput | PesertaKelasWhereInput[]
    OR?: PesertaKelasWhereInput[]
    NOT?: PesertaKelasWhereInput | PesertaKelasWhereInput[]
    id?: IntFilter<"PesertaKelas"> | number
    createdAt?: DateTimeFilter<"PesertaKelas"> | Date | string
    kelas_id?: IntFilter<"PesertaKelas"> | number
    mahasiswa_id?: IntFilter<"PesertaKelas"> | number
    kelas?: XOR<KelasScalarRelationFilter, KelasWhereInput>
    mahasiswa?: XOR<UserScalarRelationFilter, UserWhereInput>
    nilai?: NilaiListRelationFilter
  }

  export type PesertaKelasOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    kelas_id?: SortOrder
    mahasiswa_id?: SortOrder
    kelas?: KelasOrderByWithRelationInput
    mahasiswa?: UserOrderByWithRelationInput
    nilai?: NilaiOrderByRelationAggregateInput
  }

  export type PesertaKelasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    kelas_id_mahasiswa_id?: PesertaKelasKelas_idMahasiswa_idCompoundUniqueInput
    AND?: PesertaKelasWhereInput | PesertaKelasWhereInput[]
    OR?: PesertaKelasWhereInput[]
    NOT?: PesertaKelasWhereInput | PesertaKelasWhereInput[]
    createdAt?: DateTimeFilter<"PesertaKelas"> | Date | string
    kelas_id?: IntFilter<"PesertaKelas"> | number
    mahasiswa_id?: IntFilter<"PesertaKelas"> | number
    kelas?: XOR<KelasScalarRelationFilter, KelasWhereInput>
    mahasiswa?: XOR<UserScalarRelationFilter, UserWhereInput>
    nilai?: NilaiListRelationFilter
  }, "id" | "kelas_id_mahasiswa_id">

  export type PesertaKelasOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    kelas_id?: SortOrder
    mahasiswa_id?: SortOrder
    _count?: PesertaKelasCountOrderByAggregateInput
    _avg?: PesertaKelasAvgOrderByAggregateInput
    _max?: PesertaKelasMaxOrderByAggregateInput
    _min?: PesertaKelasMinOrderByAggregateInput
    _sum?: PesertaKelasSumOrderByAggregateInput
  }

  export type PesertaKelasScalarWhereWithAggregatesInput = {
    AND?: PesertaKelasScalarWhereWithAggregatesInput | PesertaKelasScalarWhereWithAggregatesInput[]
    OR?: PesertaKelasScalarWhereWithAggregatesInput[]
    NOT?: PesertaKelasScalarWhereWithAggregatesInput | PesertaKelasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PesertaKelas"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PesertaKelas"> | Date | string
    kelas_id?: IntWithAggregatesFilter<"PesertaKelas"> | number
    mahasiswa_id?: IntWithAggregatesFilter<"PesertaKelas"> | number
  }

  export type RPSWhereInput = {
    AND?: RPSWhereInput | RPSWhereInput[]
    OR?: RPSWhereInput[]
    NOT?: RPSWhereInput | RPSWhereInput[]
    id?: IntFilter<"RPS"> | number
    file_path?: StringFilter<"RPS"> | string
    is_locked?: BoolFilter<"RPS"> | boolean
    createdAt?: DateTimeFilter<"RPS"> | Date | string
    updatedAt?: DateTimeFilter<"RPS"> | Date | string
    kelas_id?: IntFilter<"RPS"> | number
    kelas?: XOR<KelasScalarRelationFilter, KelasWhereInput>
  }

  export type RPSOrderByWithRelationInput = {
    id?: SortOrder
    file_path?: SortOrder
    is_locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kelas_id?: SortOrder
    kelas?: KelasOrderByWithRelationInput
  }

  export type RPSWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RPSWhereInput | RPSWhereInput[]
    OR?: RPSWhereInput[]
    NOT?: RPSWhereInput | RPSWhereInput[]
    file_path?: StringFilter<"RPS"> | string
    is_locked?: BoolFilter<"RPS"> | boolean
    createdAt?: DateTimeFilter<"RPS"> | Date | string
    updatedAt?: DateTimeFilter<"RPS"> | Date | string
    kelas_id?: IntFilter<"RPS"> | number
    kelas?: XOR<KelasScalarRelationFilter, KelasWhereInput>
  }, "id">

  export type RPSOrderByWithAggregationInput = {
    id?: SortOrder
    file_path?: SortOrder
    is_locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kelas_id?: SortOrder
    _count?: RPSCountOrderByAggregateInput
    _avg?: RPSAvgOrderByAggregateInput
    _max?: RPSMaxOrderByAggregateInput
    _min?: RPSMinOrderByAggregateInput
    _sum?: RPSSumOrderByAggregateInput
  }

  export type RPSScalarWhereWithAggregatesInput = {
    AND?: RPSScalarWhereWithAggregatesInput | RPSScalarWhereWithAggregatesInput[]
    OR?: RPSScalarWhereWithAggregatesInput[]
    NOT?: RPSScalarWhereWithAggregatesInput | RPSScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RPS"> | number
    file_path?: StringWithAggregatesFilter<"RPS"> | string
    is_locked?: BoolWithAggregatesFilter<"RPS"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RPS"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RPS"> | Date | string
    kelas_id?: IntWithAggregatesFilter<"RPS"> | number
  }

  export type CPMKWhereInput = {
    AND?: CPMKWhereInput | CPMKWhereInput[]
    OR?: CPMKWhereInput[]
    NOT?: CPMKWhereInput | CPMKWhereInput[]
    id?: IntFilter<"CPMK"> | number
    kode_cpmk?: StringFilter<"CPMK"> | string
    is_locked?: BoolFilter<"CPMK"> | boolean
    createdAt?: DateTimeFilter<"CPMK"> | Date | string
    updatedAt?: DateTimeFilter<"CPMK"> | Date | string
    kelas_id?: IntFilter<"CPMK"> | number
    kelas?: XOR<KelasScalarRelationFilter, KelasWhereInput>
    komponenPenilaian?: KomponenPenilaianListRelationFilter
    piMap?: CPMK_PI_MapListRelationFilter
  }

  export type CPMKOrderByWithRelationInput = {
    id?: SortOrder
    kode_cpmk?: SortOrder
    is_locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kelas_id?: SortOrder
    kelas?: KelasOrderByWithRelationInput
    komponenPenilaian?: KomponenPenilaianOrderByRelationAggregateInput
    piMap?: CPMK_PI_MapOrderByRelationAggregateInput
  }

  export type CPMKWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CPMKWhereInput | CPMKWhereInput[]
    OR?: CPMKWhereInput[]
    NOT?: CPMKWhereInput | CPMKWhereInput[]
    kode_cpmk?: StringFilter<"CPMK"> | string
    is_locked?: BoolFilter<"CPMK"> | boolean
    createdAt?: DateTimeFilter<"CPMK"> | Date | string
    updatedAt?: DateTimeFilter<"CPMK"> | Date | string
    kelas_id?: IntFilter<"CPMK"> | number
    kelas?: XOR<KelasScalarRelationFilter, KelasWhereInput>
    komponenPenilaian?: KomponenPenilaianListRelationFilter
    piMap?: CPMK_PI_MapListRelationFilter
  }, "id">

  export type CPMKOrderByWithAggregationInput = {
    id?: SortOrder
    kode_cpmk?: SortOrder
    is_locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kelas_id?: SortOrder
    _count?: CPMKCountOrderByAggregateInput
    _avg?: CPMKAvgOrderByAggregateInput
    _max?: CPMKMaxOrderByAggregateInput
    _min?: CPMKMinOrderByAggregateInput
    _sum?: CPMKSumOrderByAggregateInput
  }

  export type CPMKScalarWhereWithAggregatesInput = {
    AND?: CPMKScalarWhereWithAggregatesInput | CPMKScalarWhereWithAggregatesInput[]
    OR?: CPMKScalarWhereWithAggregatesInput[]
    NOT?: CPMKScalarWhereWithAggregatesInput | CPMKScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CPMK"> | number
    kode_cpmk?: StringWithAggregatesFilter<"CPMK"> | string
    is_locked?: BoolWithAggregatesFilter<"CPMK"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CPMK"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CPMK"> | Date | string
    kelas_id?: IntWithAggregatesFilter<"CPMK"> | number
  }

  export type CPMK_PI_MapWhereInput = {
    AND?: CPMK_PI_MapWhereInput | CPMK_PI_MapWhereInput[]
    OR?: CPMK_PI_MapWhereInput[]
    NOT?: CPMK_PI_MapWhereInput | CPMK_PI_MapWhereInput[]
    cpmk_id?: IntFilter<"CPMK_PI_Map"> | number
    pi_id?: IntFilter<"CPMK_PI_Map"> | number
    cpmk?: XOR<CPMKScalarRelationFilter, CPMKWhereInput>
    pi?: XOR<PerformanceIndicatorScalarRelationFilter, PerformanceIndicatorWhereInput>
  }

  export type CPMK_PI_MapOrderByWithRelationInput = {
    cpmk_id?: SortOrder
    pi_id?: SortOrder
    cpmk?: CPMKOrderByWithRelationInput
    pi?: PerformanceIndicatorOrderByWithRelationInput
  }

  export type CPMK_PI_MapWhereUniqueInput = Prisma.AtLeast<{
    cpmk_id_pi_id?: CPMK_PI_MapCpmk_idPi_idCompoundUniqueInput
    AND?: CPMK_PI_MapWhereInput | CPMK_PI_MapWhereInput[]
    OR?: CPMK_PI_MapWhereInput[]
    NOT?: CPMK_PI_MapWhereInput | CPMK_PI_MapWhereInput[]
    cpmk_id?: IntFilter<"CPMK_PI_Map"> | number
    pi_id?: IntFilter<"CPMK_PI_Map"> | number
    cpmk?: XOR<CPMKScalarRelationFilter, CPMKWhereInput>
    pi?: XOR<PerformanceIndicatorScalarRelationFilter, PerformanceIndicatorWhereInput>
  }, "cpmk_id_pi_id">

  export type CPMK_PI_MapOrderByWithAggregationInput = {
    cpmk_id?: SortOrder
    pi_id?: SortOrder
    _count?: CPMK_PI_MapCountOrderByAggregateInput
    _avg?: CPMK_PI_MapAvgOrderByAggregateInput
    _max?: CPMK_PI_MapMaxOrderByAggregateInput
    _min?: CPMK_PI_MapMinOrderByAggregateInput
    _sum?: CPMK_PI_MapSumOrderByAggregateInput
  }

  export type CPMK_PI_MapScalarWhereWithAggregatesInput = {
    AND?: CPMK_PI_MapScalarWhereWithAggregatesInput | CPMK_PI_MapScalarWhereWithAggregatesInput[]
    OR?: CPMK_PI_MapScalarWhereWithAggregatesInput[]
    NOT?: CPMK_PI_MapScalarWhereWithAggregatesInput | CPMK_PI_MapScalarWhereWithAggregatesInput[]
    cpmk_id?: IntWithAggregatesFilter<"CPMK_PI_Map"> | number
    pi_id?: IntWithAggregatesFilter<"CPMK_PI_Map"> | number
  }

  export type KomponenPenilaianWhereInput = {
    AND?: KomponenPenilaianWhereInput | KomponenPenilaianWhereInput[]
    OR?: KomponenPenilaianWhereInput[]
    NOT?: KomponenPenilaianWhereInput | KomponenPenilaianWhereInput[]
    id?: IntFilter<"KomponenPenilaian"> | number
    nama?: StringFilter<"KomponenPenilaian"> | string
    bobot?: FloatFilter<"KomponenPenilaian"> | number
    createdAt?: DateTimeFilter<"KomponenPenilaian"> | Date | string
    updatedAt?: DateTimeFilter<"KomponenPenilaian"> | Date | string
    cpmk_id?: IntFilter<"KomponenPenilaian"> | number
    cpmk?: XOR<CPMKScalarRelationFilter, CPMKWhereInput>
    nilai?: NilaiListRelationFilter
  }

  export type KomponenPenilaianOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrder
    bobot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpmk_id?: SortOrder
    cpmk?: CPMKOrderByWithRelationInput
    nilai?: NilaiOrderByRelationAggregateInput
  }

  export type KomponenPenilaianWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: KomponenPenilaianWhereInput | KomponenPenilaianWhereInput[]
    OR?: KomponenPenilaianWhereInput[]
    NOT?: KomponenPenilaianWhereInput | KomponenPenilaianWhereInput[]
    nama?: StringFilter<"KomponenPenilaian"> | string
    bobot?: FloatFilter<"KomponenPenilaian"> | number
    createdAt?: DateTimeFilter<"KomponenPenilaian"> | Date | string
    updatedAt?: DateTimeFilter<"KomponenPenilaian"> | Date | string
    cpmk_id?: IntFilter<"KomponenPenilaian"> | number
    cpmk?: XOR<CPMKScalarRelationFilter, CPMKWhereInput>
    nilai?: NilaiListRelationFilter
  }, "id">

  export type KomponenPenilaianOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrder
    bobot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpmk_id?: SortOrder
    _count?: KomponenPenilaianCountOrderByAggregateInput
    _avg?: KomponenPenilaianAvgOrderByAggregateInput
    _max?: KomponenPenilaianMaxOrderByAggregateInput
    _min?: KomponenPenilaianMinOrderByAggregateInput
    _sum?: KomponenPenilaianSumOrderByAggregateInput
  }

  export type KomponenPenilaianScalarWhereWithAggregatesInput = {
    AND?: KomponenPenilaianScalarWhereWithAggregatesInput | KomponenPenilaianScalarWhereWithAggregatesInput[]
    OR?: KomponenPenilaianScalarWhereWithAggregatesInput[]
    NOT?: KomponenPenilaianScalarWhereWithAggregatesInput | KomponenPenilaianScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KomponenPenilaian"> | number
    nama?: StringWithAggregatesFilter<"KomponenPenilaian"> | string
    bobot?: FloatWithAggregatesFilter<"KomponenPenilaian"> | number
    createdAt?: DateTimeWithAggregatesFilter<"KomponenPenilaian"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KomponenPenilaian"> | Date | string
    cpmk_id?: IntWithAggregatesFilter<"KomponenPenilaian"> | number
  }

  export type NilaiWhereInput = {
    AND?: NilaiWhereInput | NilaiWhereInput[]
    OR?: NilaiWhereInput[]
    NOT?: NilaiWhereInput | NilaiWhereInput[]
    id?: IntFilter<"Nilai"> | number
    nilai_angka?: FloatFilter<"Nilai"> | number
    createdAt?: DateTimeFilter<"Nilai"> | Date | string
    updatedAt?: DateTimeFilter<"Nilai"> | Date | string
    peserta_kelas_id?: IntFilter<"Nilai"> | number
    komponen_penilaian_id?: IntFilter<"Nilai"> | number
    pesertaKelas?: XOR<PesertaKelasScalarRelationFilter, PesertaKelasWhereInput>
    komponenPenilaian?: XOR<KomponenPenilaianScalarRelationFilter, KomponenPenilaianWhereInput>
  }

  export type NilaiOrderByWithRelationInput = {
    id?: SortOrder
    nilai_angka?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    peserta_kelas_id?: SortOrder
    komponen_penilaian_id?: SortOrder
    pesertaKelas?: PesertaKelasOrderByWithRelationInput
    komponenPenilaian?: KomponenPenilaianOrderByWithRelationInput
  }

  export type NilaiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    peserta_kelas_id_komponen_penilaian_id?: NilaiPeserta_kelas_idKomponen_penilaian_idCompoundUniqueInput
    AND?: NilaiWhereInput | NilaiWhereInput[]
    OR?: NilaiWhereInput[]
    NOT?: NilaiWhereInput | NilaiWhereInput[]
    nilai_angka?: FloatFilter<"Nilai"> | number
    createdAt?: DateTimeFilter<"Nilai"> | Date | string
    updatedAt?: DateTimeFilter<"Nilai"> | Date | string
    peserta_kelas_id?: IntFilter<"Nilai"> | number
    komponen_penilaian_id?: IntFilter<"Nilai"> | number
    pesertaKelas?: XOR<PesertaKelasScalarRelationFilter, PesertaKelasWhereInput>
    komponenPenilaian?: XOR<KomponenPenilaianScalarRelationFilter, KomponenPenilaianWhereInput>
  }, "id" | "peserta_kelas_id_komponen_penilaian_id">

  export type NilaiOrderByWithAggregationInput = {
    id?: SortOrder
    nilai_angka?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    peserta_kelas_id?: SortOrder
    komponen_penilaian_id?: SortOrder
    _count?: NilaiCountOrderByAggregateInput
    _avg?: NilaiAvgOrderByAggregateInput
    _max?: NilaiMaxOrderByAggregateInput
    _min?: NilaiMinOrderByAggregateInput
    _sum?: NilaiSumOrderByAggregateInput
  }

  export type NilaiScalarWhereWithAggregatesInput = {
    AND?: NilaiScalarWhereWithAggregatesInput | NilaiScalarWhereWithAggregatesInput[]
    OR?: NilaiScalarWhereWithAggregatesInput[]
    NOT?: NilaiScalarWhereWithAggregatesInput | NilaiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Nilai"> | number
    nilai_angka?: FloatWithAggregatesFilter<"Nilai"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Nilai"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Nilai"> | Date | string
    peserta_kelas_id?: IntWithAggregatesFilter<"Nilai"> | number
    komponen_penilaian_id?: IntWithAggregatesFilter<"Nilai"> | number
  }

  export type ProgramStudiCreateInput = {
    nama: string
    jenjang: string
    total_sks_lulus: number
    users?: UserCreateNestedManyWithoutProgramStudiInput
    kurikulum?: KurikulumCreateNestedManyWithoutProgramStudiInput
  }

  export type ProgramStudiUncheckedCreateInput = {
    id?: number
    nama: string
    jenjang: string
    total_sks_lulus: number
    users?: UserUncheckedCreateNestedManyWithoutProgramStudiInput
    kurikulum?: KurikulumUncheckedCreateNestedManyWithoutProgramStudiInput
  }

  export type ProgramStudiUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
    jenjang?: StringFieldUpdateOperationsInput | string
    total_sks_lulus?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutProgramStudiNestedInput
    kurikulum?: KurikulumUpdateManyWithoutProgramStudiNestedInput
  }

  export type ProgramStudiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    jenjang?: StringFieldUpdateOperationsInput | string
    total_sks_lulus?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutProgramStudiNestedInput
    kurikulum?: KurikulumUncheckedUpdateManyWithoutProgramStudiNestedInput
  }

  export type ProgramStudiCreateManyInput = {
    id?: number
    nama: string
    jenjang: string
    total_sks_lulus: number
  }

  export type ProgramStudiUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
    jenjang?: StringFieldUpdateOperationsInput | string
    total_sks_lulus?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramStudiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    jenjang?: StringFieldUpdateOperationsInput | string
    total_sks_lulus?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    username: string
    password_hash: string
    nama: string
    role: $Enums.UserRole
    programStudi: ProgramStudiCreateNestedOneWithoutUsersInput
    dosenPengampu?: DosenPengampuCreateNestedManyWithoutDosenInput
    pesertaKelas?: PesertaKelasCreateNestedManyWithoutMahasiswaInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password_hash: string
    nama: string
    role: $Enums.UserRole
    program_studi_id: number
    dosenPengampu?: DosenPengampuUncheckedCreateNestedManyWithoutDosenInput
    pesertaKelas?: PesertaKelasUncheckedCreateNestedManyWithoutMahasiswaInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programStudi?: ProgramStudiUpdateOneRequiredWithoutUsersNestedInput
    dosenPengampu?: DosenPengampuUpdateManyWithoutDosenNestedInput
    pesertaKelas?: PesertaKelasUpdateManyWithoutMahasiswaNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    program_studi_id?: IntFieldUpdateOperationsInput | number
    dosenPengampu?: DosenPengampuUncheckedUpdateManyWithoutDosenNestedInput
    pesertaKelas?: PesertaKelasUncheckedUpdateManyWithoutMahasiswaNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password_hash: string
    nama: string
    role: $Enums.UserRole
    program_studi_id: number
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    program_studi_id?: IntFieldUpdateOperationsInput | number
  }

  export type KurikulumCreateInput = {
    nama: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    programStudi: ProgramStudiCreateNestedOneWithoutKurikulumInput
    mataKuliah?: MataKuliahCreateNestedManyWithoutKurikulumInput
    cpl?: CPLCreateNestedManyWithoutKurikulumInput
    piGroups?: PIGroupCreateNestedManyWithoutKurikulumInput
  }

  export type KurikulumUncheckedCreateInput = {
    id?: number
    nama: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    program_studi_id: number
    mataKuliah?: MataKuliahUncheckedCreateNestedManyWithoutKurikulumInput
    cpl?: CPLUncheckedCreateNestedManyWithoutKurikulumInput
    piGroups?: PIGroupUncheckedCreateNestedManyWithoutKurikulumInput
  }

  export type KurikulumUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programStudi?: ProgramStudiUpdateOneRequiredWithoutKurikulumNestedInput
    mataKuliah?: MataKuliahUpdateManyWithoutKurikulumNestedInput
    cpl?: CPLUpdateManyWithoutKurikulumNestedInput
    piGroups?: PIGroupUpdateManyWithoutKurikulumNestedInput
  }

  export type KurikulumUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program_studi_id?: IntFieldUpdateOperationsInput | number
    mataKuliah?: MataKuliahUncheckedUpdateManyWithoutKurikulumNestedInput
    cpl?: CPLUncheckedUpdateManyWithoutKurikulumNestedInput
    piGroups?: PIGroupUncheckedUpdateManyWithoutKurikulumNestedInput
  }

  export type KurikulumCreateManyInput = {
    id?: number
    nama: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    program_studi_id: number
  }

  export type KurikulumUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KurikulumUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program_studi_id?: IntFieldUpdateOperationsInput | number
  }

  export type MataKuliahCreateInput = {
    kode_mk: string
    nama: string
    sks: number
    createdAt?: Date | string
    updatedAt?: Date | string
    kurikulum: KurikulumCreateNestedOneWithoutMataKuliahInput
    kelas?: KelasCreateNestedManyWithoutMataKuliahInput
  }

  export type MataKuliahUncheckedCreateInput = {
    id?: number
    kode_mk: string
    nama: string
    sks: number
    createdAt?: Date | string
    updatedAt?: Date | string
    kurikulum_id: number
    kelas?: KelasUncheckedCreateNestedManyWithoutMataKuliahInput
  }

  export type MataKuliahUpdateInput = {
    kode_mk?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    sks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kurikulum?: KurikulumUpdateOneRequiredWithoutMataKuliahNestedInput
    kelas?: KelasUpdateManyWithoutMataKuliahNestedInput
  }

  export type MataKuliahUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_mk?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    sks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kurikulum_id?: IntFieldUpdateOperationsInput | number
    kelas?: KelasUncheckedUpdateManyWithoutMataKuliahNestedInput
  }

  export type MataKuliahCreateManyInput = {
    id?: number
    kode_mk: string
    nama: string
    sks: number
    createdAt?: Date | string
    updatedAt?: Date | string
    kurikulum_id: number
  }

  export type MataKuliahUpdateManyMutationInput = {
    kode_mk?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    sks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MataKuliahUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_mk?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    sks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kurikulum_id?: IntFieldUpdateOperationsInput | number
  }

  export type PIGroupCreateInput = {
    kode_grup: string
    nama_grup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kurikulum: KurikulumCreateNestedOneWithoutPiGroupsInput
    indicators?: PerformanceIndicatorCreateNestedManyWithoutPiGroupInput
    cpl?: CPLCreateNestedManyWithoutPiGroupInput
  }

  export type PIGroupUncheckedCreateInput = {
    id?: number
    kode_grup: string
    nama_grup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kurikulum_id: number
    indicators?: PerformanceIndicatorUncheckedCreateNestedManyWithoutPiGroupInput
    cpl?: CPLUncheckedCreateNestedManyWithoutPiGroupInput
  }

  export type PIGroupUpdateInput = {
    kode_grup?: StringFieldUpdateOperationsInput | string
    nama_grup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kurikulum?: KurikulumUpdateOneRequiredWithoutPiGroupsNestedInput
    indicators?: PerformanceIndicatorUpdateManyWithoutPiGroupNestedInput
    cpl?: CPLUpdateManyWithoutPiGroupNestedInput
  }

  export type PIGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_grup?: StringFieldUpdateOperationsInput | string
    nama_grup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kurikulum_id?: IntFieldUpdateOperationsInput | number
    indicators?: PerformanceIndicatorUncheckedUpdateManyWithoutPiGroupNestedInput
    cpl?: CPLUncheckedUpdateManyWithoutPiGroupNestedInput
  }

  export type PIGroupCreateManyInput = {
    id?: number
    kode_grup: string
    nama_grup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kurikulum_id: number
  }

  export type PIGroupUpdateManyMutationInput = {
    kode_grup?: StringFieldUpdateOperationsInput | string
    nama_grup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PIGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_grup?: StringFieldUpdateOperationsInput | string
    nama_grup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kurikulum_id?: IntFieldUpdateOperationsInput | number
  }

  export type PerformanceIndicatorCreateInput = {
    kode_pi: string
    deskripsi: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    piGroup: PIGroupCreateNestedOneWithoutIndicatorsInput
    cpmkMap?: CPMK_PI_MapCreateNestedManyWithoutPiInput
  }

  export type PerformanceIndicatorUncheckedCreateInput = {
    id?: number
    kode_pi: string
    deskripsi: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pi_group_id: number
    cpmkMap?: CPMK_PI_MapUncheckedCreateNestedManyWithoutPiInput
  }

  export type PerformanceIndicatorUpdateInput = {
    kode_pi?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    piGroup?: PIGroupUpdateOneRequiredWithoutIndicatorsNestedInput
    cpmkMap?: CPMK_PI_MapUpdateManyWithoutPiNestedInput
  }

  export type PerformanceIndicatorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_pi?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pi_group_id?: IntFieldUpdateOperationsInput | number
    cpmkMap?: CPMK_PI_MapUncheckedUpdateManyWithoutPiNestedInput
  }

  export type PerformanceIndicatorCreateManyInput = {
    id?: number
    kode_pi: string
    deskripsi: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pi_group_id: number
  }

  export type PerformanceIndicatorUpdateManyMutationInput = {
    kode_pi?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceIndicatorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_pi?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pi_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type CPLCreateInput = {
    kode_cpl: string
    deskripsi: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kurikulum: KurikulumCreateNestedOneWithoutCplInput
    piGroup: PIGroupCreateNestedOneWithoutCplInput
  }

  export type CPLUncheckedCreateInput = {
    id?: number
    kode_cpl: string
    deskripsi: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kurikulum_id: number
    pi_group_id: number
  }

  export type CPLUpdateInput = {
    kode_cpl?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kurikulum?: KurikulumUpdateOneRequiredWithoutCplNestedInput
    piGroup?: PIGroupUpdateOneRequiredWithoutCplNestedInput
  }

  export type CPLUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_cpl?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kurikulum_id?: IntFieldUpdateOperationsInput | number
    pi_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type CPLCreateManyInput = {
    id?: number
    kode_cpl: string
    deskripsi: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kurikulum_id: number
    pi_group_id: number
  }

  export type CPLUpdateManyMutationInput = {
    kode_cpl?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CPLUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_cpl?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kurikulum_id?: IntFieldUpdateOperationsInput | number
    pi_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type TahunAjaranCreateInput = {
    tahun: string
    semester: $Enums.Semester
    kelas?: KelasCreateNestedManyWithoutTahunAjaranInput
  }

  export type TahunAjaranUncheckedCreateInput = {
    id?: number
    tahun: string
    semester: $Enums.Semester
    kelas?: KelasUncheckedCreateNestedManyWithoutTahunAjaranInput
  }

  export type TahunAjaranUpdateInput = {
    tahun?: StringFieldUpdateOperationsInput | string
    semester?: EnumSemesterFieldUpdateOperationsInput | $Enums.Semester
    kelas?: KelasUpdateManyWithoutTahunAjaranNestedInput
  }

  export type TahunAjaranUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tahun?: StringFieldUpdateOperationsInput | string
    semester?: EnumSemesterFieldUpdateOperationsInput | $Enums.Semester
    kelas?: KelasUncheckedUpdateManyWithoutTahunAjaranNestedInput
  }

  export type TahunAjaranCreateManyInput = {
    id?: number
    tahun: string
    semester: $Enums.Semester
  }

  export type TahunAjaranUpdateManyMutationInput = {
    tahun?: StringFieldUpdateOperationsInput | string
    semester?: EnumSemesterFieldUpdateOperationsInput | $Enums.Semester
  }

  export type TahunAjaranUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tahun?: StringFieldUpdateOperationsInput | string
    semester?: EnumSemesterFieldUpdateOperationsInput | $Enums.Semester
  }

  export type KelasCreateInput = {
    nama_kelas: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mataKuliah: MataKuliahCreateNestedOneWithoutKelasInput
    tahunAjaran: TahunAjaranCreateNestedOneWithoutKelasInput
    dosenPengampu?: DosenPengampuCreateNestedManyWithoutKelasInput
    pesertaKelas?: PesertaKelasCreateNestedManyWithoutKelasInput
    rps?: RPSCreateNestedManyWithoutKelasInput
    cpmk?: CPMKCreateNestedManyWithoutKelasInput
  }

  export type KelasUncheckedCreateInput = {
    id?: number
    nama_kelas: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mata_kuliah_id: number
    tahun_ajaran_id: number
    dosenPengampu?: DosenPengampuUncheckedCreateNestedManyWithoutKelasInput
    pesertaKelas?: PesertaKelasUncheckedCreateNestedManyWithoutKelasInput
    rps?: RPSUncheckedCreateNestedManyWithoutKelasInput
    cpmk?: CPMKUncheckedCreateNestedManyWithoutKelasInput
  }

  export type KelasUpdateInput = {
    nama_kelas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mataKuliah?: MataKuliahUpdateOneRequiredWithoutKelasNestedInput
    tahunAjaran?: TahunAjaranUpdateOneRequiredWithoutKelasNestedInput
    dosenPengampu?: DosenPengampuUpdateManyWithoutKelasNestedInput
    pesertaKelas?: PesertaKelasUpdateManyWithoutKelasNestedInput
    rps?: RPSUpdateManyWithoutKelasNestedInput
    cpmk?: CPMKUpdateManyWithoutKelasNestedInput
  }

  export type KelasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_kelas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mata_kuliah_id?: IntFieldUpdateOperationsInput | number
    tahun_ajaran_id?: IntFieldUpdateOperationsInput | number
    dosenPengampu?: DosenPengampuUncheckedUpdateManyWithoutKelasNestedInput
    pesertaKelas?: PesertaKelasUncheckedUpdateManyWithoutKelasNestedInput
    rps?: RPSUncheckedUpdateManyWithoutKelasNestedInput
    cpmk?: CPMKUncheckedUpdateManyWithoutKelasNestedInput
  }

  export type KelasCreateManyInput = {
    id?: number
    nama_kelas: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mata_kuliah_id: number
    tahun_ajaran_id: number
  }

  export type KelasUpdateManyMutationInput = {
    nama_kelas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KelasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_kelas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mata_kuliah_id?: IntFieldUpdateOperationsInput | number
    tahun_ajaran_id?: IntFieldUpdateOperationsInput | number
  }

  export type DosenPengampuCreateInput = {
    createdAt?: Date | string
    kelas: KelasCreateNestedOneWithoutDosenPengampuInput
    dosen: UserCreateNestedOneWithoutDosenPengampuInput
  }

  export type DosenPengampuUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    kelas_id: number
    dosen_id: number
  }

  export type DosenPengampuUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas?: KelasUpdateOneRequiredWithoutDosenPengampuNestedInput
    dosen?: UserUpdateOneRequiredWithoutDosenPengampuNestedInput
  }

  export type DosenPengampuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas_id?: IntFieldUpdateOperationsInput | number
    dosen_id?: IntFieldUpdateOperationsInput | number
  }

  export type DosenPengampuCreateManyInput = {
    id?: number
    createdAt?: Date | string
    kelas_id: number
    dosen_id: number
  }

  export type DosenPengampuUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DosenPengampuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas_id?: IntFieldUpdateOperationsInput | number
    dosen_id?: IntFieldUpdateOperationsInput | number
  }

  export type PesertaKelasCreateInput = {
    createdAt?: Date | string
    kelas: KelasCreateNestedOneWithoutPesertaKelasInput
    mahasiswa: UserCreateNestedOneWithoutPesertaKelasInput
    nilai?: NilaiCreateNestedManyWithoutPesertaKelasInput
  }

  export type PesertaKelasUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    kelas_id: number
    mahasiswa_id: number
    nilai?: NilaiUncheckedCreateNestedManyWithoutPesertaKelasInput
  }

  export type PesertaKelasUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas?: KelasUpdateOneRequiredWithoutPesertaKelasNestedInput
    mahasiswa?: UserUpdateOneRequiredWithoutPesertaKelasNestedInput
    nilai?: NilaiUpdateManyWithoutPesertaKelasNestedInput
  }

  export type PesertaKelasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas_id?: IntFieldUpdateOperationsInput | number
    mahasiswa_id?: IntFieldUpdateOperationsInput | number
    nilai?: NilaiUncheckedUpdateManyWithoutPesertaKelasNestedInput
  }

  export type PesertaKelasCreateManyInput = {
    id?: number
    createdAt?: Date | string
    kelas_id: number
    mahasiswa_id: number
  }

  export type PesertaKelasUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PesertaKelasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas_id?: IntFieldUpdateOperationsInput | number
    mahasiswa_id?: IntFieldUpdateOperationsInput | number
  }

  export type RPSCreateInput = {
    file_path: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kelas: KelasCreateNestedOneWithoutRpsInput
  }

  export type RPSUncheckedCreateInput = {
    id?: number
    file_path: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kelas_id: number
  }

  export type RPSUpdateInput = {
    file_path?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas?: KelasUpdateOneRequiredWithoutRpsNestedInput
  }

  export type RPSUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_path?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas_id?: IntFieldUpdateOperationsInput | number
  }

  export type RPSCreateManyInput = {
    id?: number
    file_path: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kelas_id: number
  }

  export type RPSUpdateManyMutationInput = {
    file_path?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RPSUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_path?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas_id?: IntFieldUpdateOperationsInput | number
  }

  export type CPMKCreateInput = {
    kode_cpmk: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kelas: KelasCreateNestedOneWithoutCpmkInput
    komponenPenilaian?: KomponenPenilaianCreateNestedManyWithoutCpmkInput
    piMap?: CPMK_PI_MapCreateNestedManyWithoutCpmkInput
  }

  export type CPMKUncheckedCreateInput = {
    id?: number
    kode_cpmk: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kelas_id: number
    komponenPenilaian?: KomponenPenilaianUncheckedCreateNestedManyWithoutCpmkInput
    piMap?: CPMK_PI_MapUncheckedCreateNestedManyWithoutCpmkInput
  }

  export type CPMKUpdateInput = {
    kode_cpmk?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas?: KelasUpdateOneRequiredWithoutCpmkNestedInput
    komponenPenilaian?: KomponenPenilaianUpdateManyWithoutCpmkNestedInput
    piMap?: CPMK_PI_MapUpdateManyWithoutCpmkNestedInput
  }

  export type CPMKUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_cpmk?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas_id?: IntFieldUpdateOperationsInput | number
    komponenPenilaian?: KomponenPenilaianUncheckedUpdateManyWithoutCpmkNestedInput
    piMap?: CPMK_PI_MapUncheckedUpdateManyWithoutCpmkNestedInput
  }

  export type CPMKCreateManyInput = {
    id?: number
    kode_cpmk: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kelas_id: number
  }

  export type CPMKUpdateManyMutationInput = {
    kode_cpmk?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CPMKUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_cpmk?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas_id?: IntFieldUpdateOperationsInput | number
  }

  export type CPMK_PI_MapCreateInput = {
    cpmk: CPMKCreateNestedOneWithoutPiMapInput
    pi: PerformanceIndicatorCreateNestedOneWithoutCpmkMapInput
  }

  export type CPMK_PI_MapUncheckedCreateInput = {
    cpmk_id: number
    pi_id: number
  }

  export type CPMK_PI_MapUpdateInput = {
    cpmk?: CPMKUpdateOneRequiredWithoutPiMapNestedInput
    pi?: PerformanceIndicatorUpdateOneRequiredWithoutCpmkMapNestedInput
  }

  export type CPMK_PI_MapUncheckedUpdateInput = {
    cpmk_id?: IntFieldUpdateOperationsInput | number
    pi_id?: IntFieldUpdateOperationsInput | number
  }

  export type CPMK_PI_MapCreateManyInput = {
    cpmk_id: number
    pi_id: number
  }

  export type CPMK_PI_MapUpdateManyMutationInput = {

  }

  export type CPMK_PI_MapUncheckedUpdateManyInput = {
    cpmk_id?: IntFieldUpdateOperationsInput | number
    pi_id?: IntFieldUpdateOperationsInput | number
  }

  export type KomponenPenilaianCreateInput = {
    nama: string
    bobot: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cpmk: CPMKCreateNestedOneWithoutKomponenPenilaianInput
    nilai?: NilaiCreateNestedManyWithoutKomponenPenilaianInput
  }

  export type KomponenPenilaianUncheckedCreateInput = {
    id?: number
    nama: string
    bobot: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cpmk_id: number
    nilai?: NilaiUncheckedCreateNestedManyWithoutKomponenPenilaianInput
  }

  export type KomponenPenilaianUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
    bobot?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpmk?: CPMKUpdateOneRequiredWithoutKomponenPenilaianNestedInput
    nilai?: NilaiUpdateManyWithoutKomponenPenilaianNestedInput
  }

  export type KomponenPenilaianUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    bobot?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpmk_id?: IntFieldUpdateOperationsInput | number
    nilai?: NilaiUncheckedUpdateManyWithoutKomponenPenilaianNestedInput
  }

  export type KomponenPenilaianCreateManyInput = {
    id?: number
    nama: string
    bobot: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cpmk_id: number
  }

  export type KomponenPenilaianUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
    bobot?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KomponenPenilaianUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    bobot?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpmk_id?: IntFieldUpdateOperationsInput | number
  }

  export type NilaiCreateInput = {
    nilai_angka: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pesertaKelas: PesertaKelasCreateNestedOneWithoutNilaiInput
    komponenPenilaian: KomponenPenilaianCreateNestedOneWithoutNilaiInput
  }

  export type NilaiUncheckedCreateInput = {
    id?: number
    nilai_angka: number
    createdAt?: Date | string
    updatedAt?: Date | string
    peserta_kelas_id: number
    komponen_penilaian_id: number
  }

  export type NilaiUpdateInput = {
    nilai_angka?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pesertaKelas?: PesertaKelasUpdateOneRequiredWithoutNilaiNestedInput
    komponenPenilaian?: KomponenPenilaianUpdateOneRequiredWithoutNilaiNestedInput
  }

  export type NilaiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nilai_angka?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    peserta_kelas_id?: IntFieldUpdateOperationsInput | number
    komponen_penilaian_id?: IntFieldUpdateOperationsInput | number
  }

  export type NilaiCreateManyInput = {
    id?: number
    nilai_angka: number
    createdAt?: Date | string
    updatedAt?: Date | string
    peserta_kelas_id: number
    komponen_penilaian_id: number
  }

  export type NilaiUpdateManyMutationInput = {
    nilai_angka?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NilaiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nilai_angka?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    peserta_kelas_id?: IntFieldUpdateOperationsInput | number
    komponen_penilaian_id?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type KurikulumListRelationFilter = {
    every?: KurikulumWhereInput
    some?: KurikulumWhereInput
    none?: KurikulumWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KurikulumOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramStudiCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    jenjang?: SortOrder
    total_sks_lulus?: SortOrder
  }

  export type ProgramStudiAvgOrderByAggregateInput = {
    id?: SortOrder
    total_sks_lulus?: SortOrder
  }

  export type ProgramStudiMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    jenjang?: SortOrder
    total_sks_lulus?: SortOrder
  }

  export type ProgramStudiMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    jenjang?: SortOrder
    total_sks_lulus?: SortOrder
  }

  export type ProgramStudiSumOrderByAggregateInput = {
    id?: SortOrder
    total_sks_lulus?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type ProgramStudiScalarRelationFilter = {
    is?: ProgramStudiWhereInput
    isNot?: ProgramStudiWhereInput
  }

  export type DosenPengampuListRelationFilter = {
    every?: DosenPengampuWhereInput
    some?: DosenPengampuWhereInput
    none?: DosenPengampuWhereInput
  }

  export type PesertaKelasListRelationFilter = {
    every?: PesertaKelasWhereInput
    some?: PesertaKelasWhereInput
    none?: PesertaKelasWhereInput
  }

  export type DosenPengampuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PesertaKelasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    nama?: SortOrder
    role?: SortOrder
    program_studi_id?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    program_studi_id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    nama?: SortOrder
    role?: SortOrder
    program_studi_id?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password_hash?: SortOrder
    nama?: SortOrder
    role?: SortOrder
    program_studi_id?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    program_studi_id?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MataKuliahListRelationFilter = {
    every?: MataKuliahWhereInput
    some?: MataKuliahWhereInput
    none?: MataKuliahWhereInput
  }

  export type CPLListRelationFilter = {
    every?: CPLWhereInput
    some?: CPLWhereInput
    none?: CPLWhereInput
  }

  export type PIGroupListRelationFilter = {
    every?: PIGroupWhereInput
    some?: PIGroupWhereInput
    none?: PIGroupWhereInput
  }

  export type MataKuliahOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CPLOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PIGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KurikulumCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    tahun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    program_studi_id?: SortOrder
  }

  export type KurikulumAvgOrderByAggregateInput = {
    id?: SortOrder
    tahun?: SortOrder
    program_studi_id?: SortOrder
  }

  export type KurikulumMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    tahun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    program_studi_id?: SortOrder
  }

  export type KurikulumMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    tahun?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    program_studi_id?: SortOrder
  }

  export type KurikulumSumOrderByAggregateInput = {
    id?: SortOrder
    tahun?: SortOrder
    program_studi_id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type KurikulumScalarRelationFilter = {
    is?: KurikulumWhereInput
    isNot?: KurikulumWhereInput
  }

  export type KelasListRelationFilter = {
    every?: KelasWhereInput
    some?: KelasWhereInput
    none?: KelasWhereInput
  }

  export type KelasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MataKuliahCountOrderByAggregateInput = {
    id?: SortOrder
    kode_mk?: SortOrder
    nama?: SortOrder
    sks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kurikulum_id?: SortOrder
  }

  export type MataKuliahAvgOrderByAggregateInput = {
    id?: SortOrder
    sks?: SortOrder
    kurikulum_id?: SortOrder
  }

  export type MataKuliahMaxOrderByAggregateInput = {
    id?: SortOrder
    kode_mk?: SortOrder
    nama?: SortOrder
    sks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kurikulum_id?: SortOrder
  }

  export type MataKuliahMinOrderByAggregateInput = {
    id?: SortOrder
    kode_mk?: SortOrder
    nama?: SortOrder
    sks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kurikulum_id?: SortOrder
  }

  export type MataKuliahSumOrderByAggregateInput = {
    id?: SortOrder
    sks?: SortOrder
    kurikulum_id?: SortOrder
  }

  export type PerformanceIndicatorListRelationFilter = {
    every?: PerformanceIndicatorWhereInput
    some?: PerformanceIndicatorWhereInput
    none?: PerformanceIndicatorWhereInput
  }

  export type PerformanceIndicatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PIGroupCountOrderByAggregateInput = {
    id?: SortOrder
    kode_grup?: SortOrder
    nama_grup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kurikulum_id?: SortOrder
  }

  export type PIGroupAvgOrderByAggregateInput = {
    id?: SortOrder
    kurikulum_id?: SortOrder
  }

  export type PIGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    kode_grup?: SortOrder
    nama_grup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kurikulum_id?: SortOrder
  }

  export type PIGroupMinOrderByAggregateInput = {
    id?: SortOrder
    kode_grup?: SortOrder
    nama_grup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kurikulum_id?: SortOrder
  }

  export type PIGroupSumOrderByAggregateInput = {
    id?: SortOrder
    kurikulum_id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PIGroupScalarRelationFilter = {
    is?: PIGroupWhereInput
    isNot?: PIGroupWhereInput
  }

  export type CPMK_PI_MapListRelationFilter = {
    every?: CPMK_PI_MapWhereInput
    some?: CPMK_PI_MapWhereInput
    none?: CPMK_PI_MapWhereInput
  }

  export type CPMK_PI_MapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PerformanceIndicatorCountOrderByAggregateInput = {
    id?: SortOrder
    kode_pi?: SortOrder
    deskripsi?: SortOrder
    is_locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pi_group_id?: SortOrder
  }

  export type PerformanceIndicatorAvgOrderByAggregateInput = {
    id?: SortOrder
    pi_group_id?: SortOrder
  }

  export type PerformanceIndicatorMaxOrderByAggregateInput = {
    id?: SortOrder
    kode_pi?: SortOrder
    deskripsi?: SortOrder
    is_locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pi_group_id?: SortOrder
  }

  export type PerformanceIndicatorMinOrderByAggregateInput = {
    id?: SortOrder
    kode_pi?: SortOrder
    deskripsi?: SortOrder
    is_locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pi_group_id?: SortOrder
  }

  export type PerformanceIndicatorSumOrderByAggregateInput = {
    id?: SortOrder
    pi_group_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CPLCountOrderByAggregateInput = {
    id?: SortOrder
    kode_cpl?: SortOrder
    deskripsi?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kurikulum_id?: SortOrder
    pi_group_id?: SortOrder
  }

  export type CPLAvgOrderByAggregateInput = {
    id?: SortOrder
    kurikulum_id?: SortOrder
    pi_group_id?: SortOrder
  }

  export type CPLMaxOrderByAggregateInput = {
    id?: SortOrder
    kode_cpl?: SortOrder
    deskripsi?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kurikulum_id?: SortOrder
    pi_group_id?: SortOrder
  }

  export type CPLMinOrderByAggregateInput = {
    id?: SortOrder
    kode_cpl?: SortOrder
    deskripsi?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kurikulum_id?: SortOrder
    pi_group_id?: SortOrder
  }

  export type CPLSumOrderByAggregateInput = {
    id?: SortOrder
    kurikulum_id?: SortOrder
    pi_group_id?: SortOrder
  }

  export type EnumSemesterFilter<$PrismaModel = never> = {
    equals?: $Enums.Semester | EnumSemesterFieldRefInput<$PrismaModel>
    in?: $Enums.Semester[] | ListEnumSemesterFieldRefInput<$PrismaModel>
    notIn?: $Enums.Semester[] | ListEnumSemesterFieldRefInput<$PrismaModel>
    not?: NestedEnumSemesterFilter<$PrismaModel> | $Enums.Semester
  }

  export type TahunAjaranTahunSemesterCompoundUniqueInput = {
    tahun: string
    semester: $Enums.Semester
  }

  export type TahunAjaranCountOrderByAggregateInput = {
    id?: SortOrder
    tahun?: SortOrder
    semester?: SortOrder
  }

  export type TahunAjaranAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TahunAjaranMaxOrderByAggregateInput = {
    id?: SortOrder
    tahun?: SortOrder
    semester?: SortOrder
  }

  export type TahunAjaranMinOrderByAggregateInput = {
    id?: SortOrder
    tahun?: SortOrder
    semester?: SortOrder
  }

  export type TahunAjaranSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumSemesterWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Semester | EnumSemesterFieldRefInput<$PrismaModel>
    in?: $Enums.Semester[] | ListEnumSemesterFieldRefInput<$PrismaModel>
    notIn?: $Enums.Semester[] | ListEnumSemesterFieldRefInput<$PrismaModel>
    not?: NestedEnumSemesterWithAggregatesFilter<$PrismaModel> | $Enums.Semester
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSemesterFilter<$PrismaModel>
    _max?: NestedEnumSemesterFilter<$PrismaModel>
  }

  export type MataKuliahScalarRelationFilter = {
    is?: MataKuliahWhereInput
    isNot?: MataKuliahWhereInput
  }

  export type TahunAjaranScalarRelationFilter = {
    is?: TahunAjaranWhereInput
    isNot?: TahunAjaranWhereInput
  }

  export type RPSListRelationFilter = {
    every?: RPSWhereInput
    some?: RPSWhereInput
    none?: RPSWhereInput
  }

  export type CPMKListRelationFilter = {
    every?: CPMKWhereInput
    some?: CPMKWhereInput
    none?: CPMKWhereInput
  }

  export type RPSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CPMKOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KelasCountOrderByAggregateInput = {
    id?: SortOrder
    nama_kelas?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mata_kuliah_id?: SortOrder
    tahun_ajaran_id?: SortOrder
  }

  export type KelasAvgOrderByAggregateInput = {
    id?: SortOrder
    mata_kuliah_id?: SortOrder
    tahun_ajaran_id?: SortOrder
  }

  export type KelasMaxOrderByAggregateInput = {
    id?: SortOrder
    nama_kelas?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mata_kuliah_id?: SortOrder
    tahun_ajaran_id?: SortOrder
  }

  export type KelasMinOrderByAggregateInput = {
    id?: SortOrder
    nama_kelas?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mata_kuliah_id?: SortOrder
    tahun_ajaran_id?: SortOrder
  }

  export type KelasSumOrderByAggregateInput = {
    id?: SortOrder
    mata_kuliah_id?: SortOrder
    tahun_ajaran_id?: SortOrder
  }

  export type KelasScalarRelationFilter = {
    is?: KelasWhereInput
    isNot?: KelasWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DosenPengampuKelas_idDosen_idCompoundUniqueInput = {
    kelas_id: number
    dosen_id: number
  }

  export type DosenPengampuCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    kelas_id?: SortOrder
    dosen_id?: SortOrder
  }

  export type DosenPengampuAvgOrderByAggregateInput = {
    id?: SortOrder
    kelas_id?: SortOrder
    dosen_id?: SortOrder
  }

  export type DosenPengampuMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    kelas_id?: SortOrder
    dosen_id?: SortOrder
  }

  export type DosenPengampuMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    kelas_id?: SortOrder
    dosen_id?: SortOrder
  }

  export type DosenPengampuSumOrderByAggregateInput = {
    id?: SortOrder
    kelas_id?: SortOrder
    dosen_id?: SortOrder
  }

  export type NilaiListRelationFilter = {
    every?: NilaiWhereInput
    some?: NilaiWhereInput
    none?: NilaiWhereInput
  }

  export type NilaiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PesertaKelasKelas_idMahasiswa_idCompoundUniqueInput = {
    kelas_id: number
    mahasiswa_id: number
  }

  export type PesertaKelasCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    kelas_id?: SortOrder
    mahasiswa_id?: SortOrder
  }

  export type PesertaKelasAvgOrderByAggregateInput = {
    id?: SortOrder
    kelas_id?: SortOrder
    mahasiswa_id?: SortOrder
  }

  export type PesertaKelasMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    kelas_id?: SortOrder
    mahasiswa_id?: SortOrder
  }

  export type PesertaKelasMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    kelas_id?: SortOrder
    mahasiswa_id?: SortOrder
  }

  export type PesertaKelasSumOrderByAggregateInput = {
    id?: SortOrder
    kelas_id?: SortOrder
    mahasiswa_id?: SortOrder
  }

  export type RPSCountOrderByAggregateInput = {
    id?: SortOrder
    file_path?: SortOrder
    is_locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kelas_id?: SortOrder
  }

  export type RPSAvgOrderByAggregateInput = {
    id?: SortOrder
    kelas_id?: SortOrder
  }

  export type RPSMaxOrderByAggregateInput = {
    id?: SortOrder
    file_path?: SortOrder
    is_locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kelas_id?: SortOrder
  }

  export type RPSMinOrderByAggregateInput = {
    id?: SortOrder
    file_path?: SortOrder
    is_locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kelas_id?: SortOrder
  }

  export type RPSSumOrderByAggregateInput = {
    id?: SortOrder
    kelas_id?: SortOrder
  }

  export type KomponenPenilaianListRelationFilter = {
    every?: KomponenPenilaianWhereInput
    some?: KomponenPenilaianWhereInput
    none?: KomponenPenilaianWhereInput
  }

  export type KomponenPenilaianOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CPMKCountOrderByAggregateInput = {
    id?: SortOrder
    kode_cpmk?: SortOrder
    is_locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kelas_id?: SortOrder
  }

  export type CPMKAvgOrderByAggregateInput = {
    id?: SortOrder
    kelas_id?: SortOrder
  }

  export type CPMKMaxOrderByAggregateInput = {
    id?: SortOrder
    kode_cpmk?: SortOrder
    is_locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kelas_id?: SortOrder
  }

  export type CPMKMinOrderByAggregateInput = {
    id?: SortOrder
    kode_cpmk?: SortOrder
    is_locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kelas_id?: SortOrder
  }

  export type CPMKSumOrderByAggregateInput = {
    id?: SortOrder
    kelas_id?: SortOrder
  }

  export type CPMKScalarRelationFilter = {
    is?: CPMKWhereInput
    isNot?: CPMKWhereInput
  }

  export type PerformanceIndicatorScalarRelationFilter = {
    is?: PerformanceIndicatorWhereInput
    isNot?: PerformanceIndicatorWhereInput
  }

  export type CPMK_PI_MapCpmk_idPi_idCompoundUniqueInput = {
    cpmk_id: number
    pi_id: number
  }

  export type CPMK_PI_MapCountOrderByAggregateInput = {
    cpmk_id?: SortOrder
    pi_id?: SortOrder
  }

  export type CPMK_PI_MapAvgOrderByAggregateInput = {
    cpmk_id?: SortOrder
    pi_id?: SortOrder
  }

  export type CPMK_PI_MapMaxOrderByAggregateInput = {
    cpmk_id?: SortOrder
    pi_id?: SortOrder
  }

  export type CPMK_PI_MapMinOrderByAggregateInput = {
    cpmk_id?: SortOrder
    pi_id?: SortOrder
  }

  export type CPMK_PI_MapSumOrderByAggregateInput = {
    cpmk_id?: SortOrder
    pi_id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type KomponenPenilaianCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    bobot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpmk_id?: SortOrder
  }

  export type KomponenPenilaianAvgOrderByAggregateInput = {
    id?: SortOrder
    bobot?: SortOrder
    cpmk_id?: SortOrder
  }

  export type KomponenPenilaianMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    bobot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpmk_id?: SortOrder
  }

  export type KomponenPenilaianMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    bobot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpmk_id?: SortOrder
  }

  export type KomponenPenilaianSumOrderByAggregateInput = {
    id?: SortOrder
    bobot?: SortOrder
    cpmk_id?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type PesertaKelasScalarRelationFilter = {
    is?: PesertaKelasWhereInput
    isNot?: PesertaKelasWhereInput
  }

  export type KomponenPenilaianScalarRelationFilter = {
    is?: KomponenPenilaianWhereInput
    isNot?: KomponenPenilaianWhereInput
  }

  export type NilaiPeserta_kelas_idKomponen_penilaian_idCompoundUniqueInput = {
    peserta_kelas_id: number
    komponen_penilaian_id: number
  }

  export type NilaiCountOrderByAggregateInput = {
    id?: SortOrder
    nilai_angka?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    peserta_kelas_id?: SortOrder
    komponen_penilaian_id?: SortOrder
  }

  export type NilaiAvgOrderByAggregateInput = {
    id?: SortOrder
    nilai_angka?: SortOrder
    peserta_kelas_id?: SortOrder
    komponen_penilaian_id?: SortOrder
  }

  export type NilaiMaxOrderByAggregateInput = {
    id?: SortOrder
    nilai_angka?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    peserta_kelas_id?: SortOrder
    komponen_penilaian_id?: SortOrder
  }

  export type NilaiMinOrderByAggregateInput = {
    id?: SortOrder
    nilai_angka?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    peserta_kelas_id?: SortOrder
    komponen_penilaian_id?: SortOrder
  }

  export type NilaiSumOrderByAggregateInput = {
    id?: SortOrder
    nilai_angka?: SortOrder
    peserta_kelas_id?: SortOrder
    komponen_penilaian_id?: SortOrder
  }

  export type UserCreateNestedManyWithoutProgramStudiInput = {
    create?: XOR<UserCreateWithoutProgramStudiInput, UserUncheckedCreateWithoutProgramStudiInput> | UserCreateWithoutProgramStudiInput[] | UserUncheckedCreateWithoutProgramStudiInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProgramStudiInput | UserCreateOrConnectWithoutProgramStudiInput[]
    createMany?: UserCreateManyProgramStudiInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type KurikulumCreateNestedManyWithoutProgramStudiInput = {
    create?: XOR<KurikulumCreateWithoutProgramStudiInput, KurikulumUncheckedCreateWithoutProgramStudiInput> | KurikulumCreateWithoutProgramStudiInput[] | KurikulumUncheckedCreateWithoutProgramStudiInput[]
    connectOrCreate?: KurikulumCreateOrConnectWithoutProgramStudiInput | KurikulumCreateOrConnectWithoutProgramStudiInput[]
    createMany?: KurikulumCreateManyProgramStudiInputEnvelope
    connect?: KurikulumWhereUniqueInput | KurikulumWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutProgramStudiInput = {
    create?: XOR<UserCreateWithoutProgramStudiInput, UserUncheckedCreateWithoutProgramStudiInput> | UserCreateWithoutProgramStudiInput[] | UserUncheckedCreateWithoutProgramStudiInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProgramStudiInput | UserCreateOrConnectWithoutProgramStudiInput[]
    createMany?: UserCreateManyProgramStudiInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type KurikulumUncheckedCreateNestedManyWithoutProgramStudiInput = {
    create?: XOR<KurikulumCreateWithoutProgramStudiInput, KurikulumUncheckedCreateWithoutProgramStudiInput> | KurikulumCreateWithoutProgramStudiInput[] | KurikulumUncheckedCreateWithoutProgramStudiInput[]
    connectOrCreate?: KurikulumCreateOrConnectWithoutProgramStudiInput | KurikulumCreateOrConnectWithoutProgramStudiInput[]
    createMany?: KurikulumCreateManyProgramStudiInputEnvelope
    connect?: KurikulumWhereUniqueInput | KurikulumWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateManyWithoutProgramStudiNestedInput = {
    create?: XOR<UserCreateWithoutProgramStudiInput, UserUncheckedCreateWithoutProgramStudiInput> | UserCreateWithoutProgramStudiInput[] | UserUncheckedCreateWithoutProgramStudiInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProgramStudiInput | UserCreateOrConnectWithoutProgramStudiInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProgramStudiInput | UserUpsertWithWhereUniqueWithoutProgramStudiInput[]
    createMany?: UserCreateManyProgramStudiInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProgramStudiInput | UserUpdateWithWhereUniqueWithoutProgramStudiInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProgramStudiInput | UserUpdateManyWithWhereWithoutProgramStudiInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type KurikulumUpdateManyWithoutProgramStudiNestedInput = {
    create?: XOR<KurikulumCreateWithoutProgramStudiInput, KurikulumUncheckedCreateWithoutProgramStudiInput> | KurikulumCreateWithoutProgramStudiInput[] | KurikulumUncheckedCreateWithoutProgramStudiInput[]
    connectOrCreate?: KurikulumCreateOrConnectWithoutProgramStudiInput | KurikulumCreateOrConnectWithoutProgramStudiInput[]
    upsert?: KurikulumUpsertWithWhereUniqueWithoutProgramStudiInput | KurikulumUpsertWithWhereUniqueWithoutProgramStudiInput[]
    createMany?: KurikulumCreateManyProgramStudiInputEnvelope
    set?: KurikulumWhereUniqueInput | KurikulumWhereUniqueInput[]
    disconnect?: KurikulumWhereUniqueInput | KurikulumWhereUniqueInput[]
    delete?: KurikulumWhereUniqueInput | KurikulumWhereUniqueInput[]
    connect?: KurikulumWhereUniqueInput | KurikulumWhereUniqueInput[]
    update?: KurikulumUpdateWithWhereUniqueWithoutProgramStudiInput | KurikulumUpdateWithWhereUniqueWithoutProgramStudiInput[]
    updateMany?: KurikulumUpdateManyWithWhereWithoutProgramStudiInput | KurikulumUpdateManyWithWhereWithoutProgramStudiInput[]
    deleteMany?: KurikulumScalarWhereInput | KurikulumScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutProgramStudiNestedInput = {
    create?: XOR<UserCreateWithoutProgramStudiInput, UserUncheckedCreateWithoutProgramStudiInput> | UserCreateWithoutProgramStudiInput[] | UserUncheckedCreateWithoutProgramStudiInput[]
    connectOrCreate?: UserCreateOrConnectWithoutProgramStudiInput | UserCreateOrConnectWithoutProgramStudiInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutProgramStudiInput | UserUpsertWithWhereUniqueWithoutProgramStudiInput[]
    createMany?: UserCreateManyProgramStudiInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutProgramStudiInput | UserUpdateWithWhereUniqueWithoutProgramStudiInput[]
    updateMany?: UserUpdateManyWithWhereWithoutProgramStudiInput | UserUpdateManyWithWhereWithoutProgramStudiInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type KurikulumUncheckedUpdateManyWithoutProgramStudiNestedInput = {
    create?: XOR<KurikulumCreateWithoutProgramStudiInput, KurikulumUncheckedCreateWithoutProgramStudiInput> | KurikulumCreateWithoutProgramStudiInput[] | KurikulumUncheckedCreateWithoutProgramStudiInput[]
    connectOrCreate?: KurikulumCreateOrConnectWithoutProgramStudiInput | KurikulumCreateOrConnectWithoutProgramStudiInput[]
    upsert?: KurikulumUpsertWithWhereUniqueWithoutProgramStudiInput | KurikulumUpsertWithWhereUniqueWithoutProgramStudiInput[]
    createMany?: KurikulumCreateManyProgramStudiInputEnvelope
    set?: KurikulumWhereUniqueInput | KurikulumWhereUniqueInput[]
    disconnect?: KurikulumWhereUniqueInput | KurikulumWhereUniqueInput[]
    delete?: KurikulumWhereUniqueInput | KurikulumWhereUniqueInput[]
    connect?: KurikulumWhereUniqueInput | KurikulumWhereUniqueInput[]
    update?: KurikulumUpdateWithWhereUniqueWithoutProgramStudiInput | KurikulumUpdateWithWhereUniqueWithoutProgramStudiInput[]
    updateMany?: KurikulumUpdateManyWithWhereWithoutProgramStudiInput | KurikulumUpdateManyWithWhereWithoutProgramStudiInput[]
    deleteMany?: KurikulumScalarWhereInput | KurikulumScalarWhereInput[]
  }

  export type ProgramStudiCreateNestedOneWithoutUsersInput = {
    create?: XOR<ProgramStudiCreateWithoutUsersInput, ProgramStudiUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ProgramStudiCreateOrConnectWithoutUsersInput
    connect?: ProgramStudiWhereUniqueInput
  }

  export type DosenPengampuCreateNestedManyWithoutDosenInput = {
    create?: XOR<DosenPengampuCreateWithoutDosenInput, DosenPengampuUncheckedCreateWithoutDosenInput> | DosenPengampuCreateWithoutDosenInput[] | DosenPengampuUncheckedCreateWithoutDosenInput[]
    connectOrCreate?: DosenPengampuCreateOrConnectWithoutDosenInput | DosenPengampuCreateOrConnectWithoutDosenInput[]
    createMany?: DosenPengampuCreateManyDosenInputEnvelope
    connect?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
  }

  export type PesertaKelasCreateNestedManyWithoutMahasiswaInput = {
    create?: XOR<PesertaKelasCreateWithoutMahasiswaInput, PesertaKelasUncheckedCreateWithoutMahasiswaInput> | PesertaKelasCreateWithoutMahasiswaInput[] | PesertaKelasUncheckedCreateWithoutMahasiswaInput[]
    connectOrCreate?: PesertaKelasCreateOrConnectWithoutMahasiswaInput | PesertaKelasCreateOrConnectWithoutMahasiswaInput[]
    createMany?: PesertaKelasCreateManyMahasiswaInputEnvelope
    connect?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
  }

  export type DosenPengampuUncheckedCreateNestedManyWithoutDosenInput = {
    create?: XOR<DosenPengampuCreateWithoutDosenInput, DosenPengampuUncheckedCreateWithoutDosenInput> | DosenPengampuCreateWithoutDosenInput[] | DosenPengampuUncheckedCreateWithoutDosenInput[]
    connectOrCreate?: DosenPengampuCreateOrConnectWithoutDosenInput | DosenPengampuCreateOrConnectWithoutDosenInput[]
    createMany?: DosenPengampuCreateManyDosenInputEnvelope
    connect?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
  }

  export type PesertaKelasUncheckedCreateNestedManyWithoutMahasiswaInput = {
    create?: XOR<PesertaKelasCreateWithoutMahasiswaInput, PesertaKelasUncheckedCreateWithoutMahasiswaInput> | PesertaKelasCreateWithoutMahasiswaInput[] | PesertaKelasUncheckedCreateWithoutMahasiswaInput[]
    connectOrCreate?: PesertaKelasCreateOrConnectWithoutMahasiswaInput | PesertaKelasCreateOrConnectWithoutMahasiswaInput[]
    createMany?: PesertaKelasCreateManyMahasiswaInputEnvelope
    connect?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type ProgramStudiUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<ProgramStudiCreateWithoutUsersInput, ProgramStudiUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ProgramStudiCreateOrConnectWithoutUsersInput
    upsert?: ProgramStudiUpsertWithoutUsersInput
    connect?: ProgramStudiWhereUniqueInput
    update?: XOR<XOR<ProgramStudiUpdateToOneWithWhereWithoutUsersInput, ProgramStudiUpdateWithoutUsersInput>, ProgramStudiUncheckedUpdateWithoutUsersInput>
  }

  export type DosenPengampuUpdateManyWithoutDosenNestedInput = {
    create?: XOR<DosenPengampuCreateWithoutDosenInput, DosenPengampuUncheckedCreateWithoutDosenInput> | DosenPengampuCreateWithoutDosenInput[] | DosenPengampuUncheckedCreateWithoutDosenInput[]
    connectOrCreate?: DosenPengampuCreateOrConnectWithoutDosenInput | DosenPengampuCreateOrConnectWithoutDosenInput[]
    upsert?: DosenPengampuUpsertWithWhereUniqueWithoutDosenInput | DosenPengampuUpsertWithWhereUniqueWithoutDosenInput[]
    createMany?: DosenPengampuCreateManyDosenInputEnvelope
    set?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
    disconnect?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
    delete?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
    connect?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
    update?: DosenPengampuUpdateWithWhereUniqueWithoutDosenInput | DosenPengampuUpdateWithWhereUniqueWithoutDosenInput[]
    updateMany?: DosenPengampuUpdateManyWithWhereWithoutDosenInput | DosenPengampuUpdateManyWithWhereWithoutDosenInput[]
    deleteMany?: DosenPengampuScalarWhereInput | DosenPengampuScalarWhereInput[]
  }

  export type PesertaKelasUpdateManyWithoutMahasiswaNestedInput = {
    create?: XOR<PesertaKelasCreateWithoutMahasiswaInput, PesertaKelasUncheckedCreateWithoutMahasiswaInput> | PesertaKelasCreateWithoutMahasiswaInput[] | PesertaKelasUncheckedCreateWithoutMahasiswaInput[]
    connectOrCreate?: PesertaKelasCreateOrConnectWithoutMahasiswaInput | PesertaKelasCreateOrConnectWithoutMahasiswaInput[]
    upsert?: PesertaKelasUpsertWithWhereUniqueWithoutMahasiswaInput | PesertaKelasUpsertWithWhereUniqueWithoutMahasiswaInput[]
    createMany?: PesertaKelasCreateManyMahasiswaInputEnvelope
    set?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
    disconnect?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
    delete?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
    connect?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
    update?: PesertaKelasUpdateWithWhereUniqueWithoutMahasiswaInput | PesertaKelasUpdateWithWhereUniqueWithoutMahasiswaInput[]
    updateMany?: PesertaKelasUpdateManyWithWhereWithoutMahasiswaInput | PesertaKelasUpdateManyWithWhereWithoutMahasiswaInput[]
    deleteMany?: PesertaKelasScalarWhereInput | PesertaKelasScalarWhereInput[]
  }

  export type DosenPengampuUncheckedUpdateManyWithoutDosenNestedInput = {
    create?: XOR<DosenPengampuCreateWithoutDosenInput, DosenPengampuUncheckedCreateWithoutDosenInput> | DosenPengampuCreateWithoutDosenInput[] | DosenPengampuUncheckedCreateWithoutDosenInput[]
    connectOrCreate?: DosenPengampuCreateOrConnectWithoutDosenInput | DosenPengampuCreateOrConnectWithoutDosenInput[]
    upsert?: DosenPengampuUpsertWithWhereUniqueWithoutDosenInput | DosenPengampuUpsertWithWhereUniqueWithoutDosenInput[]
    createMany?: DosenPengampuCreateManyDosenInputEnvelope
    set?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
    disconnect?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
    delete?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
    connect?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
    update?: DosenPengampuUpdateWithWhereUniqueWithoutDosenInput | DosenPengampuUpdateWithWhereUniqueWithoutDosenInput[]
    updateMany?: DosenPengampuUpdateManyWithWhereWithoutDosenInput | DosenPengampuUpdateManyWithWhereWithoutDosenInput[]
    deleteMany?: DosenPengampuScalarWhereInput | DosenPengampuScalarWhereInput[]
  }

  export type PesertaKelasUncheckedUpdateManyWithoutMahasiswaNestedInput = {
    create?: XOR<PesertaKelasCreateWithoutMahasiswaInput, PesertaKelasUncheckedCreateWithoutMahasiswaInput> | PesertaKelasCreateWithoutMahasiswaInput[] | PesertaKelasUncheckedCreateWithoutMahasiswaInput[]
    connectOrCreate?: PesertaKelasCreateOrConnectWithoutMahasiswaInput | PesertaKelasCreateOrConnectWithoutMahasiswaInput[]
    upsert?: PesertaKelasUpsertWithWhereUniqueWithoutMahasiswaInput | PesertaKelasUpsertWithWhereUniqueWithoutMahasiswaInput[]
    createMany?: PesertaKelasCreateManyMahasiswaInputEnvelope
    set?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
    disconnect?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
    delete?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
    connect?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
    update?: PesertaKelasUpdateWithWhereUniqueWithoutMahasiswaInput | PesertaKelasUpdateWithWhereUniqueWithoutMahasiswaInput[]
    updateMany?: PesertaKelasUpdateManyWithWhereWithoutMahasiswaInput | PesertaKelasUpdateManyWithWhereWithoutMahasiswaInput[]
    deleteMany?: PesertaKelasScalarWhereInput | PesertaKelasScalarWhereInput[]
  }

  export type ProgramStudiCreateNestedOneWithoutKurikulumInput = {
    create?: XOR<ProgramStudiCreateWithoutKurikulumInput, ProgramStudiUncheckedCreateWithoutKurikulumInput>
    connectOrCreate?: ProgramStudiCreateOrConnectWithoutKurikulumInput
    connect?: ProgramStudiWhereUniqueInput
  }

  export type MataKuliahCreateNestedManyWithoutKurikulumInput = {
    create?: XOR<MataKuliahCreateWithoutKurikulumInput, MataKuliahUncheckedCreateWithoutKurikulumInput> | MataKuliahCreateWithoutKurikulumInput[] | MataKuliahUncheckedCreateWithoutKurikulumInput[]
    connectOrCreate?: MataKuliahCreateOrConnectWithoutKurikulumInput | MataKuliahCreateOrConnectWithoutKurikulumInput[]
    createMany?: MataKuliahCreateManyKurikulumInputEnvelope
    connect?: MataKuliahWhereUniqueInput | MataKuliahWhereUniqueInput[]
  }

  export type CPLCreateNestedManyWithoutKurikulumInput = {
    create?: XOR<CPLCreateWithoutKurikulumInput, CPLUncheckedCreateWithoutKurikulumInput> | CPLCreateWithoutKurikulumInput[] | CPLUncheckedCreateWithoutKurikulumInput[]
    connectOrCreate?: CPLCreateOrConnectWithoutKurikulumInput | CPLCreateOrConnectWithoutKurikulumInput[]
    createMany?: CPLCreateManyKurikulumInputEnvelope
    connect?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
  }

  export type PIGroupCreateNestedManyWithoutKurikulumInput = {
    create?: XOR<PIGroupCreateWithoutKurikulumInput, PIGroupUncheckedCreateWithoutKurikulumInput> | PIGroupCreateWithoutKurikulumInput[] | PIGroupUncheckedCreateWithoutKurikulumInput[]
    connectOrCreate?: PIGroupCreateOrConnectWithoutKurikulumInput | PIGroupCreateOrConnectWithoutKurikulumInput[]
    createMany?: PIGroupCreateManyKurikulumInputEnvelope
    connect?: PIGroupWhereUniqueInput | PIGroupWhereUniqueInput[]
  }

  export type MataKuliahUncheckedCreateNestedManyWithoutKurikulumInput = {
    create?: XOR<MataKuliahCreateWithoutKurikulumInput, MataKuliahUncheckedCreateWithoutKurikulumInput> | MataKuliahCreateWithoutKurikulumInput[] | MataKuliahUncheckedCreateWithoutKurikulumInput[]
    connectOrCreate?: MataKuliahCreateOrConnectWithoutKurikulumInput | MataKuliahCreateOrConnectWithoutKurikulumInput[]
    createMany?: MataKuliahCreateManyKurikulumInputEnvelope
    connect?: MataKuliahWhereUniqueInput | MataKuliahWhereUniqueInput[]
  }

  export type CPLUncheckedCreateNestedManyWithoutKurikulumInput = {
    create?: XOR<CPLCreateWithoutKurikulumInput, CPLUncheckedCreateWithoutKurikulumInput> | CPLCreateWithoutKurikulumInput[] | CPLUncheckedCreateWithoutKurikulumInput[]
    connectOrCreate?: CPLCreateOrConnectWithoutKurikulumInput | CPLCreateOrConnectWithoutKurikulumInput[]
    createMany?: CPLCreateManyKurikulumInputEnvelope
    connect?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
  }

  export type PIGroupUncheckedCreateNestedManyWithoutKurikulumInput = {
    create?: XOR<PIGroupCreateWithoutKurikulumInput, PIGroupUncheckedCreateWithoutKurikulumInput> | PIGroupCreateWithoutKurikulumInput[] | PIGroupUncheckedCreateWithoutKurikulumInput[]
    connectOrCreate?: PIGroupCreateOrConnectWithoutKurikulumInput | PIGroupCreateOrConnectWithoutKurikulumInput[]
    createMany?: PIGroupCreateManyKurikulumInputEnvelope
    connect?: PIGroupWhereUniqueInput | PIGroupWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProgramStudiUpdateOneRequiredWithoutKurikulumNestedInput = {
    create?: XOR<ProgramStudiCreateWithoutKurikulumInput, ProgramStudiUncheckedCreateWithoutKurikulumInput>
    connectOrCreate?: ProgramStudiCreateOrConnectWithoutKurikulumInput
    upsert?: ProgramStudiUpsertWithoutKurikulumInput
    connect?: ProgramStudiWhereUniqueInput
    update?: XOR<XOR<ProgramStudiUpdateToOneWithWhereWithoutKurikulumInput, ProgramStudiUpdateWithoutKurikulumInput>, ProgramStudiUncheckedUpdateWithoutKurikulumInput>
  }

  export type MataKuliahUpdateManyWithoutKurikulumNestedInput = {
    create?: XOR<MataKuliahCreateWithoutKurikulumInput, MataKuliahUncheckedCreateWithoutKurikulumInput> | MataKuliahCreateWithoutKurikulumInput[] | MataKuliahUncheckedCreateWithoutKurikulumInput[]
    connectOrCreate?: MataKuliahCreateOrConnectWithoutKurikulumInput | MataKuliahCreateOrConnectWithoutKurikulumInput[]
    upsert?: MataKuliahUpsertWithWhereUniqueWithoutKurikulumInput | MataKuliahUpsertWithWhereUniqueWithoutKurikulumInput[]
    createMany?: MataKuliahCreateManyKurikulumInputEnvelope
    set?: MataKuliahWhereUniqueInput | MataKuliahWhereUniqueInput[]
    disconnect?: MataKuliahWhereUniqueInput | MataKuliahWhereUniqueInput[]
    delete?: MataKuliahWhereUniqueInput | MataKuliahWhereUniqueInput[]
    connect?: MataKuliahWhereUniqueInput | MataKuliahWhereUniqueInput[]
    update?: MataKuliahUpdateWithWhereUniqueWithoutKurikulumInput | MataKuliahUpdateWithWhereUniqueWithoutKurikulumInput[]
    updateMany?: MataKuliahUpdateManyWithWhereWithoutKurikulumInput | MataKuliahUpdateManyWithWhereWithoutKurikulumInput[]
    deleteMany?: MataKuliahScalarWhereInput | MataKuliahScalarWhereInput[]
  }

  export type CPLUpdateManyWithoutKurikulumNestedInput = {
    create?: XOR<CPLCreateWithoutKurikulumInput, CPLUncheckedCreateWithoutKurikulumInput> | CPLCreateWithoutKurikulumInput[] | CPLUncheckedCreateWithoutKurikulumInput[]
    connectOrCreate?: CPLCreateOrConnectWithoutKurikulumInput | CPLCreateOrConnectWithoutKurikulumInput[]
    upsert?: CPLUpsertWithWhereUniqueWithoutKurikulumInput | CPLUpsertWithWhereUniqueWithoutKurikulumInput[]
    createMany?: CPLCreateManyKurikulumInputEnvelope
    set?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
    disconnect?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
    delete?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
    connect?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
    update?: CPLUpdateWithWhereUniqueWithoutKurikulumInput | CPLUpdateWithWhereUniqueWithoutKurikulumInput[]
    updateMany?: CPLUpdateManyWithWhereWithoutKurikulumInput | CPLUpdateManyWithWhereWithoutKurikulumInput[]
    deleteMany?: CPLScalarWhereInput | CPLScalarWhereInput[]
  }

  export type PIGroupUpdateManyWithoutKurikulumNestedInput = {
    create?: XOR<PIGroupCreateWithoutKurikulumInput, PIGroupUncheckedCreateWithoutKurikulumInput> | PIGroupCreateWithoutKurikulumInput[] | PIGroupUncheckedCreateWithoutKurikulumInput[]
    connectOrCreate?: PIGroupCreateOrConnectWithoutKurikulumInput | PIGroupCreateOrConnectWithoutKurikulumInput[]
    upsert?: PIGroupUpsertWithWhereUniqueWithoutKurikulumInput | PIGroupUpsertWithWhereUniqueWithoutKurikulumInput[]
    createMany?: PIGroupCreateManyKurikulumInputEnvelope
    set?: PIGroupWhereUniqueInput | PIGroupWhereUniqueInput[]
    disconnect?: PIGroupWhereUniqueInput | PIGroupWhereUniqueInput[]
    delete?: PIGroupWhereUniqueInput | PIGroupWhereUniqueInput[]
    connect?: PIGroupWhereUniqueInput | PIGroupWhereUniqueInput[]
    update?: PIGroupUpdateWithWhereUniqueWithoutKurikulumInput | PIGroupUpdateWithWhereUniqueWithoutKurikulumInput[]
    updateMany?: PIGroupUpdateManyWithWhereWithoutKurikulumInput | PIGroupUpdateManyWithWhereWithoutKurikulumInput[]
    deleteMany?: PIGroupScalarWhereInput | PIGroupScalarWhereInput[]
  }

  export type MataKuliahUncheckedUpdateManyWithoutKurikulumNestedInput = {
    create?: XOR<MataKuliahCreateWithoutKurikulumInput, MataKuliahUncheckedCreateWithoutKurikulumInput> | MataKuliahCreateWithoutKurikulumInput[] | MataKuliahUncheckedCreateWithoutKurikulumInput[]
    connectOrCreate?: MataKuliahCreateOrConnectWithoutKurikulumInput | MataKuliahCreateOrConnectWithoutKurikulumInput[]
    upsert?: MataKuliahUpsertWithWhereUniqueWithoutKurikulumInput | MataKuliahUpsertWithWhereUniqueWithoutKurikulumInput[]
    createMany?: MataKuliahCreateManyKurikulumInputEnvelope
    set?: MataKuliahWhereUniqueInput | MataKuliahWhereUniqueInput[]
    disconnect?: MataKuliahWhereUniqueInput | MataKuliahWhereUniqueInput[]
    delete?: MataKuliahWhereUniqueInput | MataKuliahWhereUniqueInput[]
    connect?: MataKuliahWhereUniqueInput | MataKuliahWhereUniqueInput[]
    update?: MataKuliahUpdateWithWhereUniqueWithoutKurikulumInput | MataKuliahUpdateWithWhereUniqueWithoutKurikulumInput[]
    updateMany?: MataKuliahUpdateManyWithWhereWithoutKurikulumInput | MataKuliahUpdateManyWithWhereWithoutKurikulumInput[]
    deleteMany?: MataKuliahScalarWhereInput | MataKuliahScalarWhereInput[]
  }

  export type CPLUncheckedUpdateManyWithoutKurikulumNestedInput = {
    create?: XOR<CPLCreateWithoutKurikulumInput, CPLUncheckedCreateWithoutKurikulumInput> | CPLCreateWithoutKurikulumInput[] | CPLUncheckedCreateWithoutKurikulumInput[]
    connectOrCreate?: CPLCreateOrConnectWithoutKurikulumInput | CPLCreateOrConnectWithoutKurikulumInput[]
    upsert?: CPLUpsertWithWhereUniqueWithoutKurikulumInput | CPLUpsertWithWhereUniqueWithoutKurikulumInput[]
    createMany?: CPLCreateManyKurikulumInputEnvelope
    set?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
    disconnect?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
    delete?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
    connect?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
    update?: CPLUpdateWithWhereUniqueWithoutKurikulumInput | CPLUpdateWithWhereUniqueWithoutKurikulumInput[]
    updateMany?: CPLUpdateManyWithWhereWithoutKurikulumInput | CPLUpdateManyWithWhereWithoutKurikulumInput[]
    deleteMany?: CPLScalarWhereInput | CPLScalarWhereInput[]
  }

  export type PIGroupUncheckedUpdateManyWithoutKurikulumNestedInput = {
    create?: XOR<PIGroupCreateWithoutKurikulumInput, PIGroupUncheckedCreateWithoutKurikulumInput> | PIGroupCreateWithoutKurikulumInput[] | PIGroupUncheckedCreateWithoutKurikulumInput[]
    connectOrCreate?: PIGroupCreateOrConnectWithoutKurikulumInput | PIGroupCreateOrConnectWithoutKurikulumInput[]
    upsert?: PIGroupUpsertWithWhereUniqueWithoutKurikulumInput | PIGroupUpsertWithWhereUniqueWithoutKurikulumInput[]
    createMany?: PIGroupCreateManyKurikulumInputEnvelope
    set?: PIGroupWhereUniqueInput | PIGroupWhereUniqueInput[]
    disconnect?: PIGroupWhereUniqueInput | PIGroupWhereUniqueInput[]
    delete?: PIGroupWhereUniqueInput | PIGroupWhereUniqueInput[]
    connect?: PIGroupWhereUniqueInput | PIGroupWhereUniqueInput[]
    update?: PIGroupUpdateWithWhereUniqueWithoutKurikulumInput | PIGroupUpdateWithWhereUniqueWithoutKurikulumInput[]
    updateMany?: PIGroupUpdateManyWithWhereWithoutKurikulumInput | PIGroupUpdateManyWithWhereWithoutKurikulumInput[]
    deleteMany?: PIGroupScalarWhereInput | PIGroupScalarWhereInput[]
  }

  export type KurikulumCreateNestedOneWithoutMataKuliahInput = {
    create?: XOR<KurikulumCreateWithoutMataKuliahInput, KurikulumUncheckedCreateWithoutMataKuliahInput>
    connectOrCreate?: KurikulumCreateOrConnectWithoutMataKuliahInput
    connect?: KurikulumWhereUniqueInput
  }

  export type KelasCreateNestedManyWithoutMataKuliahInput = {
    create?: XOR<KelasCreateWithoutMataKuliahInput, KelasUncheckedCreateWithoutMataKuliahInput> | KelasCreateWithoutMataKuliahInput[] | KelasUncheckedCreateWithoutMataKuliahInput[]
    connectOrCreate?: KelasCreateOrConnectWithoutMataKuliahInput | KelasCreateOrConnectWithoutMataKuliahInput[]
    createMany?: KelasCreateManyMataKuliahInputEnvelope
    connect?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
  }

  export type KelasUncheckedCreateNestedManyWithoutMataKuliahInput = {
    create?: XOR<KelasCreateWithoutMataKuliahInput, KelasUncheckedCreateWithoutMataKuliahInput> | KelasCreateWithoutMataKuliahInput[] | KelasUncheckedCreateWithoutMataKuliahInput[]
    connectOrCreate?: KelasCreateOrConnectWithoutMataKuliahInput | KelasCreateOrConnectWithoutMataKuliahInput[]
    createMany?: KelasCreateManyMataKuliahInputEnvelope
    connect?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
  }

  export type KurikulumUpdateOneRequiredWithoutMataKuliahNestedInput = {
    create?: XOR<KurikulumCreateWithoutMataKuliahInput, KurikulumUncheckedCreateWithoutMataKuliahInput>
    connectOrCreate?: KurikulumCreateOrConnectWithoutMataKuliahInput
    upsert?: KurikulumUpsertWithoutMataKuliahInput
    connect?: KurikulumWhereUniqueInput
    update?: XOR<XOR<KurikulumUpdateToOneWithWhereWithoutMataKuliahInput, KurikulumUpdateWithoutMataKuliahInput>, KurikulumUncheckedUpdateWithoutMataKuliahInput>
  }

  export type KelasUpdateManyWithoutMataKuliahNestedInput = {
    create?: XOR<KelasCreateWithoutMataKuliahInput, KelasUncheckedCreateWithoutMataKuliahInput> | KelasCreateWithoutMataKuliahInput[] | KelasUncheckedCreateWithoutMataKuliahInput[]
    connectOrCreate?: KelasCreateOrConnectWithoutMataKuliahInput | KelasCreateOrConnectWithoutMataKuliahInput[]
    upsert?: KelasUpsertWithWhereUniqueWithoutMataKuliahInput | KelasUpsertWithWhereUniqueWithoutMataKuliahInput[]
    createMany?: KelasCreateManyMataKuliahInputEnvelope
    set?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
    disconnect?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
    delete?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
    connect?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
    update?: KelasUpdateWithWhereUniqueWithoutMataKuliahInput | KelasUpdateWithWhereUniqueWithoutMataKuliahInput[]
    updateMany?: KelasUpdateManyWithWhereWithoutMataKuliahInput | KelasUpdateManyWithWhereWithoutMataKuliahInput[]
    deleteMany?: KelasScalarWhereInput | KelasScalarWhereInput[]
  }

  export type KelasUncheckedUpdateManyWithoutMataKuliahNestedInput = {
    create?: XOR<KelasCreateWithoutMataKuliahInput, KelasUncheckedCreateWithoutMataKuliahInput> | KelasCreateWithoutMataKuliahInput[] | KelasUncheckedCreateWithoutMataKuliahInput[]
    connectOrCreate?: KelasCreateOrConnectWithoutMataKuliahInput | KelasCreateOrConnectWithoutMataKuliahInput[]
    upsert?: KelasUpsertWithWhereUniqueWithoutMataKuliahInput | KelasUpsertWithWhereUniqueWithoutMataKuliahInput[]
    createMany?: KelasCreateManyMataKuliahInputEnvelope
    set?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
    disconnect?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
    delete?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
    connect?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
    update?: KelasUpdateWithWhereUniqueWithoutMataKuliahInput | KelasUpdateWithWhereUniqueWithoutMataKuliahInput[]
    updateMany?: KelasUpdateManyWithWhereWithoutMataKuliahInput | KelasUpdateManyWithWhereWithoutMataKuliahInput[]
    deleteMany?: KelasScalarWhereInput | KelasScalarWhereInput[]
  }

  export type KurikulumCreateNestedOneWithoutPiGroupsInput = {
    create?: XOR<KurikulumCreateWithoutPiGroupsInput, KurikulumUncheckedCreateWithoutPiGroupsInput>
    connectOrCreate?: KurikulumCreateOrConnectWithoutPiGroupsInput
    connect?: KurikulumWhereUniqueInput
  }

  export type PerformanceIndicatorCreateNestedManyWithoutPiGroupInput = {
    create?: XOR<PerformanceIndicatorCreateWithoutPiGroupInput, PerformanceIndicatorUncheckedCreateWithoutPiGroupInput> | PerformanceIndicatorCreateWithoutPiGroupInput[] | PerformanceIndicatorUncheckedCreateWithoutPiGroupInput[]
    connectOrCreate?: PerformanceIndicatorCreateOrConnectWithoutPiGroupInput | PerformanceIndicatorCreateOrConnectWithoutPiGroupInput[]
    createMany?: PerformanceIndicatorCreateManyPiGroupInputEnvelope
    connect?: PerformanceIndicatorWhereUniqueInput | PerformanceIndicatorWhereUniqueInput[]
  }

  export type CPLCreateNestedManyWithoutPiGroupInput = {
    create?: XOR<CPLCreateWithoutPiGroupInput, CPLUncheckedCreateWithoutPiGroupInput> | CPLCreateWithoutPiGroupInput[] | CPLUncheckedCreateWithoutPiGroupInput[]
    connectOrCreate?: CPLCreateOrConnectWithoutPiGroupInput | CPLCreateOrConnectWithoutPiGroupInput[]
    createMany?: CPLCreateManyPiGroupInputEnvelope
    connect?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
  }

  export type PerformanceIndicatorUncheckedCreateNestedManyWithoutPiGroupInput = {
    create?: XOR<PerformanceIndicatorCreateWithoutPiGroupInput, PerformanceIndicatorUncheckedCreateWithoutPiGroupInput> | PerformanceIndicatorCreateWithoutPiGroupInput[] | PerformanceIndicatorUncheckedCreateWithoutPiGroupInput[]
    connectOrCreate?: PerformanceIndicatorCreateOrConnectWithoutPiGroupInput | PerformanceIndicatorCreateOrConnectWithoutPiGroupInput[]
    createMany?: PerformanceIndicatorCreateManyPiGroupInputEnvelope
    connect?: PerformanceIndicatorWhereUniqueInput | PerformanceIndicatorWhereUniqueInput[]
  }

  export type CPLUncheckedCreateNestedManyWithoutPiGroupInput = {
    create?: XOR<CPLCreateWithoutPiGroupInput, CPLUncheckedCreateWithoutPiGroupInput> | CPLCreateWithoutPiGroupInput[] | CPLUncheckedCreateWithoutPiGroupInput[]
    connectOrCreate?: CPLCreateOrConnectWithoutPiGroupInput | CPLCreateOrConnectWithoutPiGroupInput[]
    createMany?: CPLCreateManyPiGroupInputEnvelope
    connect?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
  }

  export type KurikulumUpdateOneRequiredWithoutPiGroupsNestedInput = {
    create?: XOR<KurikulumCreateWithoutPiGroupsInput, KurikulumUncheckedCreateWithoutPiGroupsInput>
    connectOrCreate?: KurikulumCreateOrConnectWithoutPiGroupsInput
    upsert?: KurikulumUpsertWithoutPiGroupsInput
    connect?: KurikulumWhereUniqueInput
    update?: XOR<XOR<KurikulumUpdateToOneWithWhereWithoutPiGroupsInput, KurikulumUpdateWithoutPiGroupsInput>, KurikulumUncheckedUpdateWithoutPiGroupsInput>
  }

  export type PerformanceIndicatorUpdateManyWithoutPiGroupNestedInput = {
    create?: XOR<PerformanceIndicatorCreateWithoutPiGroupInput, PerformanceIndicatorUncheckedCreateWithoutPiGroupInput> | PerformanceIndicatorCreateWithoutPiGroupInput[] | PerformanceIndicatorUncheckedCreateWithoutPiGroupInput[]
    connectOrCreate?: PerformanceIndicatorCreateOrConnectWithoutPiGroupInput | PerformanceIndicatorCreateOrConnectWithoutPiGroupInput[]
    upsert?: PerformanceIndicatorUpsertWithWhereUniqueWithoutPiGroupInput | PerformanceIndicatorUpsertWithWhereUniqueWithoutPiGroupInput[]
    createMany?: PerformanceIndicatorCreateManyPiGroupInputEnvelope
    set?: PerformanceIndicatorWhereUniqueInput | PerformanceIndicatorWhereUniqueInput[]
    disconnect?: PerformanceIndicatorWhereUniqueInput | PerformanceIndicatorWhereUniqueInput[]
    delete?: PerformanceIndicatorWhereUniqueInput | PerformanceIndicatorWhereUniqueInput[]
    connect?: PerformanceIndicatorWhereUniqueInput | PerformanceIndicatorWhereUniqueInput[]
    update?: PerformanceIndicatorUpdateWithWhereUniqueWithoutPiGroupInput | PerformanceIndicatorUpdateWithWhereUniqueWithoutPiGroupInput[]
    updateMany?: PerformanceIndicatorUpdateManyWithWhereWithoutPiGroupInput | PerformanceIndicatorUpdateManyWithWhereWithoutPiGroupInput[]
    deleteMany?: PerformanceIndicatorScalarWhereInput | PerformanceIndicatorScalarWhereInput[]
  }

  export type CPLUpdateManyWithoutPiGroupNestedInput = {
    create?: XOR<CPLCreateWithoutPiGroupInput, CPLUncheckedCreateWithoutPiGroupInput> | CPLCreateWithoutPiGroupInput[] | CPLUncheckedCreateWithoutPiGroupInput[]
    connectOrCreate?: CPLCreateOrConnectWithoutPiGroupInput | CPLCreateOrConnectWithoutPiGroupInput[]
    upsert?: CPLUpsertWithWhereUniqueWithoutPiGroupInput | CPLUpsertWithWhereUniqueWithoutPiGroupInput[]
    createMany?: CPLCreateManyPiGroupInputEnvelope
    set?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
    disconnect?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
    delete?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
    connect?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
    update?: CPLUpdateWithWhereUniqueWithoutPiGroupInput | CPLUpdateWithWhereUniqueWithoutPiGroupInput[]
    updateMany?: CPLUpdateManyWithWhereWithoutPiGroupInput | CPLUpdateManyWithWhereWithoutPiGroupInput[]
    deleteMany?: CPLScalarWhereInput | CPLScalarWhereInput[]
  }

  export type PerformanceIndicatorUncheckedUpdateManyWithoutPiGroupNestedInput = {
    create?: XOR<PerformanceIndicatorCreateWithoutPiGroupInput, PerformanceIndicatorUncheckedCreateWithoutPiGroupInput> | PerformanceIndicatorCreateWithoutPiGroupInput[] | PerformanceIndicatorUncheckedCreateWithoutPiGroupInput[]
    connectOrCreate?: PerformanceIndicatorCreateOrConnectWithoutPiGroupInput | PerformanceIndicatorCreateOrConnectWithoutPiGroupInput[]
    upsert?: PerformanceIndicatorUpsertWithWhereUniqueWithoutPiGroupInput | PerformanceIndicatorUpsertWithWhereUniqueWithoutPiGroupInput[]
    createMany?: PerformanceIndicatorCreateManyPiGroupInputEnvelope
    set?: PerformanceIndicatorWhereUniqueInput | PerformanceIndicatorWhereUniqueInput[]
    disconnect?: PerformanceIndicatorWhereUniqueInput | PerformanceIndicatorWhereUniqueInput[]
    delete?: PerformanceIndicatorWhereUniqueInput | PerformanceIndicatorWhereUniqueInput[]
    connect?: PerformanceIndicatorWhereUniqueInput | PerformanceIndicatorWhereUniqueInput[]
    update?: PerformanceIndicatorUpdateWithWhereUniqueWithoutPiGroupInput | PerformanceIndicatorUpdateWithWhereUniqueWithoutPiGroupInput[]
    updateMany?: PerformanceIndicatorUpdateManyWithWhereWithoutPiGroupInput | PerformanceIndicatorUpdateManyWithWhereWithoutPiGroupInput[]
    deleteMany?: PerformanceIndicatorScalarWhereInput | PerformanceIndicatorScalarWhereInput[]
  }

  export type CPLUncheckedUpdateManyWithoutPiGroupNestedInput = {
    create?: XOR<CPLCreateWithoutPiGroupInput, CPLUncheckedCreateWithoutPiGroupInput> | CPLCreateWithoutPiGroupInput[] | CPLUncheckedCreateWithoutPiGroupInput[]
    connectOrCreate?: CPLCreateOrConnectWithoutPiGroupInput | CPLCreateOrConnectWithoutPiGroupInput[]
    upsert?: CPLUpsertWithWhereUniqueWithoutPiGroupInput | CPLUpsertWithWhereUniqueWithoutPiGroupInput[]
    createMany?: CPLCreateManyPiGroupInputEnvelope
    set?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
    disconnect?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
    delete?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
    connect?: CPLWhereUniqueInput | CPLWhereUniqueInput[]
    update?: CPLUpdateWithWhereUniqueWithoutPiGroupInput | CPLUpdateWithWhereUniqueWithoutPiGroupInput[]
    updateMany?: CPLUpdateManyWithWhereWithoutPiGroupInput | CPLUpdateManyWithWhereWithoutPiGroupInput[]
    deleteMany?: CPLScalarWhereInput | CPLScalarWhereInput[]
  }

  export type PIGroupCreateNestedOneWithoutIndicatorsInput = {
    create?: XOR<PIGroupCreateWithoutIndicatorsInput, PIGroupUncheckedCreateWithoutIndicatorsInput>
    connectOrCreate?: PIGroupCreateOrConnectWithoutIndicatorsInput
    connect?: PIGroupWhereUniqueInput
  }

  export type CPMK_PI_MapCreateNestedManyWithoutPiInput = {
    create?: XOR<CPMK_PI_MapCreateWithoutPiInput, CPMK_PI_MapUncheckedCreateWithoutPiInput> | CPMK_PI_MapCreateWithoutPiInput[] | CPMK_PI_MapUncheckedCreateWithoutPiInput[]
    connectOrCreate?: CPMK_PI_MapCreateOrConnectWithoutPiInput | CPMK_PI_MapCreateOrConnectWithoutPiInput[]
    createMany?: CPMK_PI_MapCreateManyPiInputEnvelope
    connect?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
  }

  export type CPMK_PI_MapUncheckedCreateNestedManyWithoutPiInput = {
    create?: XOR<CPMK_PI_MapCreateWithoutPiInput, CPMK_PI_MapUncheckedCreateWithoutPiInput> | CPMK_PI_MapCreateWithoutPiInput[] | CPMK_PI_MapUncheckedCreateWithoutPiInput[]
    connectOrCreate?: CPMK_PI_MapCreateOrConnectWithoutPiInput | CPMK_PI_MapCreateOrConnectWithoutPiInput[]
    createMany?: CPMK_PI_MapCreateManyPiInputEnvelope
    connect?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PIGroupUpdateOneRequiredWithoutIndicatorsNestedInput = {
    create?: XOR<PIGroupCreateWithoutIndicatorsInput, PIGroupUncheckedCreateWithoutIndicatorsInput>
    connectOrCreate?: PIGroupCreateOrConnectWithoutIndicatorsInput
    upsert?: PIGroupUpsertWithoutIndicatorsInput
    connect?: PIGroupWhereUniqueInput
    update?: XOR<XOR<PIGroupUpdateToOneWithWhereWithoutIndicatorsInput, PIGroupUpdateWithoutIndicatorsInput>, PIGroupUncheckedUpdateWithoutIndicatorsInput>
  }

  export type CPMK_PI_MapUpdateManyWithoutPiNestedInput = {
    create?: XOR<CPMK_PI_MapCreateWithoutPiInput, CPMK_PI_MapUncheckedCreateWithoutPiInput> | CPMK_PI_MapCreateWithoutPiInput[] | CPMK_PI_MapUncheckedCreateWithoutPiInput[]
    connectOrCreate?: CPMK_PI_MapCreateOrConnectWithoutPiInput | CPMK_PI_MapCreateOrConnectWithoutPiInput[]
    upsert?: CPMK_PI_MapUpsertWithWhereUniqueWithoutPiInput | CPMK_PI_MapUpsertWithWhereUniqueWithoutPiInput[]
    createMany?: CPMK_PI_MapCreateManyPiInputEnvelope
    set?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
    disconnect?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
    delete?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
    connect?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
    update?: CPMK_PI_MapUpdateWithWhereUniqueWithoutPiInput | CPMK_PI_MapUpdateWithWhereUniqueWithoutPiInput[]
    updateMany?: CPMK_PI_MapUpdateManyWithWhereWithoutPiInput | CPMK_PI_MapUpdateManyWithWhereWithoutPiInput[]
    deleteMany?: CPMK_PI_MapScalarWhereInput | CPMK_PI_MapScalarWhereInput[]
  }

  export type CPMK_PI_MapUncheckedUpdateManyWithoutPiNestedInput = {
    create?: XOR<CPMK_PI_MapCreateWithoutPiInput, CPMK_PI_MapUncheckedCreateWithoutPiInput> | CPMK_PI_MapCreateWithoutPiInput[] | CPMK_PI_MapUncheckedCreateWithoutPiInput[]
    connectOrCreate?: CPMK_PI_MapCreateOrConnectWithoutPiInput | CPMK_PI_MapCreateOrConnectWithoutPiInput[]
    upsert?: CPMK_PI_MapUpsertWithWhereUniqueWithoutPiInput | CPMK_PI_MapUpsertWithWhereUniqueWithoutPiInput[]
    createMany?: CPMK_PI_MapCreateManyPiInputEnvelope
    set?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
    disconnect?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
    delete?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
    connect?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
    update?: CPMK_PI_MapUpdateWithWhereUniqueWithoutPiInput | CPMK_PI_MapUpdateWithWhereUniqueWithoutPiInput[]
    updateMany?: CPMK_PI_MapUpdateManyWithWhereWithoutPiInput | CPMK_PI_MapUpdateManyWithWhereWithoutPiInput[]
    deleteMany?: CPMK_PI_MapScalarWhereInput | CPMK_PI_MapScalarWhereInput[]
  }

  export type KurikulumCreateNestedOneWithoutCplInput = {
    create?: XOR<KurikulumCreateWithoutCplInput, KurikulumUncheckedCreateWithoutCplInput>
    connectOrCreate?: KurikulumCreateOrConnectWithoutCplInput
    connect?: KurikulumWhereUniqueInput
  }

  export type PIGroupCreateNestedOneWithoutCplInput = {
    create?: XOR<PIGroupCreateWithoutCplInput, PIGroupUncheckedCreateWithoutCplInput>
    connectOrCreate?: PIGroupCreateOrConnectWithoutCplInput
    connect?: PIGroupWhereUniqueInput
  }

  export type KurikulumUpdateOneRequiredWithoutCplNestedInput = {
    create?: XOR<KurikulumCreateWithoutCplInput, KurikulumUncheckedCreateWithoutCplInput>
    connectOrCreate?: KurikulumCreateOrConnectWithoutCplInput
    upsert?: KurikulumUpsertWithoutCplInput
    connect?: KurikulumWhereUniqueInput
    update?: XOR<XOR<KurikulumUpdateToOneWithWhereWithoutCplInput, KurikulumUpdateWithoutCplInput>, KurikulumUncheckedUpdateWithoutCplInput>
  }

  export type PIGroupUpdateOneRequiredWithoutCplNestedInput = {
    create?: XOR<PIGroupCreateWithoutCplInput, PIGroupUncheckedCreateWithoutCplInput>
    connectOrCreate?: PIGroupCreateOrConnectWithoutCplInput
    upsert?: PIGroupUpsertWithoutCplInput
    connect?: PIGroupWhereUniqueInput
    update?: XOR<XOR<PIGroupUpdateToOneWithWhereWithoutCplInput, PIGroupUpdateWithoutCplInput>, PIGroupUncheckedUpdateWithoutCplInput>
  }

  export type KelasCreateNestedManyWithoutTahunAjaranInput = {
    create?: XOR<KelasCreateWithoutTahunAjaranInput, KelasUncheckedCreateWithoutTahunAjaranInput> | KelasCreateWithoutTahunAjaranInput[] | KelasUncheckedCreateWithoutTahunAjaranInput[]
    connectOrCreate?: KelasCreateOrConnectWithoutTahunAjaranInput | KelasCreateOrConnectWithoutTahunAjaranInput[]
    createMany?: KelasCreateManyTahunAjaranInputEnvelope
    connect?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
  }

  export type KelasUncheckedCreateNestedManyWithoutTahunAjaranInput = {
    create?: XOR<KelasCreateWithoutTahunAjaranInput, KelasUncheckedCreateWithoutTahunAjaranInput> | KelasCreateWithoutTahunAjaranInput[] | KelasUncheckedCreateWithoutTahunAjaranInput[]
    connectOrCreate?: KelasCreateOrConnectWithoutTahunAjaranInput | KelasCreateOrConnectWithoutTahunAjaranInput[]
    createMany?: KelasCreateManyTahunAjaranInputEnvelope
    connect?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
  }

  export type EnumSemesterFieldUpdateOperationsInput = {
    set?: $Enums.Semester
  }

  export type KelasUpdateManyWithoutTahunAjaranNestedInput = {
    create?: XOR<KelasCreateWithoutTahunAjaranInput, KelasUncheckedCreateWithoutTahunAjaranInput> | KelasCreateWithoutTahunAjaranInput[] | KelasUncheckedCreateWithoutTahunAjaranInput[]
    connectOrCreate?: KelasCreateOrConnectWithoutTahunAjaranInput | KelasCreateOrConnectWithoutTahunAjaranInput[]
    upsert?: KelasUpsertWithWhereUniqueWithoutTahunAjaranInput | KelasUpsertWithWhereUniqueWithoutTahunAjaranInput[]
    createMany?: KelasCreateManyTahunAjaranInputEnvelope
    set?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
    disconnect?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
    delete?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
    connect?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
    update?: KelasUpdateWithWhereUniqueWithoutTahunAjaranInput | KelasUpdateWithWhereUniqueWithoutTahunAjaranInput[]
    updateMany?: KelasUpdateManyWithWhereWithoutTahunAjaranInput | KelasUpdateManyWithWhereWithoutTahunAjaranInput[]
    deleteMany?: KelasScalarWhereInput | KelasScalarWhereInput[]
  }

  export type KelasUncheckedUpdateManyWithoutTahunAjaranNestedInput = {
    create?: XOR<KelasCreateWithoutTahunAjaranInput, KelasUncheckedCreateWithoutTahunAjaranInput> | KelasCreateWithoutTahunAjaranInput[] | KelasUncheckedCreateWithoutTahunAjaranInput[]
    connectOrCreate?: KelasCreateOrConnectWithoutTahunAjaranInput | KelasCreateOrConnectWithoutTahunAjaranInput[]
    upsert?: KelasUpsertWithWhereUniqueWithoutTahunAjaranInput | KelasUpsertWithWhereUniqueWithoutTahunAjaranInput[]
    createMany?: KelasCreateManyTahunAjaranInputEnvelope
    set?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
    disconnect?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
    delete?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
    connect?: KelasWhereUniqueInput | KelasWhereUniqueInput[]
    update?: KelasUpdateWithWhereUniqueWithoutTahunAjaranInput | KelasUpdateWithWhereUniqueWithoutTahunAjaranInput[]
    updateMany?: KelasUpdateManyWithWhereWithoutTahunAjaranInput | KelasUpdateManyWithWhereWithoutTahunAjaranInput[]
    deleteMany?: KelasScalarWhereInput | KelasScalarWhereInput[]
  }

  export type MataKuliahCreateNestedOneWithoutKelasInput = {
    create?: XOR<MataKuliahCreateWithoutKelasInput, MataKuliahUncheckedCreateWithoutKelasInput>
    connectOrCreate?: MataKuliahCreateOrConnectWithoutKelasInput
    connect?: MataKuliahWhereUniqueInput
  }

  export type TahunAjaranCreateNestedOneWithoutKelasInput = {
    create?: XOR<TahunAjaranCreateWithoutKelasInput, TahunAjaranUncheckedCreateWithoutKelasInput>
    connectOrCreate?: TahunAjaranCreateOrConnectWithoutKelasInput
    connect?: TahunAjaranWhereUniqueInput
  }

  export type DosenPengampuCreateNestedManyWithoutKelasInput = {
    create?: XOR<DosenPengampuCreateWithoutKelasInput, DosenPengampuUncheckedCreateWithoutKelasInput> | DosenPengampuCreateWithoutKelasInput[] | DosenPengampuUncheckedCreateWithoutKelasInput[]
    connectOrCreate?: DosenPengampuCreateOrConnectWithoutKelasInput | DosenPengampuCreateOrConnectWithoutKelasInput[]
    createMany?: DosenPengampuCreateManyKelasInputEnvelope
    connect?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
  }

  export type PesertaKelasCreateNestedManyWithoutKelasInput = {
    create?: XOR<PesertaKelasCreateWithoutKelasInput, PesertaKelasUncheckedCreateWithoutKelasInput> | PesertaKelasCreateWithoutKelasInput[] | PesertaKelasUncheckedCreateWithoutKelasInput[]
    connectOrCreate?: PesertaKelasCreateOrConnectWithoutKelasInput | PesertaKelasCreateOrConnectWithoutKelasInput[]
    createMany?: PesertaKelasCreateManyKelasInputEnvelope
    connect?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
  }

  export type RPSCreateNestedManyWithoutKelasInput = {
    create?: XOR<RPSCreateWithoutKelasInput, RPSUncheckedCreateWithoutKelasInput> | RPSCreateWithoutKelasInput[] | RPSUncheckedCreateWithoutKelasInput[]
    connectOrCreate?: RPSCreateOrConnectWithoutKelasInput | RPSCreateOrConnectWithoutKelasInput[]
    createMany?: RPSCreateManyKelasInputEnvelope
    connect?: RPSWhereUniqueInput | RPSWhereUniqueInput[]
  }

  export type CPMKCreateNestedManyWithoutKelasInput = {
    create?: XOR<CPMKCreateWithoutKelasInput, CPMKUncheckedCreateWithoutKelasInput> | CPMKCreateWithoutKelasInput[] | CPMKUncheckedCreateWithoutKelasInput[]
    connectOrCreate?: CPMKCreateOrConnectWithoutKelasInput | CPMKCreateOrConnectWithoutKelasInput[]
    createMany?: CPMKCreateManyKelasInputEnvelope
    connect?: CPMKWhereUniqueInput | CPMKWhereUniqueInput[]
  }

  export type DosenPengampuUncheckedCreateNestedManyWithoutKelasInput = {
    create?: XOR<DosenPengampuCreateWithoutKelasInput, DosenPengampuUncheckedCreateWithoutKelasInput> | DosenPengampuCreateWithoutKelasInput[] | DosenPengampuUncheckedCreateWithoutKelasInput[]
    connectOrCreate?: DosenPengampuCreateOrConnectWithoutKelasInput | DosenPengampuCreateOrConnectWithoutKelasInput[]
    createMany?: DosenPengampuCreateManyKelasInputEnvelope
    connect?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
  }

  export type PesertaKelasUncheckedCreateNestedManyWithoutKelasInput = {
    create?: XOR<PesertaKelasCreateWithoutKelasInput, PesertaKelasUncheckedCreateWithoutKelasInput> | PesertaKelasCreateWithoutKelasInput[] | PesertaKelasUncheckedCreateWithoutKelasInput[]
    connectOrCreate?: PesertaKelasCreateOrConnectWithoutKelasInput | PesertaKelasCreateOrConnectWithoutKelasInput[]
    createMany?: PesertaKelasCreateManyKelasInputEnvelope
    connect?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
  }

  export type RPSUncheckedCreateNestedManyWithoutKelasInput = {
    create?: XOR<RPSCreateWithoutKelasInput, RPSUncheckedCreateWithoutKelasInput> | RPSCreateWithoutKelasInput[] | RPSUncheckedCreateWithoutKelasInput[]
    connectOrCreate?: RPSCreateOrConnectWithoutKelasInput | RPSCreateOrConnectWithoutKelasInput[]
    createMany?: RPSCreateManyKelasInputEnvelope
    connect?: RPSWhereUniqueInput | RPSWhereUniqueInput[]
  }

  export type CPMKUncheckedCreateNestedManyWithoutKelasInput = {
    create?: XOR<CPMKCreateWithoutKelasInput, CPMKUncheckedCreateWithoutKelasInput> | CPMKCreateWithoutKelasInput[] | CPMKUncheckedCreateWithoutKelasInput[]
    connectOrCreate?: CPMKCreateOrConnectWithoutKelasInput | CPMKCreateOrConnectWithoutKelasInput[]
    createMany?: CPMKCreateManyKelasInputEnvelope
    connect?: CPMKWhereUniqueInput | CPMKWhereUniqueInput[]
  }

  export type MataKuliahUpdateOneRequiredWithoutKelasNestedInput = {
    create?: XOR<MataKuliahCreateWithoutKelasInput, MataKuliahUncheckedCreateWithoutKelasInput>
    connectOrCreate?: MataKuliahCreateOrConnectWithoutKelasInput
    upsert?: MataKuliahUpsertWithoutKelasInput
    connect?: MataKuliahWhereUniqueInput
    update?: XOR<XOR<MataKuliahUpdateToOneWithWhereWithoutKelasInput, MataKuliahUpdateWithoutKelasInput>, MataKuliahUncheckedUpdateWithoutKelasInput>
  }

  export type TahunAjaranUpdateOneRequiredWithoutKelasNestedInput = {
    create?: XOR<TahunAjaranCreateWithoutKelasInput, TahunAjaranUncheckedCreateWithoutKelasInput>
    connectOrCreate?: TahunAjaranCreateOrConnectWithoutKelasInput
    upsert?: TahunAjaranUpsertWithoutKelasInput
    connect?: TahunAjaranWhereUniqueInput
    update?: XOR<XOR<TahunAjaranUpdateToOneWithWhereWithoutKelasInput, TahunAjaranUpdateWithoutKelasInput>, TahunAjaranUncheckedUpdateWithoutKelasInput>
  }

  export type DosenPengampuUpdateManyWithoutKelasNestedInput = {
    create?: XOR<DosenPengampuCreateWithoutKelasInput, DosenPengampuUncheckedCreateWithoutKelasInput> | DosenPengampuCreateWithoutKelasInput[] | DosenPengampuUncheckedCreateWithoutKelasInput[]
    connectOrCreate?: DosenPengampuCreateOrConnectWithoutKelasInput | DosenPengampuCreateOrConnectWithoutKelasInput[]
    upsert?: DosenPengampuUpsertWithWhereUniqueWithoutKelasInput | DosenPengampuUpsertWithWhereUniqueWithoutKelasInput[]
    createMany?: DosenPengampuCreateManyKelasInputEnvelope
    set?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
    disconnect?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
    delete?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
    connect?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
    update?: DosenPengampuUpdateWithWhereUniqueWithoutKelasInput | DosenPengampuUpdateWithWhereUniqueWithoutKelasInput[]
    updateMany?: DosenPengampuUpdateManyWithWhereWithoutKelasInput | DosenPengampuUpdateManyWithWhereWithoutKelasInput[]
    deleteMany?: DosenPengampuScalarWhereInput | DosenPengampuScalarWhereInput[]
  }

  export type PesertaKelasUpdateManyWithoutKelasNestedInput = {
    create?: XOR<PesertaKelasCreateWithoutKelasInput, PesertaKelasUncheckedCreateWithoutKelasInput> | PesertaKelasCreateWithoutKelasInput[] | PesertaKelasUncheckedCreateWithoutKelasInput[]
    connectOrCreate?: PesertaKelasCreateOrConnectWithoutKelasInput | PesertaKelasCreateOrConnectWithoutKelasInput[]
    upsert?: PesertaKelasUpsertWithWhereUniqueWithoutKelasInput | PesertaKelasUpsertWithWhereUniqueWithoutKelasInput[]
    createMany?: PesertaKelasCreateManyKelasInputEnvelope
    set?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
    disconnect?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
    delete?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
    connect?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
    update?: PesertaKelasUpdateWithWhereUniqueWithoutKelasInput | PesertaKelasUpdateWithWhereUniqueWithoutKelasInput[]
    updateMany?: PesertaKelasUpdateManyWithWhereWithoutKelasInput | PesertaKelasUpdateManyWithWhereWithoutKelasInput[]
    deleteMany?: PesertaKelasScalarWhereInput | PesertaKelasScalarWhereInput[]
  }

  export type RPSUpdateManyWithoutKelasNestedInput = {
    create?: XOR<RPSCreateWithoutKelasInput, RPSUncheckedCreateWithoutKelasInput> | RPSCreateWithoutKelasInput[] | RPSUncheckedCreateWithoutKelasInput[]
    connectOrCreate?: RPSCreateOrConnectWithoutKelasInput | RPSCreateOrConnectWithoutKelasInput[]
    upsert?: RPSUpsertWithWhereUniqueWithoutKelasInput | RPSUpsertWithWhereUniqueWithoutKelasInput[]
    createMany?: RPSCreateManyKelasInputEnvelope
    set?: RPSWhereUniqueInput | RPSWhereUniqueInput[]
    disconnect?: RPSWhereUniqueInput | RPSWhereUniqueInput[]
    delete?: RPSWhereUniqueInput | RPSWhereUniqueInput[]
    connect?: RPSWhereUniqueInput | RPSWhereUniqueInput[]
    update?: RPSUpdateWithWhereUniqueWithoutKelasInput | RPSUpdateWithWhereUniqueWithoutKelasInput[]
    updateMany?: RPSUpdateManyWithWhereWithoutKelasInput | RPSUpdateManyWithWhereWithoutKelasInput[]
    deleteMany?: RPSScalarWhereInput | RPSScalarWhereInput[]
  }

  export type CPMKUpdateManyWithoutKelasNestedInput = {
    create?: XOR<CPMKCreateWithoutKelasInput, CPMKUncheckedCreateWithoutKelasInput> | CPMKCreateWithoutKelasInput[] | CPMKUncheckedCreateWithoutKelasInput[]
    connectOrCreate?: CPMKCreateOrConnectWithoutKelasInput | CPMKCreateOrConnectWithoutKelasInput[]
    upsert?: CPMKUpsertWithWhereUniqueWithoutKelasInput | CPMKUpsertWithWhereUniqueWithoutKelasInput[]
    createMany?: CPMKCreateManyKelasInputEnvelope
    set?: CPMKWhereUniqueInput | CPMKWhereUniqueInput[]
    disconnect?: CPMKWhereUniqueInput | CPMKWhereUniqueInput[]
    delete?: CPMKWhereUniqueInput | CPMKWhereUniqueInput[]
    connect?: CPMKWhereUniqueInput | CPMKWhereUniqueInput[]
    update?: CPMKUpdateWithWhereUniqueWithoutKelasInput | CPMKUpdateWithWhereUniqueWithoutKelasInput[]
    updateMany?: CPMKUpdateManyWithWhereWithoutKelasInput | CPMKUpdateManyWithWhereWithoutKelasInput[]
    deleteMany?: CPMKScalarWhereInput | CPMKScalarWhereInput[]
  }

  export type DosenPengampuUncheckedUpdateManyWithoutKelasNestedInput = {
    create?: XOR<DosenPengampuCreateWithoutKelasInput, DosenPengampuUncheckedCreateWithoutKelasInput> | DosenPengampuCreateWithoutKelasInput[] | DosenPengampuUncheckedCreateWithoutKelasInput[]
    connectOrCreate?: DosenPengampuCreateOrConnectWithoutKelasInput | DosenPengampuCreateOrConnectWithoutKelasInput[]
    upsert?: DosenPengampuUpsertWithWhereUniqueWithoutKelasInput | DosenPengampuUpsertWithWhereUniqueWithoutKelasInput[]
    createMany?: DosenPengampuCreateManyKelasInputEnvelope
    set?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
    disconnect?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
    delete?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
    connect?: DosenPengampuWhereUniqueInput | DosenPengampuWhereUniqueInput[]
    update?: DosenPengampuUpdateWithWhereUniqueWithoutKelasInput | DosenPengampuUpdateWithWhereUniqueWithoutKelasInput[]
    updateMany?: DosenPengampuUpdateManyWithWhereWithoutKelasInput | DosenPengampuUpdateManyWithWhereWithoutKelasInput[]
    deleteMany?: DosenPengampuScalarWhereInput | DosenPengampuScalarWhereInput[]
  }

  export type PesertaKelasUncheckedUpdateManyWithoutKelasNestedInput = {
    create?: XOR<PesertaKelasCreateWithoutKelasInput, PesertaKelasUncheckedCreateWithoutKelasInput> | PesertaKelasCreateWithoutKelasInput[] | PesertaKelasUncheckedCreateWithoutKelasInput[]
    connectOrCreate?: PesertaKelasCreateOrConnectWithoutKelasInput | PesertaKelasCreateOrConnectWithoutKelasInput[]
    upsert?: PesertaKelasUpsertWithWhereUniqueWithoutKelasInput | PesertaKelasUpsertWithWhereUniqueWithoutKelasInput[]
    createMany?: PesertaKelasCreateManyKelasInputEnvelope
    set?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
    disconnect?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
    delete?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
    connect?: PesertaKelasWhereUniqueInput | PesertaKelasWhereUniqueInput[]
    update?: PesertaKelasUpdateWithWhereUniqueWithoutKelasInput | PesertaKelasUpdateWithWhereUniqueWithoutKelasInput[]
    updateMany?: PesertaKelasUpdateManyWithWhereWithoutKelasInput | PesertaKelasUpdateManyWithWhereWithoutKelasInput[]
    deleteMany?: PesertaKelasScalarWhereInput | PesertaKelasScalarWhereInput[]
  }

  export type RPSUncheckedUpdateManyWithoutKelasNestedInput = {
    create?: XOR<RPSCreateWithoutKelasInput, RPSUncheckedCreateWithoutKelasInput> | RPSCreateWithoutKelasInput[] | RPSUncheckedCreateWithoutKelasInput[]
    connectOrCreate?: RPSCreateOrConnectWithoutKelasInput | RPSCreateOrConnectWithoutKelasInput[]
    upsert?: RPSUpsertWithWhereUniqueWithoutKelasInput | RPSUpsertWithWhereUniqueWithoutKelasInput[]
    createMany?: RPSCreateManyKelasInputEnvelope
    set?: RPSWhereUniqueInput | RPSWhereUniqueInput[]
    disconnect?: RPSWhereUniqueInput | RPSWhereUniqueInput[]
    delete?: RPSWhereUniqueInput | RPSWhereUniqueInput[]
    connect?: RPSWhereUniqueInput | RPSWhereUniqueInput[]
    update?: RPSUpdateWithWhereUniqueWithoutKelasInput | RPSUpdateWithWhereUniqueWithoutKelasInput[]
    updateMany?: RPSUpdateManyWithWhereWithoutKelasInput | RPSUpdateManyWithWhereWithoutKelasInput[]
    deleteMany?: RPSScalarWhereInput | RPSScalarWhereInput[]
  }

  export type CPMKUncheckedUpdateManyWithoutKelasNestedInput = {
    create?: XOR<CPMKCreateWithoutKelasInput, CPMKUncheckedCreateWithoutKelasInput> | CPMKCreateWithoutKelasInput[] | CPMKUncheckedCreateWithoutKelasInput[]
    connectOrCreate?: CPMKCreateOrConnectWithoutKelasInput | CPMKCreateOrConnectWithoutKelasInput[]
    upsert?: CPMKUpsertWithWhereUniqueWithoutKelasInput | CPMKUpsertWithWhereUniqueWithoutKelasInput[]
    createMany?: CPMKCreateManyKelasInputEnvelope
    set?: CPMKWhereUniqueInput | CPMKWhereUniqueInput[]
    disconnect?: CPMKWhereUniqueInput | CPMKWhereUniqueInput[]
    delete?: CPMKWhereUniqueInput | CPMKWhereUniqueInput[]
    connect?: CPMKWhereUniqueInput | CPMKWhereUniqueInput[]
    update?: CPMKUpdateWithWhereUniqueWithoutKelasInput | CPMKUpdateWithWhereUniqueWithoutKelasInput[]
    updateMany?: CPMKUpdateManyWithWhereWithoutKelasInput | CPMKUpdateManyWithWhereWithoutKelasInput[]
    deleteMany?: CPMKScalarWhereInput | CPMKScalarWhereInput[]
  }

  export type KelasCreateNestedOneWithoutDosenPengampuInput = {
    create?: XOR<KelasCreateWithoutDosenPengampuInput, KelasUncheckedCreateWithoutDosenPengampuInput>
    connectOrCreate?: KelasCreateOrConnectWithoutDosenPengampuInput
    connect?: KelasWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDosenPengampuInput = {
    create?: XOR<UserCreateWithoutDosenPengampuInput, UserUncheckedCreateWithoutDosenPengampuInput>
    connectOrCreate?: UserCreateOrConnectWithoutDosenPengampuInput
    connect?: UserWhereUniqueInput
  }

  export type KelasUpdateOneRequiredWithoutDosenPengampuNestedInput = {
    create?: XOR<KelasCreateWithoutDosenPengampuInput, KelasUncheckedCreateWithoutDosenPengampuInput>
    connectOrCreate?: KelasCreateOrConnectWithoutDosenPengampuInput
    upsert?: KelasUpsertWithoutDosenPengampuInput
    connect?: KelasWhereUniqueInput
    update?: XOR<XOR<KelasUpdateToOneWithWhereWithoutDosenPengampuInput, KelasUpdateWithoutDosenPengampuInput>, KelasUncheckedUpdateWithoutDosenPengampuInput>
  }

  export type UserUpdateOneRequiredWithoutDosenPengampuNestedInput = {
    create?: XOR<UserCreateWithoutDosenPengampuInput, UserUncheckedCreateWithoutDosenPengampuInput>
    connectOrCreate?: UserCreateOrConnectWithoutDosenPengampuInput
    upsert?: UserUpsertWithoutDosenPengampuInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDosenPengampuInput, UserUpdateWithoutDosenPengampuInput>, UserUncheckedUpdateWithoutDosenPengampuInput>
  }

  export type KelasCreateNestedOneWithoutPesertaKelasInput = {
    create?: XOR<KelasCreateWithoutPesertaKelasInput, KelasUncheckedCreateWithoutPesertaKelasInput>
    connectOrCreate?: KelasCreateOrConnectWithoutPesertaKelasInput
    connect?: KelasWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPesertaKelasInput = {
    create?: XOR<UserCreateWithoutPesertaKelasInput, UserUncheckedCreateWithoutPesertaKelasInput>
    connectOrCreate?: UserCreateOrConnectWithoutPesertaKelasInput
    connect?: UserWhereUniqueInput
  }

  export type NilaiCreateNestedManyWithoutPesertaKelasInput = {
    create?: XOR<NilaiCreateWithoutPesertaKelasInput, NilaiUncheckedCreateWithoutPesertaKelasInput> | NilaiCreateWithoutPesertaKelasInput[] | NilaiUncheckedCreateWithoutPesertaKelasInput[]
    connectOrCreate?: NilaiCreateOrConnectWithoutPesertaKelasInput | NilaiCreateOrConnectWithoutPesertaKelasInput[]
    createMany?: NilaiCreateManyPesertaKelasInputEnvelope
    connect?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
  }

  export type NilaiUncheckedCreateNestedManyWithoutPesertaKelasInput = {
    create?: XOR<NilaiCreateWithoutPesertaKelasInput, NilaiUncheckedCreateWithoutPesertaKelasInput> | NilaiCreateWithoutPesertaKelasInput[] | NilaiUncheckedCreateWithoutPesertaKelasInput[]
    connectOrCreate?: NilaiCreateOrConnectWithoutPesertaKelasInput | NilaiCreateOrConnectWithoutPesertaKelasInput[]
    createMany?: NilaiCreateManyPesertaKelasInputEnvelope
    connect?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
  }

  export type KelasUpdateOneRequiredWithoutPesertaKelasNestedInput = {
    create?: XOR<KelasCreateWithoutPesertaKelasInput, KelasUncheckedCreateWithoutPesertaKelasInput>
    connectOrCreate?: KelasCreateOrConnectWithoutPesertaKelasInput
    upsert?: KelasUpsertWithoutPesertaKelasInput
    connect?: KelasWhereUniqueInput
    update?: XOR<XOR<KelasUpdateToOneWithWhereWithoutPesertaKelasInput, KelasUpdateWithoutPesertaKelasInput>, KelasUncheckedUpdateWithoutPesertaKelasInput>
  }

  export type UserUpdateOneRequiredWithoutPesertaKelasNestedInput = {
    create?: XOR<UserCreateWithoutPesertaKelasInput, UserUncheckedCreateWithoutPesertaKelasInput>
    connectOrCreate?: UserCreateOrConnectWithoutPesertaKelasInput
    upsert?: UserUpsertWithoutPesertaKelasInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPesertaKelasInput, UserUpdateWithoutPesertaKelasInput>, UserUncheckedUpdateWithoutPesertaKelasInput>
  }

  export type NilaiUpdateManyWithoutPesertaKelasNestedInput = {
    create?: XOR<NilaiCreateWithoutPesertaKelasInput, NilaiUncheckedCreateWithoutPesertaKelasInput> | NilaiCreateWithoutPesertaKelasInput[] | NilaiUncheckedCreateWithoutPesertaKelasInput[]
    connectOrCreate?: NilaiCreateOrConnectWithoutPesertaKelasInput | NilaiCreateOrConnectWithoutPesertaKelasInput[]
    upsert?: NilaiUpsertWithWhereUniqueWithoutPesertaKelasInput | NilaiUpsertWithWhereUniqueWithoutPesertaKelasInput[]
    createMany?: NilaiCreateManyPesertaKelasInputEnvelope
    set?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
    disconnect?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
    delete?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
    connect?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
    update?: NilaiUpdateWithWhereUniqueWithoutPesertaKelasInput | NilaiUpdateWithWhereUniqueWithoutPesertaKelasInput[]
    updateMany?: NilaiUpdateManyWithWhereWithoutPesertaKelasInput | NilaiUpdateManyWithWhereWithoutPesertaKelasInput[]
    deleteMany?: NilaiScalarWhereInput | NilaiScalarWhereInput[]
  }

  export type NilaiUncheckedUpdateManyWithoutPesertaKelasNestedInput = {
    create?: XOR<NilaiCreateWithoutPesertaKelasInput, NilaiUncheckedCreateWithoutPesertaKelasInput> | NilaiCreateWithoutPesertaKelasInput[] | NilaiUncheckedCreateWithoutPesertaKelasInput[]
    connectOrCreate?: NilaiCreateOrConnectWithoutPesertaKelasInput | NilaiCreateOrConnectWithoutPesertaKelasInput[]
    upsert?: NilaiUpsertWithWhereUniqueWithoutPesertaKelasInput | NilaiUpsertWithWhereUniqueWithoutPesertaKelasInput[]
    createMany?: NilaiCreateManyPesertaKelasInputEnvelope
    set?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
    disconnect?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
    delete?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
    connect?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
    update?: NilaiUpdateWithWhereUniqueWithoutPesertaKelasInput | NilaiUpdateWithWhereUniqueWithoutPesertaKelasInput[]
    updateMany?: NilaiUpdateManyWithWhereWithoutPesertaKelasInput | NilaiUpdateManyWithWhereWithoutPesertaKelasInput[]
    deleteMany?: NilaiScalarWhereInput | NilaiScalarWhereInput[]
  }

  export type KelasCreateNestedOneWithoutRpsInput = {
    create?: XOR<KelasCreateWithoutRpsInput, KelasUncheckedCreateWithoutRpsInput>
    connectOrCreate?: KelasCreateOrConnectWithoutRpsInput
    connect?: KelasWhereUniqueInput
  }

  export type KelasUpdateOneRequiredWithoutRpsNestedInput = {
    create?: XOR<KelasCreateWithoutRpsInput, KelasUncheckedCreateWithoutRpsInput>
    connectOrCreate?: KelasCreateOrConnectWithoutRpsInput
    upsert?: KelasUpsertWithoutRpsInput
    connect?: KelasWhereUniqueInput
    update?: XOR<XOR<KelasUpdateToOneWithWhereWithoutRpsInput, KelasUpdateWithoutRpsInput>, KelasUncheckedUpdateWithoutRpsInput>
  }

  export type KelasCreateNestedOneWithoutCpmkInput = {
    create?: XOR<KelasCreateWithoutCpmkInput, KelasUncheckedCreateWithoutCpmkInput>
    connectOrCreate?: KelasCreateOrConnectWithoutCpmkInput
    connect?: KelasWhereUniqueInput
  }

  export type KomponenPenilaianCreateNestedManyWithoutCpmkInput = {
    create?: XOR<KomponenPenilaianCreateWithoutCpmkInput, KomponenPenilaianUncheckedCreateWithoutCpmkInput> | KomponenPenilaianCreateWithoutCpmkInput[] | KomponenPenilaianUncheckedCreateWithoutCpmkInput[]
    connectOrCreate?: KomponenPenilaianCreateOrConnectWithoutCpmkInput | KomponenPenilaianCreateOrConnectWithoutCpmkInput[]
    createMany?: KomponenPenilaianCreateManyCpmkInputEnvelope
    connect?: KomponenPenilaianWhereUniqueInput | KomponenPenilaianWhereUniqueInput[]
  }

  export type CPMK_PI_MapCreateNestedManyWithoutCpmkInput = {
    create?: XOR<CPMK_PI_MapCreateWithoutCpmkInput, CPMK_PI_MapUncheckedCreateWithoutCpmkInput> | CPMK_PI_MapCreateWithoutCpmkInput[] | CPMK_PI_MapUncheckedCreateWithoutCpmkInput[]
    connectOrCreate?: CPMK_PI_MapCreateOrConnectWithoutCpmkInput | CPMK_PI_MapCreateOrConnectWithoutCpmkInput[]
    createMany?: CPMK_PI_MapCreateManyCpmkInputEnvelope
    connect?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
  }

  export type KomponenPenilaianUncheckedCreateNestedManyWithoutCpmkInput = {
    create?: XOR<KomponenPenilaianCreateWithoutCpmkInput, KomponenPenilaianUncheckedCreateWithoutCpmkInput> | KomponenPenilaianCreateWithoutCpmkInput[] | KomponenPenilaianUncheckedCreateWithoutCpmkInput[]
    connectOrCreate?: KomponenPenilaianCreateOrConnectWithoutCpmkInput | KomponenPenilaianCreateOrConnectWithoutCpmkInput[]
    createMany?: KomponenPenilaianCreateManyCpmkInputEnvelope
    connect?: KomponenPenilaianWhereUniqueInput | KomponenPenilaianWhereUniqueInput[]
  }

  export type CPMK_PI_MapUncheckedCreateNestedManyWithoutCpmkInput = {
    create?: XOR<CPMK_PI_MapCreateWithoutCpmkInput, CPMK_PI_MapUncheckedCreateWithoutCpmkInput> | CPMK_PI_MapCreateWithoutCpmkInput[] | CPMK_PI_MapUncheckedCreateWithoutCpmkInput[]
    connectOrCreate?: CPMK_PI_MapCreateOrConnectWithoutCpmkInput | CPMK_PI_MapCreateOrConnectWithoutCpmkInput[]
    createMany?: CPMK_PI_MapCreateManyCpmkInputEnvelope
    connect?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
  }

  export type KelasUpdateOneRequiredWithoutCpmkNestedInput = {
    create?: XOR<KelasCreateWithoutCpmkInput, KelasUncheckedCreateWithoutCpmkInput>
    connectOrCreate?: KelasCreateOrConnectWithoutCpmkInput
    upsert?: KelasUpsertWithoutCpmkInput
    connect?: KelasWhereUniqueInput
    update?: XOR<XOR<KelasUpdateToOneWithWhereWithoutCpmkInput, KelasUpdateWithoutCpmkInput>, KelasUncheckedUpdateWithoutCpmkInput>
  }

  export type KomponenPenilaianUpdateManyWithoutCpmkNestedInput = {
    create?: XOR<KomponenPenilaianCreateWithoutCpmkInput, KomponenPenilaianUncheckedCreateWithoutCpmkInput> | KomponenPenilaianCreateWithoutCpmkInput[] | KomponenPenilaianUncheckedCreateWithoutCpmkInput[]
    connectOrCreate?: KomponenPenilaianCreateOrConnectWithoutCpmkInput | KomponenPenilaianCreateOrConnectWithoutCpmkInput[]
    upsert?: KomponenPenilaianUpsertWithWhereUniqueWithoutCpmkInput | KomponenPenilaianUpsertWithWhereUniqueWithoutCpmkInput[]
    createMany?: KomponenPenilaianCreateManyCpmkInputEnvelope
    set?: KomponenPenilaianWhereUniqueInput | KomponenPenilaianWhereUniqueInput[]
    disconnect?: KomponenPenilaianWhereUniqueInput | KomponenPenilaianWhereUniqueInput[]
    delete?: KomponenPenilaianWhereUniqueInput | KomponenPenilaianWhereUniqueInput[]
    connect?: KomponenPenilaianWhereUniqueInput | KomponenPenilaianWhereUniqueInput[]
    update?: KomponenPenilaianUpdateWithWhereUniqueWithoutCpmkInput | KomponenPenilaianUpdateWithWhereUniqueWithoutCpmkInput[]
    updateMany?: KomponenPenilaianUpdateManyWithWhereWithoutCpmkInput | KomponenPenilaianUpdateManyWithWhereWithoutCpmkInput[]
    deleteMany?: KomponenPenilaianScalarWhereInput | KomponenPenilaianScalarWhereInput[]
  }

  export type CPMK_PI_MapUpdateManyWithoutCpmkNestedInput = {
    create?: XOR<CPMK_PI_MapCreateWithoutCpmkInput, CPMK_PI_MapUncheckedCreateWithoutCpmkInput> | CPMK_PI_MapCreateWithoutCpmkInput[] | CPMK_PI_MapUncheckedCreateWithoutCpmkInput[]
    connectOrCreate?: CPMK_PI_MapCreateOrConnectWithoutCpmkInput | CPMK_PI_MapCreateOrConnectWithoutCpmkInput[]
    upsert?: CPMK_PI_MapUpsertWithWhereUniqueWithoutCpmkInput | CPMK_PI_MapUpsertWithWhereUniqueWithoutCpmkInput[]
    createMany?: CPMK_PI_MapCreateManyCpmkInputEnvelope
    set?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
    disconnect?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
    delete?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
    connect?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
    update?: CPMK_PI_MapUpdateWithWhereUniqueWithoutCpmkInput | CPMK_PI_MapUpdateWithWhereUniqueWithoutCpmkInput[]
    updateMany?: CPMK_PI_MapUpdateManyWithWhereWithoutCpmkInput | CPMK_PI_MapUpdateManyWithWhereWithoutCpmkInput[]
    deleteMany?: CPMK_PI_MapScalarWhereInput | CPMK_PI_MapScalarWhereInput[]
  }

  export type KomponenPenilaianUncheckedUpdateManyWithoutCpmkNestedInput = {
    create?: XOR<KomponenPenilaianCreateWithoutCpmkInput, KomponenPenilaianUncheckedCreateWithoutCpmkInput> | KomponenPenilaianCreateWithoutCpmkInput[] | KomponenPenilaianUncheckedCreateWithoutCpmkInput[]
    connectOrCreate?: KomponenPenilaianCreateOrConnectWithoutCpmkInput | KomponenPenilaianCreateOrConnectWithoutCpmkInput[]
    upsert?: KomponenPenilaianUpsertWithWhereUniqueWithoutCpmkInput | KomponenPenilaianUpsertWithWhereUniqueWithoutCpmkInput[]
    createMany?: KomponenPenilaianCreateManyCpmkInputEnvelope
    set?: KomponenPenilaianWhereUniqueInput | KomponenPenilaianWhereUniqueInput[]
    disconnect?: KomponenPenilaianWhereUniqueInput | KomponenPenilaianWhereUniqueInput[]
    delete?: KomponenPenilaianWhereUniqueInput | KomponenPenilaianWhereUniqueInput[]
    connect?: KomponenPenilaianWhereUniqueInput | KomponenPenilaianWhereUniqueInput[]
    update?: KomponenPenilaianUpdateWithWhereUniqueWithoutCpmkInput | KomponenPenilaianUpdateWithWhereUniqueWithoutCpmkInput[]
    updateMany?: KomponenPenilaianUpdateManyWithWhereWithoutCpmkInput | KomponenPenilaianUpdateManyWithWhereWithoutCpmkInput[]
    deleteMany?: KomponenPenilaianScalarWhereInput | KomponenPenilaianScalarWhereInput[]
  }

  export type CPMK_PI_MapUncheckedUpdateManyWithoutCpmkNestedInput = {
    create?: XOR<CPMK_PI_MapCreateWithoutCpmkInput, CPMK_PI_MapUncheckedCreateWithoutCpmkInput> | CPMK_PI_MapCreateWithoutCpmkInput[] | CPMK_PI_MapUncheckedCreateWithoutCpmkInput[]
    connectOrCreate?: CPMK_PI_MapCreateOrConnectWithoutCpmkInput | CPMK_PI_MapCreateOrConnectWithoutCpmkInput[]
    upsert?: CPMK_PI_MapUpsertWithWhereUniqueWithoutCpmkInput | CPMK_PI_MapUpsertWithWhereUniqueWithoutCpmkInput[]
    createMany?: CPMK_PI_MapCreateManyCpmkInputEnvelope
    set?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
    disconnect?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
    delete?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
    connect?: CPMK_PI_MapWhereUniqueInput | CPMK_PI_MapWhereUniqueInput[]
    update?: CPMK_PI_MapUpdateWithWhereUniqueWithoutCpmkInput | CPMK_PI_MapUpdateWithWhereUniqueWithoutCpmkInput[]
    updateMany?: CPMK_PI_MapUpdateManyWithWhereWithoutCpmkInput | CPMK_PI_MapUpdateManyWithWhereWithoutCpmkInput[]
    deleteMany?: CPMK_PI_MapScalarWhereInput | CPMK_PI_MapScalarWhereInput[]
  }

  export type CPMKCreateNestedOneWithoutPiMapInput = {
    create?: XOR<CPMKCreateWithoutPiMapInput, CPMKUncheckedCreateWithoutPiMapInput>
    connectOrCreate?: CPMKCreateOrConnectWithoutPiMapInput
    connect?: CPMKWhereUniqueInput
  }

  export type PerformanceIndicatorCreateNestedOneWithoutCpmkMapInput = {
    create?: XOR<PerformanceIndicatorCreateWithoutCpmkMapInput, PerformanceIndicatorUncheckedCreateWithoutCpmkMapInput>
    connectOrCreate?: PerformanceIndicatorCreateOrConnectWithoutCpmkMapInput
    connect?: PerformanceIndicatorWhereUniqueInput
  }

  export type CPMKUpdateOneRequiredWithoutPiMapNestedInput = {
    create?: XOR<CPMKCreateWithoutPiMapInput, CPMKUncheckedCreateWithoutPiMapInput>
    connectOrCreate?: CPMKCreateOrConnectWithoutPiMapInput
    upsert?: CPMKUpsertWithoutPiMapInput
    connect?: CPMKWhereUniqueInput
    update?: XOR<XOR<CPMKUpdateToOneWithWhereWithoutPiMapInput, CPMKUpdateWithoutPiMapInput>, CPMKUncheckedUpdateWithoutPiMapInput>
  }

  export type PerformanceIndicatorUpdateOneRequiredWithoutCpmkMapNestedInput = {
    create?: XOR<PerformanceIndicatorCreateWithoutCpmkMapInput, PerformanceIndicatorUncheckedCreateWithoutCpmkMapInput>
    connectOrCreate?: PerformanceIndicatorCreateOrConnectWithoutCpmkMapInput
    upsert?: PerformanceIndicatorUpsertWithoutCpmkMapInput
    connect?: PerformanceIndicatorWhereUniqueInput
    update?: XOR<XOR<PerformanceIndicatorUpdateToOneWithWhereWithoutCpmkMapInput, PerformanceIndicatorUpdateWithoutCpmkMapInput>, PerformanceIndicatorUncheckedUpdateWithoutCpmkMapInput>
  }

  export type CPMKCreateNestedOneWithoutKomponenPenilaianInput = {
    create?: XOR<CPMKCreateWithoutKomponenPenilaianInput, CPMKUncheckedCreateWithoutKomponenPenilaianInput>
    connectOrCreate?: CPMKCreateOrConnectWithoutKomponenPenilaianInput
    connect?: CPMKWhereUniqueInput
  }

  export type NilaiCreateNestedManyWithoutKomponenPenilaianInput = {
    create?: XOR<NilaiCreateWithoutKomponenPenilaianInput, NilaiUncheckedCreateWithoutKomponenPenilaianInput> | NilaiCreateWithoutKomponenPenilaianInput[] | NilaiUncheckedCreateWithoutKomponenPenilaianInput[]
    connectOrCreate?: NilaiCreateOrConnectWithoutKomponenPenilaianInput | NilaiCreateOrConnectWithoutKomponenPenilaianInput[]
    createMany?: NilaiCreateManyKomponenPenilaianInputEnvelope
    connect?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
  }

  export type NilaiUncheckedCreateNestedManyWithoutKomponenPenilaianInput = {
    create?: XOR<NilaiCreateWithoutKomponenPenilaianInput, NilaiUncheckedCreateWithoutKomponenPenilaianInput> | NilaiCreateWithoutKomponenPenilaianInput[] | NilaiUncheckedCreateWithoutKomponenPenilaianInput[]
    connectOrCreate?: NilaiCreateOrConnectWithoutKomponenPenilaianInput | NilaiCreateOrConnectWithoutKomponenPenilaianInput[]
    createMany?: NilaiCreateManyKomponenPenilaianInputEnvelope
    connect?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CPMKUpdateOneRequiredWithoutKomponenPenilaianNestedInput = {
    create?: XOR<CPMKCreateWithoutKomponenPenilaianInput, CPMKUncheckedCreateWithoutKomponenPenilaianInput>
    connectOrCreate?: CPMKCreateOrConnectWithoutKomponenPenilaianInput
    upsert?: CPMKUpsertWithoutKomponenPenilaianInput
    connect?: CPMKWhereUniqueInput
    update?: XOR<XOR<CPMKUpdateToOneWithWhereWithoutKomponenPenilaianInput, CPMKUpdateWithoutKomponenPenilaianInput>, CPMKUncheckedUpdateWithoutKomponenPenilaianInput>
  }

  export type NilaiUpdateManyWithoutKomponenPenilaianNestedInput = {
    create?: XOR<NilaiCreateWithoutKomponenPenilaianInput, NilaiUncheckedCreateWithoutKomponenPenilaianInput> | NilaiCreateWithoutKomponenPenilaianInput[] | NilaiUncheckedCreateWithoutKomponenPenilaianInput[]
    connectOrCreate?: NilaiCreateOrConnectWithoutKomponenPenilaianInput | NilaiCreateOrConnectWithoutKomponenPenilaianInput[]
    upsert?: NilaiUpsertWithWhereUniqueWithoutKomponenPenilaianInput | NilaiUpsertWithWhereUniqueWithoutKomponenPenilaianInput[]
    createMany?: NilaiCreateManyKomponenPenilaianInputEnvelope
    set?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
    disconnect?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
    delete?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
    connect?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
    update?: NilaiUpdateWithWhereUniqueWithoutKomponenPenilaianInput | NilaiUpdateWithWhereUniqueWithoutKomponenPenilaianInput[]
    updateMany?: NilaiUpdateManyWithWhereWithoutKomponenPenilaianInput | NilaiUpdateManyWithWhereWithoutKomponenPenilaianInput[]
    deleteMany?: NilaiScalarWhereInput | NilaiScalarWhereInput[]
  }

  export type NilaiUncheckedUpdateManyWithoutKomponenPenilaianNestedInput = {
    create?: XOR<NilaiCreateWithoutKomponenPenilaianInput, NilaiUncheckedCreateWithoutKomponenPenilaianInput> | NilaiCreateWithoutKomponenPenilaianInput[] | NilaiUncheckedCreateWithoutKomponenPenilaianInput[]
    connectOrCreate?: NilaiCreateOrConnectWithoutKomponenPenilaianInput | NilaiCreateOrConnectWithoutKomponenPenilaianInput[]
    upsert?: NilaiUpsertWithWhereUniqueWithoutKomponenPenilaianInput | NilaiUpsertWithWhereUniqueWithoutKomponenPenilaianInput[]
    createMany?: NilaiCreateManyKomponenPenilaianInputEnvelope
    set?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
    disconnect?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
    delete?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
    connect?: NilaiWhereUniqueInput | NilaiWhereUniqueInput[]
    update?: NilaiUpdateWithWhereUniqueWithoutKomponenPenilaianInput | NilaiUpdateWithWhereUniqueWithoutKomponenPenilaianInput[]
    updateMany?: NilaiUpdateManyWithWhereWithoutKomponenPenilaianInput | NilaiUpdateManyWithWhereWithoutKomponenPenilaianInput[]
    deleteMany?: NilaiScalarWhereInput | NilaiScalarWhereInput[]
  }

  export type PesertaKelasCreateNestedOneWithoutNilaiInput = {
    create?: XOR<PesertaKelasCreateWithoutNilaiInput, PesertaKelasUncheckedCreateWithoutNilaiInput>
    connectOrCreate?: PesertaKelasCreateOrConnectWithoutNilaiInput
    connect?: PesertaKelasWhereUniqueInput
  }

  export type KomponenPenilaianCreateNestedOneWithoutNilaiInput = {
    create?: XOR<KomponenPenilaianCreateWithoutNilaiInput, KomponenPenilaianUncheckedCreateWithoutNilaiInput>
    connectOrCreate?: KomponenPenilaianCreateOrConnectWithoutNilaiInput
    connect?: KomponenPenilaianWhereUniqueInput
  }

  export type PesertaKelasUpdateOneRequiredWithoutNilaiNestedInput = {
    create?: XOR<PesertaKelasCreateWithoutNilaiInput, PesertaKelasUncheckedCreateWithoutNilaiInput>
    connectOrCreate?: PesertaKelasCreateOrConnectWithoutNilaiInput
    upsert?: PesertaKelasUpsertWithoutNilaiInput
    connect?: PesertaKelasWhereUniqueInput
    update?: XOR<XOR<PesertaKelasUpdateToOneWithWhereWithoutNilaiInput, PesertaKelasUpdateWithoutNilaiInput>, PesertaKelasUncheckedUpdateWithoutNilaiInput>
  }

  export type KomponenPenilaianUpdateOneRequiredWithoutNilaiNestedInput = {
    create?: XOR<KomponenPenilaianCreateWithoutNilaiInput, KomponenPenilaianUncheckedCreateWithoutNilaiInput>
    connectOrCreate?: KomponenPenilaianCreateOrConnectWithoutNilaiInput
    upsert?: KomponenPenilaianUpsertWithoutNilaiInput
    connect?: KomponenPenilaianWhereUniqueInput
    update?: XOR<XOR<KomponenPenilaianUpdateToOneWithWhereWithoutNilaiInput, KomponenPenilaianUpdateWithoutNilaiInput>, KomponenPenilaianUncheckedUpdateWithoutNilaiInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumSemesterFilter<$PrismaModel = never> = {
    equals?: $Enums.Semester | EnumSemesterFieldRefInput<$PrismaModel>
    in?: $Enums.Semester[] | ListEnumSemesterFieldRefInput<$PrismaModel>
    notIn?: $Enums.Semester[] | ListEnumSemesterFieldRefInput<$PrismaModel>
    not?: NestedEnumSemesterFilter<$PrismaModel> | $Enums.Semester
  }

  export type NestedEnumSemesterWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Semester | EnumSemesterFieldRefInput<$PrismaModel>
    in?: $Enums.Semester[] | ListEnumSemesterFieldRefInput<$PrismaModel>
    notIn?: $Enums.Semester[] | ListEnumSemesterFieldRefInput<$PrismaModel>
    not?: NestedEnumSemesterWithAggregatesFilter<$PrismaModel> | $Enums.Semester
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSemesterFilter<$PrismaModel>
    _max?: NestedEnumSemesterFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserCreateWithoutProgramStudiInput = {
    username: string
    password_hash: string
    nama: string
    role: $Enums.UserRole
    dosenPengampu?: DosenPengampuCreateNestedManyWithoutDosenInput
    pesertaKelas?: PesertaKelasCreateNestedManyWithoutMahasiswaInput
  }

  export type UserUncheckedCreateWithoutProgramStudiInput = {
    id?: number
    username: string
    password_hash: string
    nama: string
    role: $Enums.UserRole
    dosenPengampu?: DosenPengampuUncheckedCreateNestedManyWithoutDosenInput
    pesertaKelas?: PesertaKelasUncheckedCreateNestedManyWithoutMahasiswaInput
  }

  export type UserCreateOrConnectWithoutProgramStudiInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProgramStudiInput, UserUncheckedCreateWithoutProgramStudiInput>
  }

  export type UserCreateManyProgramStudiInputEnvelope = {
    data: UserCreateManyProgramStudiInput | UserCreateManyProgramStudiInput[]
    skipDuplicates?: boolean
  }

  export type KurikulumCreateWithoutProgramStudiInput = {
    nama: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mataKuliah?: MataKuliahCreateNestedManyWithoutKurikulumInput
    cpl?: CPLCreateNestedManyWithoutKurikulumInput
    piGroups?: PIGroupCreateNestedManyWithoutKurikulumInput
  }

  export type KurikulumUncheckedCreateWithoutProgramStudiInput = {
    id?: number
    nama: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mataKuliah?: MataKuliahUncheckedCreateNestedManyWithoutKurikulumInput
    cpl?: CPLUncheckedCreateNestedManyWithoutKurikulumInput
    piGroups?: PIGroupUncheckedCreateNestedManyWithoutKurikulumInput
  }

  export type KurikulumCreateOrConnectWithoutProgramStudiInput = {
    where: KurikulumWhereUniqueInput
    create: XOR<KurikulumCreateWithoutProgramStudiInput, KurikulumUncheckedCreateWithoutProgramStudiInput>
  }

  export type KurikulumCreateManyProgramStudiInputEnvelope = {
    data: KurikulumCreateManyProgramStudiInput | KurikulumCreateManyProgramStudiInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutProgramStudiInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutProgramStudiInput, UserUncheckedUpdateWithoutProgramStudiInput>
    create: XOR<UserCreateWithoutProgramStudiInput, UserUncheckedCreateWithoutProgramStudiInput>
  }

  export type UserUpdateWithWhereUniqueWithoutProgramStudiInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutProgramStudiInput, UserUncheckedUpdateWithoutProgramStudiInput>
  }

  export type UserUpdateManyWithWhereWithoutProgramStudiInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutProgramStudiInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password_hash?: StringFilter<"User"> | string
    nama?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    program_studi_id?: IntFilter<"User"> | number
  }

  export type KurikulumUpsertWithWhereUniqueWithoutProgramStudiInput = {
    where: KurikulumWhereUniqueInput
    update: XOR<KurikulumUpdateWithoutProgramStudiInput, KurikulumUncheckedUpdateWithoutProgramStudiInput>
    create: XOR<KurikulumCreateWithoutProgramStudiInput, KurikulumUncheckedCreateWithoutProgramStudiInput>
  }

  export type KurikulumUpdateWithWhereUniqueWithoutProgramStudiInput = {
    where: KurikulumWhereUniqueInput
    data: XOR<KurikulumUpdateWithoutProgramStudiInput, KurikulumUncheckedUpdateWithoutProgramStudiInput>
  }

  export type KurikulumUpdateManyWithWhereWithoutProgramStudiInput = {
    where: KurikulumScalarWhereInput
    data: XOR<KurikulumUpdateManyMutationInput, KurikulumUncheckedUpdateManyWithoutProgramStudiInput>
  }

  export type KurikulumScalarWhereInput = {
    AND?: KurikulumScalarWhereInput | KurikulumScalarWhereInput[]
    OR?: KurikulumScalarWhereInput[]
    NOT?: KurikulumScalarWhereInput | KurikulumScalarWhereInput[]
    id?: IntFilter<"Kurikulum"> | number
    nama?: StringFilter<"Kurikulum"> | string
    tahun?: IntFilter<"Kurikulum"> | number
    createdAt?: DateTimeFilter<"Kurikulum"> | Date | string
    updatedAt?: DateTimeFilter<"Kurikulum"> | Date | string
    program_studi_id?: IntFilter<"Kurikulum"> | number
  }

  export type ProgramStudiCreateWithoutUsersInput = {
    nama: string
    jenjang: string
    total_sks_lulus: number
    kurikulum?: KurikulumCreateNestedManyWithoutProgramStudiInput
  }

  export type ProgramStudiUncheckedCreateWithoutUsersInput = {
    id?: number
    nama: string
    jenjang: string
    total_sks_lulus: number
    kurikulum?: KurikulumUncheckedCreateNestedManyWithoutProgramStudiInput
  }

  export type ProgramStudiCreateOrConnectWithoutUsersInput = {
    where: ProgramStudiWhereUniqueInput
    create: XOR<ProgramStudiCreateWithoutUsersInput, ProgramStudiUncheckedCreateWithoutUsersInput>
  }

  export type DosenPengampuCreateWithoutDosenInput = {
    createdAt?: Date | string
    kelas: KelasCreateNestedOneWithoutDosenPengampuInput
  }

  export type DosenPengampuUncheckedCreateWithoutDosenInput = {
    id?: number
    createdAt?: Date | string
    kelas_id: number
  }

  export type DosenPengampuCreateOrConnectWithoutDosenInput = {
    where: DosenPengampuWhereUniqueInput
    create: XOR<DosenPengampuCreateWithoutDosenInput, DosenPengampuUncheckedCreateWithoutDosenInput>
  }

  export type DosenPengampuCreateManyDosenInputEnvelope = {
    data: DosenPengampuCreateManyDosenInput | DosenPengampuCreateManyDosenInput[]
    skipDuplicates?: boolean
  }

  export type PesertaKelasCreateWithoutMahasiswaInput = {
    createdAt?: Date | string
    kelas: KelasCreateNestedOneWithoutPesertaKelasInput
    nilai?: NilaiCreateNestedManyWithoutPesertaKelasInput
  }

  export type PesertaKelasUncheckedCreateWithoutMahasiswaInput = {
    id?: number
    createdAt?: Date | string
    kelas_id: number
    nilai?: NilaiUncheckedCreateNestedManyWithoutPesertaKelasInput
  }

  export type PesertaKelasCreateOrConnectWithoutMahasiswaInput = {
    where: PesertaKelasWhereUniqueInput
    create: XOR<PesertaKelasCreateWithoutMahasiswaInput, PesertaKelasUncheckedCreateWithoutMahasiswaInput>
  }

  export type PesertaKelasCreateManyMahasiswaInputEnvelope = {
    data: PesertaKelasCreateManyMahasiswaInput | PesertaKelasCreateManyMahasiswaInput[]
    skipDuplicates?: boolean
  }

  export type ProgramStudiUpsertWithoutUsersInput = {
    update: XOR<ProgramStudiUpdateWithoutUsersInput, ProgramStudiUncheckedUpdateWithoutUsersInput>
    create: XOR<ProgramStudiCreateWithoutUsersInput, ProgramStudiUncheckedCreateWithoutUsersInput>
    where?: ProgramStudiWhereInput
  }

  export type ProgramStudiUpdateToOneWithWhereWithoutUsersInput = {
    where?: ProgramStudiWhereInput
    data: XOR<ProgramStudiUpdateWithoutUsersInput, ProgramStudiUncheckedUpdateWithoutUsersInput>
  }

  export type ProgramStudiUpdateWithoutUsersInput = {
    nama?: StringFieldUpdateOperationsInput | string
    jenjang?: StringFieldUpdateOperationsInput | string
    total_sks_lulus?: IntFieldUpdateOperationsInput | number
    kurikulum?: KurikulumUpdateManyWithoutProgramStudiNestedInput
  }

  export type ProgramStudiUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    jenjang?: StringFieldUpdateOperationsInput | string
    total_sks_lulus?: IntFieldUpdateOperationsInput | number
    kurikulum?: KurikulumUncheckedUpdateManyWithoutProgramStudiNestedInput
  }

  export type DosenPengampuUpsertWithWhereUniqueWithoutDosenInput = {
    where: DosenPengampuWhereUniqueInput
    update: XOR<DosenPengampuUpdateWithoutDosenInput, DosenPengampuUncheckedUpdateWithoutDosenInput>
    create: XOR<DosenPengampuCreateWithoutDosenInput, DosenPengampuUncheckedCreateWithoutDosenInput>
  }

  export type DosenPengampuUpdateWithWhereUniqueWithoutDosenInput = {
    where: DosenPengampuWhereUniqueInput
    data: XOR<DosenPengampuUpdateWithoutDosenInput, DosenPengampuUncheckedUpdateWithoutDosenInput>
  }

  export type DosenPengampuUpdateManyWithWhereWithoutDosenInput = {
    where: DosenPengampuScalarWhereInput
    data: XOR<DosenPengampuUpdateManyMutationInput, DosenPengampuUncheckedUpdateManyWithoutDosenInput>
  }

  export type DosenPengampuScalarWhereInput = {
    AND?: DosenPengampuScalarWhereInput | DosenPengampuScalarWhereInput[]
    OR?: DosenPengampuScalarWhereInput[]
    NOT?: DosenPengampuScalarWhereInput | DosenPengampuScalarWhereInput[]
    id?: IntFilter<"DosenPengampu"> | number
    createdAt?: DateTimeFilter<"DosenPengampu"> | Date | string
    kelas_id?: IntFilter<"DosenPengampu"> | number
    dosen_id?: IntFilter<"DosenPengampu"> | number
  }

  export type PesertaKelasUpsertWithWhereUniqueWithoutMahasiswaInput = {
    where: PesertaKelasWhereUniqueInput
    update: XOR<PesertaKelasUpdateWithoutMahasiswaInput, PesertaKelasUncheckedUpdateWithoutMahasiswaInput>
    create: XOR<PesertaKelasCreateWithoutMahasiswaInput, PesertaKelasUncheckedCreateWithoutMahasiswaInput>
  }

  export type PesertaKelasUpdateWithWhereUniqueWithoutMahasiswaInput = {
    where: PesertaKelasWhereUniqueInput
    data: XOR<PesertaKelasUpdateWithoutMahasiswaInput, PesertaKelasUncheckedUpdateWithoutMahasiswaInput>
  }

  export type PesertaKelasUpdateManyWithWhereWithoutMahasiswaInput = {
    where: PesertaKelasScalarWhereInput
    data: XOR<PesertaKelasUpdateManyMutationInput, PesertaKelasUncheckedUpdateManyWithoutMahasiswaInput>
  }

  export type PesertaKelasScalarWhereInput = {
    AND?: PesertaKelasScalarWhereInput | PesertaKelasScalarWhereInput[]
    OR?: PesertaKelasScalarWhereInput[]
    NOT?: PesertaKelasScalarWhereInput | PesertaKelasScalarWhereInput[]
    id?: IntFilter<"PesertaKelas"> | number
    createdAt?: DateTimeFilter<"PesertaKelas"> | Date | string
    kelas_id?: IntFilter<"PesertaKelas"> | number
    mahasiswa_id?: IntFilter<"PesertaKelas"> | number
  }

  export type ProgramStudiCreateWithoutKurikulumInput = {
    nama: string
    jenjang: string
    total_sks_lulus: number
    users?: UserCreateNestedManyWithoutProgramStudiInput
  }

  export type ProgramStudiUncheckedCreateWithoutKurikulumInput = {
    id?: number
    nama: string
    jenjang: string
    total_sks_lulus: number
    users?: UserUncheckedCreateNestedManyWithoutProgramStudiInput
  }

  export type ProgramStudiCreateOrConnectWithoutKurikulumInput = {
    where: ProgramStudiWhereUniqueInput
    create: XOR<ProgramStudiCreateWithoutKurikulumInput, ProgramStudiUncheckedCreateWithoutKurikulumInput>
  }

  export type MataKuliahCreateWithoutKurikulumInput = {
    kode_mk: string
    nama: string
    sks: number
    createdAt?: Date | string
    updatedAt?: Date | string
    kelas?: KelasCreateNestedManyWithoutMataKuliahInput
  }

  export type MataKuliahUncheckedCreateWithoutKurikulumInput = {
    id?: number
    kode_mk: string
    nama: string
    sks: number
    createdAt?: Date | string
    updatedAt?: Date | string
    kelas?: KelasUncheckedCreateNestedManyWithoutMataKuliahInput
  }

  export type MataKuliahCreateOrConnectWithoutKurikulumInput = {
    where: MataKuliahWhereUniqueInput
    create: XOR<MataKuliahCreateWithoutKurikulumInput, MataKuliahUncheckedCreateWithoutKurikulumInput>
  }

  export type MataKuliahCreateManyKurikulumInputEnvelope = {
    data: MataKuliahCreateManyKurikulumInput | MataKuliahCreateManyKurikulumInput[]
    skipDuplicates?: boolean
  }

  export type CPLCreateWithoutKurikulumInput = {
    kode_cpl: string
    deskripsi: string
    createdAt?: Date | string
    updatedAt?: Date | string
    piGroup: PIGroupCreateNestedOneWithoutCplInput
  }

  export type CPLUncheckedCreateWithoutKurikulumInput = {
    id?: number
    kode_cpl: string
    deskripsi: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pi_group_id: number
  }

  export type CPLCreateOrConnectWithoutKurikulumInput = {
    where: CPLWhereUniqueInput
    create: XOR<CPLCreateWithoutKurikulumInput, CPLUncheckedCreateWithoutKurikulumInput>
  }

  export type CPLCreateManyKurikulumInputEnvelope = {
    data: CPLCreateManyKurikulumInput | CPLCreateManyKurikulumInput[]
    skipDuplicates?: boolean
  }

  export type PIGroupCreateWithoutKurikulumInput = {
    kode_grup: string
    nama_grup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    indicators?: PerformanceIndicatorCreateNestedManyWithoutPiGroupInput
    cpl?: CPLCreateNestedManyWithoutPiGroupInput
  }

  export type PIGroupUncheckedCreateWithoutKurikulumInput = {
    id?: number
    kode_grup: string
    nama_grup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    indicators?: PerformanceIndicatorUncheckedCreateNestedManyWithoutPiGroupInput
    cpl?: CPLUncheckedCreateNestedManyWithoutPiGroupInput
  }

  export type PIGroupCreateOrConnectWithoutKurikulumInput = {
    where: PIGroupWhereUniqueInput
    create: XOR<PIGroupCreateWithoutKurikulumInput, PIGroupUncheckedCreateWithoutKurikulumInput>
  }

  export type PIGroupCreateManyKurikulumInputEnvelope = {
    data: PIGroupCreateManyKurikulumInput | PIGroupCreateManyKurikulumInput[]
    skipDuplicates?: boolean
  }

  export type ProgramStudiUpsertWithoutKurikulumInput = {
    update: XOR<ProgramStudiUpdateWithoutKurikulumInput, ProgramStudiUncheckedUpdateWithoutKurikulumInput>
    create: XOR<ProgramStudiCreateWithoutKurikulumInput, ProgramStudiUncheckedCreateWithoutKurikulumInput>
    where?: ProgramStudiWhereInput
  }

  export type ProgramStudiUpdateToOneWithWhereWithoutKurikulumInput = {
    where?: ProgramStudiWhereInput
    data: XOR<ProgramStudiUpdateWithoutKurikulumInput, ProgramStudiUncheckedUpdateWithoutKurikulumInput>
  }

  export type ProgramStudiUpdateWithoutKurikulumInput = {
    nama?: StringFieldUpdateOperationsInput | string
    jenjang?: StringFieldUpdateOperationsInput | string
    total_sks_lulus?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutProgramStudiNestedInput
  }

  export type ProgramStudiUncheckedUpdateWithoutKurikulumInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    jenjang?: StringFieldUpdateOperationsInput | string
    total_sks_lulus?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutProgramStudiNestedInput
  }

  export type MataKuliahUpsertWithWhereUniqueWithoutKurikulumInput = {
    where: MataKuliahWhereUniqueInput
    update: XOR<MataKuliahUpdateWithoutKurikulumInput, MataKuliahUncheckedUpdateWithoutKurikulumInput>
    create: XOR<MataKuliahCreateWithoutKurikulumInput, MataKuliahUncheckedCreateWithoutKurikulumInput>
  }

  export type MataKuliahUpdateWithWhereUniqueWithoutKurikulumInput = {
    where: MataKuliahWhereUniqueInput
    data: XOR<MataKuliahUpdateWithoutKurikulumInput, MataKuliahUncheckedUpdateWithoutKurikulumInput>
  }

  export type MataKuliahUpdateManyWithWhereWithoutKurikulumInput = {
    where: MataKuliahScalarWhereInput
    data: XOR<MataKuliahUpdateManyMutationInput, MataKuliahUncheckedUpdateManyWithoutKurikulumInput>
  }

  export type MataKuliahScalarWhereInput = {
    AND?: MataKuliahScalarWhereInput | MataKuliahScalarWhereInput[]
    OR?: MataKuliahScalarWhereInput[]
    NOT?: MataKuliahScalarWhereInput | MataKuliahScalarWhereInput[]
    id?: IntFilter<"MataKuliah"> | number
    kode_mk?: StringFilter<"MataKuliah"> | string
    nama?: StringFilter<"MataKuliah"> | string
    sks?: IntFilter<"MataKuliah"> | number
    createdAt?: DateTimeFilter<"MataKuliah"> | Date | string
    updatedAt?: DateTimeFilter<"MataKuliah"> | Date | string
    kurikulum_id?: IntFilter<"MataKuliah"> | number
  }

  export type CPLUpsertWithWhereUniqueWithoutKurikulumInput = {
    where: CPLWhereUniqueInput
    update: XOR<CPLUpdateWithoutKurikulumInput, CPLUncheckedUpdateWithoutKurikulumInput>
    create: XOR<CPLCreateWithoutKurikulumInput, CPLUncheckedCreateWithoutKurikulumInput>
  }

  export type CPLUpdateWithWhereUniqueWithoutKurikulumInput = {
    where: CPLWhereUniqueInput
    data: XOR<CPLUpdateWithoutKurikulumInput, CPLUncheckedUpdateWithoutKurikulumInput>
  }

  export type CPLUpdateManyWithWhereWithoutKurikulumInput = {
    where: CPLScalarWhereInput
    data: XOR<CPLUpdateManyMutationInput, CPLUncheckedUpdateManyWithoutKurikulumInput>
  }

  export type CPLScalarWhereInput = {
    AND?: CPLScalarWhereInput | CPLScalarWhereInput[]
    OR?: CPLScalarWhereInput[]
    NOT?: CPLScalarWhereInput | CPLScalarWhereInput[]
    id?: IntFilter<"CPL"> | number
    kode_cpl?: StringFilter<"CPL"> | string
    deskripsi?: StringFilter<"CPL"> | string
    createdAt?: DateTimeFilter<"CPL"> | Date | string
    updatedAt?: DateTimeFilter<"CPL"> | Date | string
    kurikulum_id?: IntFilter<"CPL"> | number
    pi_group_id?: IntFilter<"CPL"> | number
  }

  export type PIGroupUpsertWithWhereUniqueWithoutKurikulumInput = {
    where: PIGroupWhereUniqueInput
    update: XOR<PIGroupUpdateWithoutKurikulumInput, PIGroupUncheckedUpdateWithoutKurikulumInput>
    create: XOR<PIGroupCreateWithoutKurikulumInput, PIGroupUncheckedCreateWithoutKurikulumInput>
  }

  export type PIGroupUpdateWithWhereUniqueWithoutKurikulumInput = {
    where: PIGroupWhereUniqueInput
    data: XOR<PIGroupUpdateWithoutKurikulumInput, PIGroupUncheckedUpdateWithoutKurikulumInput>
  }

  export type PIGroupUpdateManyWithWhereWithoutKurikulumInput = {
    where: PIGroupScalarWhereInput
    data: XOR<PIGroupUpdateManyMutationInput, PIGroupUncheckedUpdateManyWithoutKurikulumInput>
  }

  export type PIGroupScalarWhereInput = {
    AND?: PIGroupScalarWhereInput | PIGroupScalarWhereInput[]
    OR?: PIGroupScalarWhereInput[]
    NOT?: PIGroupScalarWhereInput | PIGroupScalarWhereInput[]
    id?: IntFilter<"PIGroup"> | number
    kode_grup?: StringFilter<"PIGroup"> | string
    nama_grup?: StringFilter<"PIGroup"> | string
    createdAt?: DateTimeFilter<"PIGroup"> | Date | string
    updatedAt?: DateTimeFilter<"PIGroup"> | Date | string
    kurikulum_id?: IntFilter<"PIGroup"> | number
  }

  export type KurikulumCreateWithoutMataKuliahInput = {
    nama: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    programStudi: ProgramStudiCreateNestedOneWithoutKurikulumInput
    cpl?: CPLCreateNestedManyWithoutKurikulumInput
    piGroups?: PIGroupCreateNestedManyWithoutKurikulumInput
  }

  export type KurikulumUncheckedCreateWithoutMataKuliahInput = {
    id?: number
    nama: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    program_studi_id: number
    cpl?: CPLUncheckedCreateNestedManyWithoutKurikulumInput
    piGroups?: PIGroupUncheckedCreateNestedManyWithoutKurikulumInput
  }

  export type KurikulumCreateOrConnectWithoutMataKuliahInput = {
    where: KurikulumWhereUniqueInput
    create: XOR<KurikulumCreateWithoutMataKuliahInput, KurikulumUncheckedCreateWithoutMataKuliahInput>
  }

  export type KelasCreateWithoutMataKuliahInput = {
    nama_kelas: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tahunAjaran: TahunAjaranCreateNestedOneWithoutKelasInput
    dosenPengampu?: DosenPengampuCreateNestedManyWithoutKelasInput
    pesertaKelas?: PesertaKelasCreateNestedManyWithoutKelasInput
    rps?: RPSCreateNestedManyWithoutKelasInput
    cpmk?: CPMKCreateNestedManyWithoutKelasInput
  }

  export type KelasUncheckedCreateWithoutMataKuliahInput = {
    id?: number
    nama_kelas: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tahun_ajaran_id: number
    dosenPengampu?: DosenPengampuUncheckedCreateNestedManyWithoutKelasInput
    pesertaKelas?: PesertaKelasUncheckedCreateNestedManyWithoutKelasInput
    rps?: RPSUncheckedCreateNestedManyWithoutKelasInput
    cpmk?: CPMKUncheckedCreateNestedManyWithoutKelasInput
  }

  export type KelasCreateOrConnectWithoutMataKuliahInput = {
    where: KelasWhereUniqueInput
    create: XOR<KelasCreateWithoutMataKuliahInput, KelasUncheckedCreateWithoutMataKuliahInput>
  }

  export type KelasCreateManyMataKuliahInputEnvelope = {
    data: KelasCreateManyMataKuliahInput | KelasCreateManyMataKuliahInput[]
    skipDuplicates?: boolean
  }

  export type KurikulumUpsertWithoutMataKuliahInput = {
    update: XOR<KurikulumUpdateWithoutMataKuliahInput, KurikulumUncheckedUpdateWithoutMataKuliahInput>
    create: XOR<KurikulumCreateWithoutMataKuliahInput, KurikulumUncheckedCreateWithoutMataKuliahInput>
    where?: KurikulumWhereInput
  }

  export type KurikulumUpdateToOneWithWhereWithoutMataKuliahInput = {
    where?: KurikulumWhereInput
    data: XOR<KurikulumUpdateWithoutMataKuliahInput, KurikulumUncheckedUpdateWithoutMataKuliahInput>
  }

  export type KurikulumUpdateWithoutMataKuliahInput = {
    nama?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programStudi?: ProgramStudiUpdateOneRequiredWithoutKurikulumNestedInput
    cpl?: CPLUpdateManyWithoutKurikulumNestedInput
    piGroups?: PIGroupUpdateManyWithoutKurikulumNestedInput
  }

  export type KurikulumUncheckedUpdateWithoutMataKuliahInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program_studi_id?: IntFieldUpdateOperationsInput | number
    cpl?: CPLUncheckedUpdateManyWithoutKurikulumNestedInput
    piGroups?: PIGroupUncheckedUpdateManyWithoutKurikulumNestedInput
  }

  export type KelasUpsertWithWhereUniqueWithoutMataKuliahInput = {
    where: KelasWhereUniqueInput
    update: XOR<KelasUpdateWithoutMataKuliahInput, KelasUncheckedUpdateWithoutMataKuliahInput>
    create: XOR<KelasCreateWithoutMataKuliahInput, KelasUncheckedCreateWithoutMataKuliahInput>
  }

  export type KelasUpdateWithWhereUniqueWithoutMataKuliahInput = {
    where: KelasWhereUniqueInput
    data: XOR<KelasUpdateWithoutMataKuliahInput, KelasUncheckedUpdateWithoutMataKuliahInput>
  }

  export type KelasUpdateManyWithWhereWithoutMataKuliahInput = {
    where: KelasScalarWhereInput
    data: XOR<KelasUpdateManyMutationInput, KelasUncheckedUpdateManyWithoutMataKuliahInput>
  }

  export type KelasScalarWhereInput = {
    AND?: KelasScalarWhereInput | KelasScalarWhereInput[]
    OR?: KelasScalarWhereInput[]
    NOT?: KelasScalarWhereInput | KelasScalarWhereInput[]
    id?: IntFilter<"Kelas"> | number
    nama_kelas?: StringFilter<"Kelas"> | string
    createdAt?: DateTimeFilter<"Kelas"> | Date | string
    updatedAt?: DateTimeFilter<"Kelas"> | Date | string
    mata_kuliah_id?: IntFilter<"Kelas"> | number
    tahun_ajaran_id?: IntFilter<"Kelas"> | number
  }

  export type KurikulumCreateWithoutPiGroupsInput = {
    nama: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    programStudi: ProgramStudiCreateNestedOneWithoutKurikulumInput
    mataKuliah?: MataKuliahCreateNestedManyWithoutKurikulumInput
    cpl?: CPLCreateNestedManyWithoutKurikulumInput
  }

  export type KurikulumUncheckedCreateWithoutPiGroupsInput = {
    id?: number
    nama: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    program_studi_id: number
    mataKuliah?: MataKuliahUncheckedCreateNestedManyWithoutKurikulumInput
    cpl?: CPLUncheckedCreateNestedManyWithoutKurikulumInput
  }

  export type KurikulumCreateOrConnectWithoutPiGroupsInput = {
    where: KurikulumWhereUniqueInput
    create: XOR<KurikulumCreateWithoutPiGroupsInput, KurikulumUncheckedCreateWithoutPiGroupsInput>
  }

  export type PerformanceIndicatorCreateWithoutPiGroupInput = {
    kode_pi: string
    deskripsi: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cpmkMap?: CPMK_PI_MapCreateNestedManyWithoutPiInput
  }

  export type PerformanceIndicatorUncheckedCreateWithoutPiGroupInput = {
    id?: number
    kode_pi: string
    deskripsi: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cpmkMap?: CPMK_PI_MapUncheckedCreateNestedManyWithoutPiInput
  }

  export type PerformanceIndicatorCreateOrConnectWithoutPiGroupInput = {
    where: PerformanceIndicatorWhereUniqueInput
    create: XOR<PerformanceIndicatorCreateWithoutPiGroupInput, PerformanceIndicatorUncheckedCreateWithoutPiGroupInput>
  }

  export type PerformanceIndicatorCreateManyPiGroupInputEnvelope = {
    data: PerformanceIndicatorCreateManyPiGroupInput | PerformanceIndicatorCreateManyPiGroupInput[]
    skipDuplicates?: boolean
  }

  export type CPLCreateWithoutPiGroupInput = {
    kode_cpl: string
    deskripsi: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kurikulum: KurikulumCreateNestedOneWithoutCplInput
  }

  export type CPLUncheckedCreateWithoutPiGroupInput = {
    id?: number
    kode_cpl: string
    deskripsi: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kurikulum_id: number
  }

  export type CPLCreateOrConnectWithoutPiGroupInput = {
    where: CPLWhereUniqueInput
    create: XOR<CPLCreateWithoutPiGroupInput, CPLUncheckedCreateWithoutPiGroupInput>
  }

  export type CPLCreateManyPiGroupInputEnvelope = {
    data: CPLCreateManyPiGroupInput | CPLCreateManyPiGroupInput[]
    skipDuplicates?: boolean
  }

  export type KurikulumUpsertWithoutPiGroupsInput = {
    update: XOR<KurikulumUpdateWithoutPiGroupsInput, KurikulumUncheckedUpdateWithoutPiGroupsInput>
    create: XOR<KurikulumCreateWithoutPiGroupsInput, KurikulumUncheckedCreateWithoutPiGroupsInput>
    where?: KurikulumWhereInput
  }

  export type KurikulumUpdateToOneWithWhereWithoutPiGroupsInput = {
    where?: KurikulumWhereInput
    data: XOR<KurikulumUpdateWithoutPiGroupsInput, KurikulumUncheckedUpdateWithoutPiGroupsInput>
  }

  export type KurikulumUpdateWithoutPiGroupsInput = {
    nama?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programStudi?: ProgramStudiUpdateOneRequiredWithoutKurikulumNestedInput
    mataKuliah?: MataKuliahUpdateManyWithoutKurikulumNestedInput
    cpl?: CPLUpdateManyWithoutKurikulumNestedInput
  }

  export type KurikulumUncheckedUpdateWithoutPiGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program_studi_id?: IntFieldUpdateOperationsInput | number
    mataKuliah?: MataKuliahUncheckedUpdateManyWithoutKurikulumNestedInput
    cpl?: CPLUncheckedUpdateManyWithoutKurikulumNestedInput
  }

  export type PerformanceIndicatorUpsertWithWhereUniqueWithoutPiGroupInput = {
    where: PerformanceIndicatorWhereUniqueInput
    update: XOR<PerformanceIndicatorUpdateWithoutPiGroupInput, PerformanceIndicatorUncheckedUpdateWithoutPiGroupInput>
    create: XOR<PerformanceIndicatorCreateWithoutPiGroupInput, PerformanceIndicatorUncheckedCreateWithoutPiGroupInput>
  }

  export type PerformanceIndicatorUpdateWithWhereUniqueWithoutPiGroupInput = {
    where: PerformanceIndicatorWhereUniqueInput
    data: XOR<PerformanceIndicatorUpdateWithoutPiGroupInput, PerformanceIndicatorUncheckedUpdateWithoutPiGroupInput>
  }

  export type PerformanceIndicatorUpdateManyWithWhereWithoutPiGroupInput = {
    where: PerformanceIndicatorScalarWhereInput
    data: XOR<PerformanceIndicatorUpdateManyMutationInput, PerformanceIndicatorUncheckedUpdateManyWithoutPiGroupInput>
  }

  export type PerformanceIndicatorScalarWhereInput = {
    AND?: PerformanceIndicatorScalarWhereInput | PerformanceIndicatorScalarWhereInput[]
    OR?: PerformanceIndicatorScalarWhereInput[]
    NOT?: PerformanceIndicatorScalarWhereInput | PerformanceIndicatorScalarWhereInput[]
    id?: IntFilter<"PerformanceIndicator"> | number
    kode_pi?: StringFilter<"PerformanceIndicator"> | string
    deskripsi?: StringFilter<"PerformanceIndicator"> | string
    is_locked?: BoolFilter<"PerformanceIndicator"> | boolean
    createdAt?: DateTimeFilter<"PerformanceIndicator"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceIndicator"> | Date | string
    pi_group_id?: IntFilter<"PerformanceIndicator"> | number
  }

  export type CPLUpsertWithWhereUniqueWithoutPiGroupInput = {
    where: CPLWhereUniqueInput
    update: XOR<CPLUpdateWithoutPiGroupInput, CPLUncheckedUpdateWithoutPiGroupInput>
    create: XOR<CPLCreateWithoutPiGroupInput, CPLUncheckedCreateWithoutPiGroupInput>
  }

  export type CPLUpdateWithWhereUniqueWithoutPiGroupInput = {
    where: CPLWhereUniqueInput
    data: XOR<CPLUpdateWithoutPiGroupInput, CPLUncheckedUpdateWithoutPiGroupInput>
  }

  export type CPLUpdateManyWithWhereWithoutPiGroupInput = {
    where: CPLScalarWhereInput
    data: XOR<CPLUpdateManyMutationInput, CPLUncheckedUpdateManyWithoutPiGroupInput>
  }

  export type PIGroupCreateWithoutIndicatorsInput = {
    kode_grup: string
    nama_grup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kurikulum: KurikulumCreateNestedOneWithoutPiGroupsInput
    cpl?: CPLCreateNestedManyWithoutPiGroupInput
  }

  export type PIGroupUncheckedCreateWithoutIndicatorsInput = {
    id?: number
    kode_grup: string
    nama_grup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kurikulum_id: number
    cpl?: CPLUncheckedCreateNestedManyWithoutPiGroupInput
  }

  export type PIGroupCreateOrConnectWithoutIndicatorsInput = {
    where: PIGroupWhereUniqueInput
    create: XOR<PIGroupCreateWithoutIndicatorsInput, PIGroupUncheckedCreateWithoutIndicatorsInput>
  }

  export type CPMK_PI_MapCreateWithoutPiInput = {
    cpmk: CPMKCreateNestedOneWithoutPiMapInput
  }

  export type CPMK_PI_MapUncheckedCreateWithoutPiInput = {
    cpmk_id: number
  }

  export type CPMK_PI_MapCreateOrConnectWithoutPiInput = {
    where: CPMK_PI_MapWhereUniqueInput
    create: XOR<CPMK_PI_MapCreateWithoutPiInput, CPMK_PI_MapUncheckedCreateWithoutPiInput>
  }

  export type CPMK_PI_MapCreateManyPiInputEnvelope = {
    data: CPMK_PI_MapCreateManyPiInput | CPMK_PI_MapCreateManyPiInput[]
    skipDuplicates?: boolean
  }

  export type PIGroupUpsertWithoutIndicatorsInput = {
    update: XOR<PIGroupUpdateWithoutIndicatorsInput, PIGroupUncheckedUpdateWithoutIndicatorsInput>
    create: XOR<PIGroupCreateWithoutIndicatorsInput, PIGroupUncheckedCreateWithoutIndicatorsInput>
    where?: PIGroupWhereInput
  }

  export type PIGroupUpdateToOneWithWhereWithoutIndicatorsInput = {
    where?: PIGroupWhereInput
    data: XOR<PIGroupUpdateWithoutIndicatorsInput, PIGroupUncheckedUpdateWithoutIndicatorsInput>
  }

  export type PIGroupUpdateWithoutIndicatorsInput = {
    kode_grup?: StringFieldUpdateOperationsInput | string
    nama_grup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kurikulum?: KurikulumUpdateOneRequiredWithoutPiGroupsNestedInput
    cpl?: CPLUpdateManyWithoutPiGroupNestedInput
  }

  export type PIGroupUncheckedUpdateWithoutIndicatorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_grup?: StringFieldUpdateOperationsInput | string
    nama_grup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kurikulum_id?: IntFieldUpdateOperationsInput | number
    cpl?: CPLUncheckedUpdateManyWithoutPiGroupNestedInput
  }

  export type CPMK_PI_MapUpsertWithWhereUniqueWithoutPiInput = {
    where: CPMK_PI_MapWhereUniqueInput
    update: XOR<CPMK_PI_MapUpdateWithoutPiInput, CPMK_PI_MapUncheckedUpdateWithoutPiInput>
    create: XOR<CPMK_PI_MapCreateWithoutPiInput, CPMK_PI_MapUncheckedCreateWithoutPiInput>
  }

  export type CPMK_PI_MapUpdateWithWhereUniqueWithoutPiInput = {
    where: CPMK_PI_MapWhereUniqueInput
    data: XOR<CPMK_PI_MapUpdateWithoutPiInput, CPMK_PI_MapUncheckedUpdateWithoutPiInput>
  }

  export type CPMK_PI_MapUpdateManyWithWhereWithoutPiInput = {
    where: CPMK_PI_MapScalarWhereInput
    data: XOR<CPMK_PI_MapUpdateManyMutationInput, CPMK_PI_MapUncheckedUpdateManyWithoutPiInput>
  }

  export type CPMK_PI_MapScalarWhereInput = {
    AND?: CPMK_PI_MapScalarWhereInput | CPMK_PI_MapScalarWhereInput[]
    OR?: CPMK_PI_MapScalarWhereInput[]
    NOT?: CPMK_PI_MapScalarWhereInput | CPMK_PI_MapScalarWhereInput[]
    cpmk_id?: IntFilter<"CPMK_PI_Map"> | number
    pi_id?: IntFilter<"CPMK_PI_Map"> | number
  }

  export type KurikulumCreateWithoutCplInput = {
    nama: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    programStudi: ProgramStudiCreateNestedOneWithoutKurikulumInput
    mataKuliah?: MataKuliahCreateNestedManyWithoutKurikulumInput
    piGroups?: PIGroupCreateNestedManyWithoutKurikulumInput
  }

  export type KurikulumUncheckedCreateWithoutCplInput = {
    id?: number
    nama: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
    program_studi_id: number
    mataKuliah?: MataKuliahUncheckedCreateNestedManyWithoutKurikulumInput
    piGroups?: PIGroupUncheckedCreateNestedManyWithoutKurikulumInput
  }

  export type KurikulumCreateOrConnectWithoutCplInput = {
    where: KurikulumWhereUniqueInput
    create: XOR<KurikulumCreateWithoutCplInput, KurikulumUncheckedCreateWithoutCplInput>
  }

  export type PIGroupCreateWithoutCplInput = {
    kode_grup: string
    nama_grup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kurikulum: KurikulumCreateNestedOneWithoutPiGroupsInput
    indicators?: PerformanceIndicatorCreateNestedManyWithoutPiGroupInput
  }

  export type PIGroupUncheckedCreateWithoutCplInput = {
    id?: number
    kode_grup: string
    nama_grup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kurikulum_id: number
    indicators?: PerformanceIndicatorUncheckedCreateNestedManyWithoutPiGroupInput
  }

  export type PIGroupCreateOrConnectWithoutCplInput = {
    where: PIGroupWhereUniqueInput
    create: XOR<PIGroupCreateWithoutCplInput, PIGroupUncheckedCreateWithoutCplInput>
  }

  export type KurikulumUpsertWithoutCplInput = {
    update: XOR<KurikulumUpdateWithoutCplInput, KurikulumUncheckedUpdateWithoutCplInput>
    create: XOR<KurikulumCreateWithoutCplInput, KurikulumUncheckedCreateWithoutCplInput>
    where?: KurikulumWhereInput
  }

  export type KurikulumUpdateToOneWithWhereWithoutCplInput = {
    where?: KurikulumWhereInput
    data: XOR<KurikulumUpdateWithoutCplInput, KurikulumUncheckedUpdateWithoutCplInput>
  }

  export type KurikulumUpdateWithoutCplInput = {
    nama?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programStudi?: ProgramStudiUpdateOneRequiredWithoutKurikulumNestedInput
    mataKuliah?: MataKuliahUpdateManyWithoutKurikulumNestedInput
    piGroups?: PIGroupUpdateManyWithoutKurikulumNestedInput
  }

  export type KurikulumUncheckedUpdateWithoutCplInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program_studi_id?: IntFieldUpdateOperationsInput | number
    mataKuliah?: MataKuliahUncheckedUpdateManyWithoutKurikulumNestedInput
    piGroups?: PIGroupUncheckedUpdateManyWithoutKurikulumNestedInput
  }

  export type PIGroupUpsertWithoutCplInput = {
    update: XOR<PIGroupUpdateWithoutCplInput, PIGroupUncheckedUpdateWithoutCplInput>
    create: XOR<PIGroupCreateWithoutCplInput, PIGroupUncheckedCreateWithoutCplInput>
    where?: PIGroupWhereInput
  }

  export type PIGroupUpdateToOneWithWhereWithoutCplInput = {
    where?: PIGroupWhereInput
    data: XOR<PIGroupUpdateWithoutCplInput, PIGroupUncheckedUpdateWithoutCplInput>
  }

  export type PIGroupUpdateWithoutCplInput = {
    kode_grup?: StringFieldUpdateOperationsInput | string
    nama_grup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kurikulum?: KurikulumUpdateOneRequiredWithoutPiGroupsNestedInput
    indicators?: PerformanceIndicatorUpdateManyWithoutPiGroupNestedInput
  }

  export type PIGroupUncheckedUpdateWithoutCplInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_grup?: StringFieldUpdateOperationsInput | string
    nama_grup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kurikulum_id?: IntFieldUpdateOperationsInput | number
    indicators?: PerformanceIndicatorUncheckedUpdateManyWithoutPiGroupNestedInput
  }

  export type KelasCreateWithoutTahunAjaranInput = {
    nama_kelas: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mataKuliah: MataKuliahCreateNestedOneWithoutKelasInput
    dosenPengampu?: DosenPengampuCreateNestedManyWithoutKelasInput
    pesertaKelas?: PesertaKelasCreateNestedManyWithoutKelasInput
    rps?: RPSCreateNestedManyWithoutKelasInput
    cpmk?: CPMKCreateNestedManyWithoutKelasInput
  }

  export type KelasUncheckedCreateWithoutTahunAjaranInput = {
    id?: number
    nama_kelas: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mata_kuliah_id: number
    dosenPengampu?: DosenPengampuUncheckedCreateNestedManyWithoutKelasInput
    pesertaKelas?: PesertaKelasUncheckedCreateNestedManyWithoutKelasInput
    rps?: RPSUncheckedCreateNestedManyWithoutKelasInput
    cpmk?: CPMKUncheckedCreateNestedManyWithoutKelasInput
  }

  export type KelasCreateOrConnectWithoutTahunAjaranInput = {
    where: KelasWhereUniqueInput
    create: XOR<KelasCreateWithoutTahunAjaranInput, KelasUncheckedCreateWithoutTahunAjaranInput>
  }

  export type KelasCreateManyTahunAjaranInputEnvelope = {
    data: KelasCreateManyTahunAjaranInput | KelasCreateManyTahunAjaranInput[]
    skipDuplicates?: boolean
  }

  export type KelasUpsertWithWhereUniqueWithoutTahunAjaranInput = {
    where: KelasWhereUniqueInput
    update: XOR<KelasUpdateWithoutTahunAjaranInput, KelasUncheckedUpdateWithoutTahunAjaranInput>
    create: XOR<KelasCreateWithoutTahunAjaranInput, KelasUncheckedCreateWithoutTahunAjaranInput>
  }

  export type KelasUpdateWithWhereUniqueWithoutTahunAjaranInput = {
    where: KelasWhereUniqueInput
    data: XOR<KelasUpdateWithoutTahunAjaranInput, KelasUncheckedUpdateWithoutTahunAjaranInput>
  }

  export type KelasUpdateManyWithWhereWithoutTahunAjaranInput = {
    where: KelasScalarWhereInput
    data: XOR<KelasUpdateManyMutationInput, KelasUncheckedUpdateManyWithoutTahunAjaranInput>
  }

  export type MataKuliahCreateWithoutKelasInput = {
    kode_mk: string
    nama: string
    sks: number
    createdAt?: Date | string
    updatedAt?: Date | string
    kurikulum: KurikulumCreateNestedOneWithoutMataKuliahInput
  }

  export type MataKuliahUncheckedCreateWithoutKelasInput = {
    id?: number
    kode_mk: string
    nama: string
    sks: number
    createdAt?: Date | string
    updatedAt?: Date | string
    kurikulum_id: number
  }

  export type MataKuliahCreateOrConnectWithoutKelasInput = {
    where: MataKuliahWhereUniqueInput
    create: XOR<MataKuliahCreateWithoutKelasInput, MataKuliahUncheckedCreateWithoutKelasInput>
  }

  export type TahunAjaranCreateWithoutKelasInput = {
    tahun: string
    semester: $Enums.Semester
  }

  export type TahunAjaranUncheckedCreateWithoutKelasInput = {
    id?: number
    tahun: string
    semester: $Enums.Semester
  }

  export type TahunAjaranCreateOrConnectWithoutKelasInput = {
    where: TahunAjaranWhereUniqueInput
    create: XOR<TahunAjaranCreateWithoutKelasInput, TahunAjaranUncheckedCreateWithoutKelasInput>
  }

  export type DosenPengampuCreateWithoutKelasInput = {
    createdAt?: Date | string
    dosen: UserCreateNestedOneWithoutDosenPengampuInput
  }

  export type DosenPengampuUncheckedCreateWithoutKelasInput = {
    id?: number
    createdAt?: Date | string
    dosen_id: number
  }

  export type DosenPengampuCreateOrConnectWithoutKelasInput = {
    where: DosenPengampuWhereUniqueInput
    create: XOR<DosenPengampuCreateWithoutKelasInput, DosenPengampuUncheckedCreateWithoutKelasInput>
  }

  export type DosenPengampuCreateManyKelasInputEnvelope = {
    data: DosenPengampuCreateManyKelasInput | DosenPengampuCreateManyKelasInput[]
    skipDuplicates?: boolean
  }

  export type PesertaKelasCreateWithoutKelasInput = {
    createdAt?: Date | string
    mahasiswa: UserCreateNestedOneWithoutPesertaKelasInput
    nilai?: NilaiCreateNestedManyWithoutPesertaKelasInput
  }

  export type PesertaKelasUncheckedCreateWithoutKelasInput = {
    id?: number
    createdAt?: Date | string
    mahasiswa_id: number
    nilai?: NilaiUncheckedCreateNestedManyWithoutPesertaKelasInput
  }

  export type PesertaKelasCreateOrConnectWithoutKelasInput = {
    where: PesertaKelasWhereUniqueInput
    create: XOR<PesertaKelasCreateWithoutKelasInput, PesertaKelasUncheckedCreateWithoutKelasInput>
  }

  export type PesertaKelasCreateManyKelasInputEnvelope = {
    data: PesertaKelasCreateManyKelasInput | PesertaKelasCreateManyKelasInput[]
    skipDuplicates?: boolean
  }

  export type RPSCreateWithoutKelasInput = {
    file_path: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RPSUncheckedCreateWithoutKelasInput = {
    id?: number
    file_path: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RPSCreateOrConnectWithoutKelasInput = {
    where: RPSWhereUniqueInput
    create: XOR<RPSCreateWithoutKelasInput, RPSUncheckedCreateWithoutKelasInput>
  }

  export type RPSCreateManyKelasInputEnvelope = {
    data: RPSCreateManyKelasInput | RPSCreateManyKelasInput[]
    skipDuplicates?: boolean
  }

  export type CPMKCreateWithoutKelasInput = {
    kode_cpmk: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    komponenPenilaian?: KomponenPenilaianCreateNestedManyWithoutCpmkInput
    piMap?: CPMK_PI_MapCreateNestedManyWithoutCpmkInput
  }

  export type CPMKUncheckedCreateWithoutKelasInput = {
    id?: number
    kode_cpmk: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    komponenPenilaian?: KomponenPenilaianUncheckedCreateNestedManyWithoutCpmkInput
    piMap?: CPMK_PI_MapUncheckedCreateNestedManyWithoutCpmkInput
  }

  export type CPMKCreateOrConnectWithoutKelasInput = {
    where: CPMKWhereUniqueInput
    create: XOR<CPMKCreateWithoutKelasInput, CPMKUncheckedCreateWithoutKelasInput>
  }

  export type CPMKCreateManyKelasInputEnvelope = {
    data: CPMKCreateManyKelasInput | CPMKCreateManyKelasInput[]
    skipDuplicates?: boolean
  }

  export type MataKuliahUpsertWithoutKelasInput = {
    update: XOR<MataKuliahUpdateWithoutKelasInput, MataKuliahUncheckedUpdateWithoutKelasInput>
    create: XOR<MataKuliahCreateWithoutKelasInput, MataKuliahUncheckedCreateWithoutKelasInput>
    where?: MataKuliahWhereInput
  }

  export type MataKuliahUpdateToOneWithWhereWithoutKelasInput = {
    where?: MataKuliahWhereInput
    data: XOR<MataKuliahUpdateWithoutKelasInput, MataKuliahUncheckedUpdateWithoutKelasInput>
  }

  export type MataKuliahUpdateWithoutKelasInput = {
    kode_mk?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    sks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kurikulum?: KurikulumUpdateOneRequiredWithoutMataKuliahNestedInput
  }

  export type MataKuliahUncheckedUpdateWithoutKelasInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_mk?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    sks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kurikulum_id?: IntFieldUpdateOperationsInput | number
  }

  export type TahunAjaranUpsertWithoutKelasInput = {
    update: XOR<TahunAjaranUpdateWithoutKelasInput, TahunAjaranUncheckedUpdateWithoutKelasInput>
    create: XOR<TahunAjaranCreateWithoutKelasInput, TahunAjaranUncheckedCreateWithoutKelasInput>
    where?: TahunAjaranWhereInput
  }

  export type TahunAjaranUpdateToOneWithWhereWithoutKelasInput = {
    where?: TahunAjaranWhereInput
    data: XOR<TahunAjaranUpdateWithoutKelasInput, TahunAjaranUncheckedUpdateWithoutKelasInput>
  }

  export type TahunAjaranUpdateWithoutKelasInput = {
    tahun?: StringFieldUpdateOperationsInput | string
    semester?: EnumSemesterFieldUpdateOperationsInput | $Enums.Semester
  }

  export type TahunAjaranUncheckedUpdateWithoutKelasInput = {
    id?: IntFieldUpdateOperationsInput | number
    tahun?: StringFieldUpdateOperationsInput | string
    semester?: EnumSemesterFieldUpdateOperationsInput | $Enums.Semester
  }

  export type DosenPengampuUpsertWithWhereUniqueWithoutKelasInput = {
    where: DosenPengampuWhereUniqueInput
    update: XOR<DosenPengampuUpdateWithoutKelasInput, DosenPengampuUncheckedUpdateWithoutKelasInput>
    create: XOR<DosenPengampuCreateWithoutKelasInput, DosenPengampuUncheckedCreateWithoutKelasInput>
  }

  export type DosenPengampuUpdateWithWhereUniqueWithoutKelasInput = {
    where: DosenPengampuWhereUniqueInput
    data: XOR<DosenPengampuUpdateWithoutKelasInput, DosenPengampuUncheckedUpdateWithoutKelasInput>
  }

  export type DosenPengampuUpdateManyWithWhereWithoutKelasInput = {
    where: DosenPengampuScalarWhereInput
    data: XOR<DosenPengampuUpdateManyMutationInput, DosenPengampuUncheckedUpdateManyWithoutKelasInput>
  }

  export type PesertaKelasUpsertWithWhereUniqueWithoutKelasInput = {
    where: PesertaKelasWhereUniqueInput
    update: XOR<PesertaKelasUpdateWithoutKelasInput, PesertaKelasUncheckedUpdateWithoutKelasInput>
    create: XOR<PesertaKelasCreateWithoutKelasInput, PesertaKelasUncheckedCreateWithoutKelasInput>
  }

  export type PesertaKelasUpdateWithWhereUniqueWithoutKelasInput = {
    where: PesertaKelasWhereUniqueInput
    data: XOR<PesertaKelasUpdateWithoutKelasInput, PesertaKelasUncheckedUpdateWithoutKelasInput>
  }

  export type PesertaKelasUpdateManyWithWhereWithoutKelasInput = {
    where: PesertaKelasScalarWhereInput
    data: XOR<PesertaKelasUpdateManyMutationInput, PesertaKelasUncheckedUpdateManyWithoutKelasInput>
  }

  export type RPSUpsertWithWhereUniqueWithoutKelasInput = {
    where: RPSWhereUniqueInput
    update: XOR<RPSUpdateWithoutKelasInput, RPSUncheckedUpdateWithoutKelasInput>
    create: XOR<RPSCreateWithoutKelasInput, RPSUncheckedCreateWithoutKelasInput>
  }

  export type RPSUpdateWithWhereUniqueWithoutKelasInput = {
    where: RPSWhereUniqueInput
    data: XOR<RPSUpdateWithoutKelasInput, RPSUncheckedUpdateWithoutKelasInput>
  }

  export type RPSUpdateManyWithWhereWithoutKelasInput = {
    where: RPSScalarWhereInput
    data: XOR<RPSUpdateManyMutationInput, RPSUncheckedUpdateManyWithoutKelasInput>
  }

  export type RPSScalarWhereInput = {
    AND?: RPSScalarWhereInput | RPSScalarWhereInput[]
    OR?: RPSScalarWhereInput[]
    NOT?: RPSScalarWhereInput | RPSScalarWhereInput[]
    id?: IntFilter<"RPS"> | number
    file_path?: StringFilter<"RPS"> | string
    is_locked?: BoolFilter<"RPS"> | boolean
    createdAt?: DateTimeFilter<"RPS"> | Date | string
    updatedAt?: DateTimeFilter<"RPS"> | Date | string
    kelas_id?: IntFilter<"RPS"> | number
  }

  export type CPMKUpsertWithWhereUniqueWithoutKelasInput = {
    where: CPMKWhereUniqueInput
    update: XOR<CPMKUpdateWithoutKelasInput, CPMKUncheckedUpdateWithoutKelasInput>
    create: XOR<CPMKCreateWithoutKelasInput, CPMKUncheckedCreateWithoutKelasInput>
  }

  export type CPMKUpdateWithWhereUniqueWithoutKelasInput = {
    where: CPMKWhereUniqueInput
    data: XOR<CPMKUpdateWithoutKelasInput, CPMKUncheckedUpdateWithoutKelasInput>
  }

  export type CPMKUpdateManyWithWhereWithoutKelasInput = {
    where: CPMKScalarWhereInput
    data: XOR<CPMKUpdateManyMutationInput, CPMKUncheckedUpdateManyWithoutKelasInput>
  }

  export type CPMKScalarWhereInput = {
    AND?: CPMKScalarWhereInput | CPMKScalarWhereInput[]
    OR?: CPMKScalarWhereInput[]
    NOT?: CPMKScalarWhereInput | CPMKScalarWhereInput[]
    id?: IntFilter<"CPMK"> | number
    kode_cpmk?: StringFilter<"CPMK"> | string
    is_locked?: BoolFilter<"CPMK"> | boolean
    createdAt?: DateTimeFilter<"CPMK"> | Date | string
    updatedAt?: DateTimeFilter<"CPMK"> | Date | string
    kelas_id?: IntFilter<"CPMK"> | number
  }

  export type KelasCreateWithoutDosenPengampuInput = {
    nama_kelas: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mataKuliah: MataKuliahCreateNestedOneWithoutKelasInput
    tahunAjaran: TahunAjaranCreateNestedOneWithoutKelasInput
    pesertaKelas?: PesertaKelasCreateNestedManyWithoutKelasInput
    rps?: RPSCreateNestedManyWithoutKelasInput
    cpmk?: CPMKCreateNestedManyWithoutKelasInput
  }

  export type KelasUncheckedCreateWithoutDosenPengampuInput = {
    id?: number
    nama_kelas: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mata_kuliah_id: number
    tahun_ajaran_id: number
    pesertaKelas?: PesertaKelasUncheckedCreateNestedManyWithoutKelasInput
    rps?: RPSUncheckedCreateNestedManyWithoutKelasInput
    cpmk?: CPMKUncheckedCreateNestedManyWithoutKelasInput
  }

  export type KelasCreateOrConnectWithoutDosenPengampuInput = {
    where: KelasWhereUniqueInput
    create: XOR<KelasCreateWithoutDosenPengampuInput, KelasUncheckedCreateWithoutDosenPengampuInput>
  }

  export type UserCreateWithoutDosenPengampuInput = {
    username: string
    password_hash: string
    nama: string
    role: $Enums.UserRole
    programStudi: ProgramStudiCreateNestedOneWithoutUsersInput
    pesertaKelas?: PesertaKelasCreateNestedManyWithoutMahasiswaInput
  }

  export type UserUncheckedCreateWithoutDosenPengampuInput = {
    id?: number
    username: string
    password_hash: string
    nama: string
    role: $Enums.UserRole
    program_studi_id: number
    pesertaKelas?: PesertaKelasUncheckedCreateNestedManyWithoutMahasiswaInput
  }

  export type UserCreateOrConnectWithoutDosenPengampuInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDosenPengampuInput, UserUncheckedCreateWithoutDosenPengampuInput>
  }

  export type KelasUpsertWithoutDosenPengampuInput = {
    update: XOR<KelasUpdateWithoutDosenPengampuInput, KelasUncheckedUpdateWithoutDosenPengampuInput>
    create: XOR<KelasCreateWithoutDosenPengampuInput, KelasUncheckedCreateWithoutDosenPengampuInput>
    where?: KelasWhereInput
  }

  export type KelasUpdateToOneWithWhereWithoutDosenPengampuInput = {
    where?: KelasWhereInput
    data: XOR<KelasUpdateWithoutDosenPengampuInput, KelasUncheckedUpdateWithoutDosenPengampuInput>
  }

  export type KelasUpdateWithoutDosenPengampuInput = {
    nama_kelas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mataKuliah?: MataKuliahUpdateOneRequiredWithoutKelasNestedInput
    tahunAjaran?: TahunAjaranUpdateOneRequiredWithoutKelasNestedInput
    pesertaKelas?: PesertaKelasUpdateManyWithoutKelasNestedInput
    rps?: RPSUpdateManyWithoutKelasNestedInput
    cpmk?: CPMKUpdateManyWithoutKelasNestedInput
  }

  export type KelasUncheckedUpdateWithoutDosenPengampuInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_kelas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mata_kuliah_id?: IntFieldUpdateOperationsInput | number
    tahun_ajaran_id?: IntFieldUpdateOperationsInput | number
    pesertaKelas?: PesertaKelasUncheckedUpdateManyWithoutKelasNestedInput
    rps?: RPSUncheckedUpdateManyWithoutKelasNestedInput
    cpmk?: CPMKUncheckedUpdateManyWithoutKelasNestedInput
  }

  export type UserUpsertWithoutDosenPengampuInput = {
    update: XOR<UserUpdateWithoutDosenPengampuInput, UserUncheckedUpdateWithoutDosenPengampuInput>
    create: XOR<UserCreateWithoutDosenPengampuInput, UserUncheckedCreateWithoutDosenPengampuInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDosenPengampuInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDosenPengampuInput, UserUncheckedUpdateWithoutDosenPengampuInput>
  }

  export type UserUpdateWithoutDosenPengampuInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programStudi?: ProgramStudiUpdateOneRequiredWithoutUsersNestedInput
    pesertaKelas?: PesertaKelasUpdateManyWithoutMahasiswaNestedInput
  }

  export type UserUncheckedUpdateWithoutDosenPengampuInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    program_studi_id?: IntFieldUpdateOperationsInput | number
    pesertaKelas?: PesertaKelasUncheckedUpdateManyWithoutMahasiswaNestedInput
  }

  export type KelasCreateWithoutPesertaKelasInput = {
    nama_kelas: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mataKuliah: MataKuliahCreateNestedOneWithoutKelasInput
    tahunAjaran: TahunAjaranCreateNestedOneWithoutKelasInput
    dosenPengampu?: DosenPengampuCreateNestedManyWithoutKelasInput
    rps?: RPSCreateNestedManyWithoutKelasInput
    cpmk?: CPMKCreateNestedManyWithoutKelasInput
  }

  export type KelasUncheckedCreateWithoutPesertaKelasInput = {
    id?: number
    nama_kelas: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mata_kuliah_id: number
    tahun_ajaran_id: number
    dosenPengampu?: DosenPengampuUncheckedCreateNestedManyWithoutKelasInput
    rps?: RPSUncheckedCreateNestedManyWithoutKelasInput
    cpmk?: CPMKUncheckedCreateNestedManyWithoutKelasInput
  }

  export type KelasCreateOrConnectWithoutPesertaKelasInput = {
    where: KelasWhereUniqueInput
    create: XOR<KelasCreateWithoutPesertaKelasInput, KelasUncheckedCreateWithoutPesertaKelasInput>
  }

  export type UserCreateWithoutPesertaKelasInput = {
    username: string
    password_hash: string
    nama: string
    role: $Enums.UserRole
    programStudi: ProgramStudiCreateNestedOneWithoutUsersInput
    dosenPengampu?: DosenPengampuCreateNestedManyWithoutDosenInput
  }

  export type UserUncheckedCreateWithoutPesertaKelasInput = {
    id?: number
    username: string
    password_hash: string
    nama: string
    role: $Enums.UserRole
    program_studi_id: number
    dosenPengampu?: DosenPengampuUncheckedCreateNestedManyWithoutDosenInput
  }

  export type UserCreateOrConnectWithoutPesertaKelasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPesertaKelasInput, UserUncheckedCreateWithoutPesertaKelasInput>
  }

  export type NilaiCreateWithoutPesertaKelasInput = {
    nilai_angka: number
    createdAt?: Date | string
    updatedAt?: Date | string
    komponenPenilaian: KomponenPenilaianCreateNestedOneWithoutNilaiInput
  }

  export type NilaiUncheckedCreateWithoutPesertaKelasInput = {
    id?: number
    nilai_angka: number
    createdAt?: Date | string
    updatedAt?: Date | string
    komponen_penilaian_id: number
  }

  export type NilaiCreateOrConnectWithoutPesertaKelasInput = {
    where: NilaiWhereUniqueInput
    create: XOR<NilaiCreateWithoutPesertaKelasInput, NilaiUncheckedCreateWithoutPesertaKelasInput>
  }

  export type NilaiCreateManyPesertaKelasInputEnvelope = {
    data: NilaiCreateManyPesertaKelasInput | NilaiCreateManyPesertaKelasInput[]
    skipDuplicates?: boolean
  }

  export type KelasUpsertWithoutPesertaKelasInput = {
    update: XOR<KelasUpdateWithoutPesertaKelasInput, KelasUncheckedUpdateWithoutPesertaKelasInput>
    create: XOR<KelasCreateWithoutPesertaKelasInput, KelasUncheckedCreateWithoutPesertaKelasInput>
    where?: KelasWhereInput
  }

  export type KelasUpdateToOneWithWhereWithoutPesertaKelasInput = {
    where?: KelasWhereInput
    data: XOR<KelasUpdateWithoutPesertaKelasInput, KelasUncheckedUpdateWithoutPesertaKelasInput>
  }

  export type KelasUpdateWithoutPesertaKelasInput = {
    nama_kelas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mataKuliah?: MataKuliahUpdateOneRequiredWithoutKelasNestedInput
    tahunAjaran?: TahunAjaranUpdateOneRequiredWithoutKelasNestedInput
    dosenPengampu?: DosenPengampuUpdateManyWithoutKelasNestedInput
    rps?: RPSUpdateManyWithoutKelasNestedInput
    cpmk?: CPMKUpdateManyWithoutKelasNestedInput
  }

  export type KelasUncheckedUpdateWithoutPesertaKelasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_kelas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mata_kuliah_id?: IntFieldUpdateOperationsInput | number
    tahun_ajaran_id?: IntFieldUpdateOperationsInput | number
    dosenPengampu?: DosenPengampuUncheckedUpdateManyWithoutKelasNestedInput
    rps?: RPSUncheckedUpdateManyWithoutKelasNestedInput
    cpmk?: CPMKUncheckedUpdateManyWithoutKelasNestedInput
  }

  export type UserUpsertWithoutPesertaKelasInput = {
    update: XOR<UserUpdateWithoutPesertaKelasInput, UserUncheckedUpdateWithoutPesertaKelasInput>
    create: XOR<UserCreateWithoutPesertaKelasInput, UserUncheckedCreateWithoutPesertaKelasInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPesertaKelasInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPesertaKelasInput, UserUncheckedUpdateWithoutPesertaKelasInput>
  }

  export type UserUpdateWithoutPesertaKelasInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    programStudi?: ProgramStudiUpdateOneRequiredWithoutUsersNestedInput
    dosenPengampu?: DosenPengampuUpdateManyWithoutDosenNestedInput
  }

  export type UserUncheckedUpdateWithoutPesertaKelasInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    program_studi_id?: IntFieldUpdateOperationsInput | number
    dosenPengampu?: DosenPengampuUncheckedUpdateManyWithoutDosenNestedInput
  }

  export type NilaiUpsertWithWhereUniqueWithoutPesertaKelasInput = {
    where: NilaiWhereUniqueInput
    update: XOR<NilaiUpdateWithoutPesertaKelasInput, NilaiUncheckedUpdateWithoutPesertaKelasInput>
    create: XOR<NilaiCreateWithoutPesertaKelasInput, NilaiUncheckedCreateWithoutPesertaKelasInput>
  }

  export type NilaiUpdateWithWhereUniqueWithoutPesertaKelasInput = {
    where: NilaiWhereUniqueInput
    data: XOR<NilaiUpdateWithoutPesertaKelasInput, NilaiUncheckedUpdateWithoutPesertaKelasInput>
  }

  export type NilaiUpdateManyWithWhereWithoutPesertaKelasInput = {
    where: NilaiScalarWhereInput
    data: XOR<NilaiUpdateManyMutationInput, NilaiUncheckedUpdateManyWithoutPesertaKelasInput>
  }

  export type NilaiScalarWhereInput = {
    AND?: NilaiScalarWhereInput | NilaiScalarWhereInput[]
    OR?: NilaiScalarWhereInput[]
    NOT?: NilaiScalarWhereInput | NilaiScalarWhereInput[]
    id?: IntFilter<"Nilai"> | number
    nilai_angka?: FloatFilter<"Nilai"> | number
    createdAt?: DateTimeFilter<"Nilai"> | Date | string
    updatedAt?: DateTimeFilter<"Nilai"> | Date | string
    peserta_kelas_id?: IntFilter<"Nilai"> | number
    komponen_penilaian_id?: IntFilter<"Nilai"> | number
  }

  export type KelasCreateWithoutRpsInput = {
    nama_kelas: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mataKuliah: MataKuliahCreateNestedOneWithoutKelasInput
    tahunAjaran: TahunAjaranCreateNestedOneWithoutKelasInput
    dosenPengampu?: DosenPengampuCreateNestedManyWithoutKelasInput
    pesertaKelas?: PesertaKelasCreateNestedManyWithoutKelasInput
    cpmk?: CPMKCreateNestedManyWithoutKelasInput
  }

  export type KelasUncheckedCreateWithoutRpsInput = {
    id?: number
    nama_kelas: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mata_kuliah_id: number
    tahun_ajaran_id: number
    dosenPengampu?: DosenPengampuUncheckedCreateNestedManyWithoutKelasInput
    pesertaKelas?: PesertaKelasUncheckedCreateNestedManyWithoutKelasInput
    cpmk?: CPMKUncheckedCreateNestedManyWithoutKelasInput
  }

  export type KelasCreateOrConnectWithoutRpsInput = {
    where: KelasWhereUniqueInput
    create: XOR<KelasCreateWithoutRpsInput, KelasUncheckedCreateWithoutRpsInput>
  }

  export type KelasUpsertWithoutRpsInput = {
    update: XOR<KelasUpdateWithoutRpsInput, KelasUncheckedUpdateWithoutRpsInput>
    create: XOR<KelasCreateWithoutRpsInput, KelasUncheckedCreateWithoutRpsInput>
    where?: KelasWhereInput
  }

  export type KelasUpdateToOneWithWhereWithoutRpsInput = {
    where?: KelasWhereInput
    data: XOR<KelasUpdateWithoutRpsInput, KelasUncheckedUpdateWithoutRpsInput>
  }

  export type KelasUpdateWithoutRpsInput = {
    nama_kelas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mataKuliah?: MataKuliahUpdateOneRequiredWithoutKelasNestedInput
    tahunAjaran?: TahunAjaranUpdateOneRequiredWithoutKelasNestedInput
    dosenPengampu?: DosenPengampuUpdateManyWithoutKelasNestedInput
    pesertaKelas?: PesertaKelasUpdateManyWithoutKelasNestedInput
    cpmk?: CPMKUpdateManyWithoutKelasNestedInput
  }

  export type KelasUncheckedUpdateWithoutRpsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_kelas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mata_kuliah_id?: IntFieldUpdateOperationsInput | number
    tahun_ajaran_id?: IntFieldUpdateOperationsInput | number
    dosenPengampu?: DosenPengampuUncheckedUpdateManyWithoutKelasNestedInput
    pesertaKelas?: PesertaKelasUncheckedUpdateManyWithoutKelasNestedInput
    cpmk?: CPMKUncheckedUpdateManyWithoutKelasNestedInput
  }

  export type KelasCreateWithoutCpmkInput = {
    nama_kelas: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mataKuliah: MataKuliahCreateNestedOneWithoutKelasInput
    tahunAjaran: TahunAjaranCreateNestedOneWithoutKelasInput
    dosenPengampu?: DosenPengampuCreateNestedManyWithoutKelasInput
    pesertaKelas?: PesertaKelasCreateNestedManyWithoutKelasInput
    rps?: RPSCreateNestedManyWithoutKelasInput
  }

  export type KelasUncheckedCreateWithoutCpmkInput = {
    id?: number
    nama_kelas: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mata_kuliah_id: number
    tahun_ajaran_id: number
    dosenPengampu?: DosenPengampuUncheckedCreateNestedManyWithoutKelasInput
    pesertaKelas?: PesertaKelasUncheckedCreateNestedManyWithoutKelasInput
    rps?: RPSUncheckedCreateNestedManyWithoutKelasInput
  }

  export type KelasCreateOrConnectWithoutCpmkInput = {
    where: KelasWhereUniqueInput
    create: XOR<KelasCreateWithoutCpmkInput, KelasUncheckedCreateWithoutCpmkInput>
  }

  export type KomponenPenilaianCreateWithoutCpmkInput = {
    nama: string
    bobot: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nilai?: NilaiCreateNestedManyWithoutKomponenPenilaianInput
  }

  export type KomponenPenilaianUncheckedCreateWithoutCpmkInput = {
    id?: number
    nama: string
    bobot: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nilai?: NilaiUncheckedCreateNestedManyWithoutKomponenPenilaianInput
  }

  export type KomponenPenilaianCreateOrConnectWithoutCpmkInput = {
    where: KomponenPenilaianWhereUniqueInput
    create: XOR<KomponenPenilaianCreateWithoutCpmkInput, KomponenPenilaianUncheckedCreateWithoutCpmkInput>
  }

  export type KomponenPenilaianCreateManyCpmkInputEnvelope = {
    data: KomponenPenilaianCreateManyCpmkInput | KomponenPenilaianCreateManyCpmkInput[]
    skipDuplicates?: boolean
  }

  export type CPMK_PI_MapCreateWithoutCpmkInput = {
    pi: PerformanceIndicatorCreateNestedOneWithoutCpmkMapInput
  }

  export type CPMK_PI_MapUncheckedCreateWithoutCpmkInput = {
    pi_id: number
  }

  export type CPMK_PI_MapCreateOrConnectWithoutCpmkInput = {
    where: CPMK_PI_MapWhereUniqueInput
    create: XOR<CPMK_PI_MapCreateWithoutCpmkInput, CPMK_PI_MapUncheckedCreateWithoutCpmkInput>
  }

  export type CPMK_PI_MapCreateManyCpmkInputEnvelope = {
    data: CPMK_PI_MapCreateManyCpmkInput | CPMK_PI_MapCreateManyCpmkInput[]
    skipDuplicates?: boolean
  }

  export type KelasUpsertWithoutCpmkInput = {
    update: XOR<KelasUpdateWithoutCpmkInput, KelasUncheckedUpdateWithoutCpmkInput>
    create: XOR<KelasCreateWithoutCpmkInput, KelasUncheckedCreateWithoutCpmkInput>
    where?: KelasWhereInput
  }

  export type KelasUpdateToOneWithWhereWithoutCpmkInput = {
    where?: KelasWhereInput
    data: XOR<KelasUpdateWithoutCpmkInput, KelasUncheckedUpdateWithoutCpmkInput>
  }

  export type KelasUpdateWithoutCpmkInput = {
    nama_kelas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mataKuliah?: MataKuliahUpdateOneRequiredWithoutKelasNestedInput
    tahunAjaran?: TahunAjaranUpdateOneRequiredWithoutKelasNestedInput
    dosenPengampu?: DosenPengampuUpdateManyWithoutKelasNestedInput
    pesertaKelas?: PesertaKelasUpdateManyWithoutKelasNestedInput
    rps?: RPSUpdateManyWithoutKelasNestedInput
  }

  export type KelasUncheckedUpdateWithoutCpmkInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_kelas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mata_kuliah_id?: IntFieldUpdateOperationsInput | number
    tahun_ajaran_id?: IntFieldUpdateOperationsInput | number
    dosenPengampu?: DosenPengampuUncheckedUpdateManyWithoutKelasNestedInput
    pesertaKelas?: PesertaKelasUncheckedUpdateManyWithoutKelasNestedInput
    rps?: RPSUncheckedUpdateManyWithoutKelasNestedInput
  }

  export type KomponenPenilaianUpsertWithWhereUniqueWithoutCpmkInput = {
    where: KomponenPenilaianWhereUniqueInput
    update: XOR<KomponenPenilaianUpdateWithoutCpmkInput, KomponenPenilaianUncheckedUpdateWithoutCpmkInput>
    create: XOR<KomponenPenilaianCreateWithoutCpmkInput, KomponenPenilaianUncheckedCreateWithoutCpmkInput>
  }

  export type KomponenPenilaianUpdateWithWhereUniqueWithoutCpmkInput = {
    where: KomponenPenilaianWhereUniqueInput
    data: XOR<KomponenPenilaianUpdateWithoutCpmkInput, KomponenPenilaianUncheckedUpdateWithoutCpmkInput>
  }

  export type KomponenPenilaianUpdateManyWithWhereWithoutCpmkInput = {
    where: KomponenPenilaianScalarWhereInput
    data: XOR<KomponenPenilaianUpdateManyMutationInput, KomponenPenilaianUncheckedUpdateManyWithoutCpmkInput>
  }

  export type KomponenPenilaianScalarWhereInput = {
    AND?: KomponenPenilaianScalarWhereInput | KomponenPenilaianScalarWhereInput[]
    OR?: KomponenPenilaianScalarWhereInput[]
    NOT?: KomponenPenilaianScalarWhereInput | KomponenPenilaianScalarWhereInput[]
    id?: IntFilter<"KomponenPenilaian"> | number
    nama?: StringFilter<"KomponenPenilaian"> | string
    bobot?: FloatFilter<"KomponenPenilaian"> | number
    createdAt?: DateTimeFilter<"KomponenPenilaian"> | Date | string
    updatedAt?: DateTimeFilter<"KomponenPenilaian"> | Date | string
    cpmk_id?: IntFilter<"KomponenPenilaian"> | number
  }

  export type CPMK_PI_MapUpsertWithWhereUniqueWithoutCpmkInput = {
    where: CPMK_PI_MapWhereUniqueInput
    update: XOR<CPMK_PI_MapUpdateWithoutCpmkInput, CPMK_PI_MapUncheckedUpdateWithoutCpmkInput>
    create: XOR<CPMK_PI_MapCreateWithoutCpmkInput, CPMK_PI_MapUncheckedCreateWithoutCpmkInput>
  }

  export type CPMK_PI_MapUpdateWithWhereUniqueWithoutCpmkInput = {
    where: CPMK_PI_MapWhereUniqueInput
    data: XOR<CPMK_PI_MapUpdateWithoutCpmkInput, CPMK_PI_MapUncheckedUpdateWithoutCpmkInput>
  }

  export type CPMK_PI_MapUpdateManyWithWhereWithoutCpmkInput = {
    where: CPMK_PI_MapScalarWhereInput
    data: XOR<CPMK_PI_MapUpdateManyMutationInput, CPMK_PI_MapUncheckedUpdateManyWithoutCpmkInput>
  }

  export type CPMKCreateWithoutPiMapInput = {
    kode_cpmk: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kelas: KelasCreateNestedOneWithoutCpmkInput
    komponenPenilaian?: KomponenPenilaianCreateNestedManyWithoutCpmkInput
  }

  export type CPMKUncheckedCreateWithoutPiMapInput = {
    id?: number
    kode_cpmk: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kelas_id: number
    komponenPenilaian?: KomponenPenilaianUncheckedCreateNestedManyWithoutCpmkInput
  }

  export type CPMKCreateOrConnectWithoutPiMapInput = {
    where: CPMKWhereUniqueInput
    create: XOR<CPMKCreateWithoutPiMapInput, CPMKUncheckedCreateWithoutPiMapInput>
  }

  export type PerformanceIndicatorCreateWithoutCpmkMapInput = {
    kode_pi: string
    deskripsi: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    piGroup: PIGroupCreateNestedOneWithoutIndicatorsInput
  }

  export type PerformanceIndicatorUncheckedCreateWithoutCpmkMapInput = {
    id?: number
    kode_pi: string
    deskripsi: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pi_group_id: number
  }

  export type PerformanceIndicatorCreateOrConnectWithoutCpmkMapInput = {
    where: PerformanceIndicatorWhereUniqueInput
    create: XOR<PerformanceIndicatorCreateWithoutCpmkMapInput, PerformanceIndicatorUncheckedCreateWithoutCpmkMapInput>
  }

  export type CPMKUpsertWithoutPiMapInput = {
    update: XOR<CPMKUpdateWithoutPiMapInput, CPMKUncheckedUpdateWithoutPiMapInput>
    create: XOR<CPMKCreateWithoutPiMapInput, CPMKUncheckedCreateWithoutPiMapInput>
    where?: CPMKWhereInput
  }

  export type CPMKUpdateToOneWithWhereWithoutPiMapInput = {
    where?: CPMKWhereInput
    data: XOR<CPMKUpdateWithoutPiMapInput, CPMKUncheckedUpdateWithoutPiMapInput>
  }

  export type CPMKUpdateWithoutPiMapInput = {
    kode_cpmk?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas?: KelasUpdateOneRequiredWithoutCpmkNestedInput
    komponenPenilaian?: KomponenPenilaianUpdateManyWithoutCpmkNestedInput
  }

  export type CPMKUncheckedUpdateWithoutPiMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_cpmk?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas_id?: IntFieldUpdateOperationsInput | number
    komponenPenilaian?: KomponenPenilaianUncheckedUpdateManyWithoutCpmkNestedInput
  }

  export type PerformanceIndicatorUpsertWithoutCpmkMapInput = {
    update: XOR<PerformanceIndicatorUpdateWithoutCpmkMapInput, PerformanceIndicatorUncheckedUpdateWithoutCpmkMapInput>
    create: XOR<PerformanceIndicatorCreateWithoutCpmkMapInput, PerformanceIndicatorUncheckedCreateWithoutCpmkMapInput>
    where?: PerformanceIndicatorWhereInput
  }

  export type PerformanceIndicatorUpdateToOneWithWhereWithoutCpmkMapInput = {
    where?: PerformanceIndicatorWhereInput
    data: XOR<PerformanceIndicatorUpdateWithoutCpmkMapInput, PerformanceIndicatorUncheckedUpdateWithoutCpmkMapInput>
  }

  export type PerformanceIndicatorUpdateWithoutCpmkMapInput = {
    kode_pi?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    piGroup?: PIGroupUpdateOneRequiredWithoutIndicatorsNestedInput
  }

  export type PerformanceIndicatorUncheckedUpdateWithoutCpmkMapInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_pi?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pi_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type CPMKCreateWithoutKomponenPenilaianInput = {
    kode_cpmk: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kelas: KelasCreateNestedOneWithoutCpmkInput
    piMap?: CPMK_PI_MapCreateNestedManyWithoutCpmkInput
  }

  export type CPMKUncheckedCreateWithoutKomponenPenilaianInput = {
    id?: number
    kode_cpmk: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kelas_id: number
    piMap?: CPMK_PI_MapUncheckedCreateNestedManyWithoutCpmkInput
  }

  export type CPMKCreateOrConnectWithoutKomponenPenilaianInput = {
    where: CPMKWhereUniqueInput
    create: XOR<CPMKCreateWithoutKomponenPenilaianInput, CPMKUncheckedCreateWithoutKomponenPenilaianInput>
  }

  export type NilaiCreateWithoutKomponenPenilaianInput = {
    nilai_angka: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pesertaKelas: PesertaKelasCreateNestedOneWithoutNilaiInput
  }

  export type NilaiUncheckedCreateWithoutKomponenPenilaianInput = {
    id?: number
    nilai_angka: number
    createdAt?: Date | string
    updatedAt?: Date | string
    peserta_kelas_id: number
  }

  export type NilaiCreateOrConnectWithoutKomponenPenilaianInput = {
    where: NilaiWhereUniqueInput
    create: XOR<NilaiCreateWithoutKomponenPenilaianInput, NilaiUncheckedCreateWithoutKomponenPenilaianInput>
  }

  export type NilaiCreateManyKomponenPenilaianInputEnvelope = {
    data: NilaiCreateManyKomponenPenilaianInput | NilaiCreateManyKomponenPenilaianInput[]
    skipDuplicates?: boolean
  }

  export type CPMKUpsertWithoutKomponenPenilaianInput = {
    update: XOR<CPMKUpdateWithoutKomponenPenilaianInput, CPMKUncheckedUpdateWithoutKomponenPenilaianInput>
    create: XOR<CPMKCreateWithoutKomponenPenilaianInput, CPMKUncheckedCreateWithoutKomponenPenilaianInput>
    where?: CPMKWhereInput
  }

  export type CPMKUpdateToOneWithWhereWithoutKomponenPenilaianInput = {
    where?: CPMKWhereInput
    data: XOR<CPMKUpdateWithoutKomponenPenilaianInput, CPMKUncheckedUpdateWithoutKomponenPenilaianInput>
  }

  export type CPMKUpdateWithoutKomponenPenilaianInput = {
    kode_cpmk?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas?: KelasUpdateOneRequiredWithoutCpmkNestedInput
    piMap?: CPMK_PI_MapUpdateManyWithoutCpmkNestedInput
  }

  export type CPMKUncheckedUpdateWithoutKomponenPenilaianInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_cpmk?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas_id?: IntFieldUpdateOperationsInput | number
    piMap?: CPMK_PI_MapUncheckedUpdateManyWithoutCpmkNestedInput
  }

  export type NilaiUpsertWithWhereUniqueWithoutKomponenPenilaianInput = {
    where: NilaiWhereUniqueInput
    update: XOR<NilaiUpdateWithoutKomponenPenilaianInput, NilaiUncheckedUpdateWithoutKomponenPenilaianInput>
    create: XOR<NilaiCreateWithoutKomponenPenilaianInput, NilaiUncheckedCreateWithoutKomponenPenilaianInput>
  }

  export type NilaiUpdateWithWhereUniqueWithoutKomponenPenilaianInput = {
    where: NilaiWhereUniqueInput
    data: XOR<NilaiUpdateWithoutKomponenPenilaianInput, NilaiUncheckedUpdateWithoutKomponenPenilaianInput>
  }

  export type NilaiUpdateManyWithWhereWithoutKomponenPenilaianInput = {
    where: NilaiScalarWhereInput
    data: XOR<NilaiUpdateManyMutationInput, NilaiUncheckedUpdateManyWithoutKomponenPenilaianInput>
  }

  export type PesertaKelasCreateWithoutNilaiInput = {
    createdAt?: Date | string
    kelas: KelasCreateNestedOneWithoutPesertaKelasInput
    mahasiswa: UserCreateNestedOneWithoutPesertaKelasInput
  }

  export type PesertaKelasUncheckedCreateWithoutNilaiInput = {
    id?: number
    createdAt?: Date | string
    kelas_id: number
    mahasiswa_id: number
  }

  export type PesertaKelasCreateOrConnectWithoutNilaiInput = {
    where: PesertaKelasWhereUniqueInput
    create: XOR<PesertaKelasCreateWithoutNilaiInput, PesertaKelasUncheckedCreateWithoutNilaiInput>
  }

  export type KomponenPenilaianCreateWithoutNilaiInput = {
    nama: string
    bobot: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cpmk: CPMKCreateNestedOneWithoutKomponenPenilaianInput
  }

  export type KomponenPenilaianUncheckedCreateWithoutNilaiInput = {
    id?: number
    nama: string
    bobot: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cpmk_id: number
  }

  export type KomponenPenilaianCreateOrConnectWithoutNilaiInput = {
    where: KomponenPenilaianWhereUniqueInput
    create: XOR<KomponenPenilaianCreateWithoutNilaiInput, KomponenPenilaianUncheckedCreateWithoutNilaiInput>
  }

  export type PesertaKelasUpsertWithoutNilaiInput = {
    update: XOR<PesertaKelasUpdateWithoutNilaiInput, PesertaKelasUncheckedUpdateWithoutNilaiInput>
    create: XOR<PesertaKelasCreateWithoutNilaiInput, PesertaKelasUncheckedCreateWithoutNilaiInput>
    where?: PesertaKelasWhereInput
  }

  export type PesertaKelasUpdateToOneWithWhereWithoutNilaiInput = {
    where?: PesertaKelasWhereInput
    data: XOR<PesertaKelasUpdateWithoutNilaiInput, PesertaKelasUncheckedUpdateWithoutNilaiInput>
  }

  export type PesertaKelasUpdateWithoutNilaiInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas?: KelasUpdateOneRequiredWithoutPesertaKelasNestedInput
    mahasiswa?: UserUpdateOneRequiredWithoutPesertaKelasNestedInput
  }

  export type PesertaKelasUncheckedUpdateWithoutNilaiInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas_id?: IntFieldUpdateOperationsInput | number
    mahasiswa_id?: IntFieldUpdateOperationsInput | number
  }

  export type KomponenPenilaianUpsertWithoutNilaiInput = {
    update: XOR<KomponenPenilaianUpdateWithoutNilaiInput, KomponenPenilaianUncheckedUpdateWithoutNilaiInput>
    create: XOR<KomponenPenilaianCreateWithoutNilaiInput, KomponenPenilaianUncheckedCreateWithoutNilaiInput>
    where?: KomponenPenilaianWhereInput
  }

  export type KomponenPenilaianUpdateToOneWithWhereWithoutNilaiInput = {
    where?: KomponenPenilaianWhereInput
    data: XOR<KomponenPenilaianUpdateWithoutNilaiInput, KomponenPenilaianUncheckedUpdateWithoutNilaiInput>
  }

  export type KomponenPenilaianUpdateWithoutNilaiInput = {
    nama?: StringFieldUpdateOperationsInput | string
    bobot?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpmk?: CPMKUpdateOneRequiredWithoutKomponenPenilaianNestedInput
  }

  export type KomponenPenilaianUncheckedUpdateWithoutNilaiInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    bobot?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpmk_id?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateManyProgramStudiInput = {
    id?: number
    username: string
    password_hash: string
    nama: string
    role: $Enums.UserRole
  }

  export type KurikulumCreateManyProgramStudiInput = {
    id?: number
    nama: string
    tahun: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutProgramStudiInput = {
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dosenPengampu?: DosenPengampuUpdateManyWithoutDosenNestedInput
    pesertaKelas?: PesertaKelasUpdateManyWithoutMahasiswaNestedInput
  }

  export type UserUncheckedUpdateWithoutProgramStudiInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    dosenPengampu?: DosenPengampuUncheckedUpdateManyWithoutDosenNestedInput
    pesertaKelas?: PesertaKelasUncheckedUpdateManyWithoutMahasiswaNestedInput
  }

  export type UserUncheckedUpdateManyWithoutProgramStudiInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  }

  export type KurikulumUpdateWithoutProgramStudiInput = {
    nama?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mataKuliah?: MataKuliahUpdateManyWithoutKurikulumNestedInput
    cpl?: CPLUpdateManyWithoutKurikulumNestedInput
    piGroups?: PIGroupUpdateManyWithoutKurikulumNestedInput
  }

  export type KurikulumUncheckedUpdateWithoutProgramStudiInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mataKuliah?: MataKuliahUncheckedUpdateManyWithoutKurikulumNestedInput
    cpl?: CPLUncheckedUpdateManyWithoutKurikulumNestedInput
    piGroups?: PIGroupUncheckedUpdateManyWithoutKurikulumNestedInput
  }

  export type KurikulumUncheckedUpdateManyWithoutProgramStudiInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DosenPengampuCreateManyDosenInput = {
    id?: number
    createdAt?: Date | string
    kelas_id: number
  }

  export type PesertaKelasCreateManyMahasiswaInput = {
    id?: number
    createdAt?: Date | string
    kelas_id: number
  }

  export type DosenPengampuUpdateWithoutDosenInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas?: KelasUpdateOneRequiredWithoutDosenPengampuNestedInput
  }

  export type DosenPengampuUncheckedUpdateWithoutDosenInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas_id?: IntFieldUpdateOperationsInput | number
  }

  export type DosenPengampuUncheckedUpdateManyWithoutDosenInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas_id?: IntFieldUpdateOperationsInput | number
  }

  export type PesertaKelasUpdateWithoutMahasiswaInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas?: KelasUpdateOneRequiredWithoutPesertaKelasNestedInput
    nilai?: NilaiUpdateManyWithoutPesertaKelasNestedInput
  }

  export type PesertaKelasUncheckedUpdateWithoutMahasiswaInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas_id?: IntFieldUpdateOperationsInput | number
    nilai?: NilaiUncheckedUpdateManyWithoutPesertaKelasNestedInput
  }

  export type PesertaKelasUncheckedUpdateManyWithoutMahasiswaInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas_id?: IntFieldUpdateOperationsInput | number
  }

  export type MataKuliahCreateManyKurikulumInput = {
    id?: number
    kode_mk: string
    nama: string
    sks: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CPLCreateManyKurikulumInput = {
    id?: number
    kode_cpl: string
    deskripsi: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pi_group_id: number
  }

  export type PIGroupCreateManyKurikulumInput = {
    id?: number
    kode_grup: string
    nama_grup: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MataKuliahUpdateWithoutKurikulumInput = {
    kode_mk?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    sks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas?: KelasUpdateManyWithoutMataKuliahNestedInput
  }

  export type MataKuliahUncheckedUpdateWithoutKurikulumInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_mk?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    sks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kelas?: KelasUncheckedUpdateManyWithoutMataKuliahNestedInput
  }

  export type MataKuliahUncheckedUpdateManyWithoutKurikulumInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_mk?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    sks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CPLUpdateWithoutKurikulumInput = {
    kode_cpl?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    piGroup?: PIGroupUpdateOneRequiredWithoutCplNestedInput
  }

  export type CPLUncheckedUpdateWithoutKurikulumInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_cpl?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pi_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type CPLUncheckedUpdateManyWithoutKurikulumInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_cpl?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pi_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type PIGroupUpdateWithoutKurikulumInput = {
    kode_grup?: StringFieldUpdateOperationsInput | string
    nama_grup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicators?: PerformanceIndicatorUpdateManyWithoutPiGroupNestedInput
    cpl?: CPLUpdateManyWithoutPiGroupNestedInput
  }

  export type PIGroupUncheckedUpdateWithoutKurikulumInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_grup?: StringFieldUpdateOperationsInput | string
    nama_grup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicators?: PerformanceIndicatorUncheckedUpdateManyWithoutPiGroupNestedInput
    cpl?: CPLUncheckedUpdateManyWithoutPiGroupNestedInput
  }

  export type PIGroupUncheckedUpdateManyWithoutKurikulumInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_grup?: StringFieldUpdateOperationsInput | string
    nama_grup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KelasCreateManyMataKuliahInput = {
    id?: number
    nama_kelas: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tahun_ajaran_id: number
  }

  export type KelasUpdateWithoutMataKuliahInput = {
    nama_kelas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tahunAjaran?: TahunAjaranUpdateOneRequiredWithoutKelasNestedInput
    dosenPengampu?: DosenPengampuUpdateManyWithoutKelasNestedInput
    pesertaKelas?: PesertaKelasUpdateManyWithoutKelasNestedInput
    rps?: RPSUpdateManyWithoutKelasNestedInput
    cpmk?: CPMKUpdateManyWithoutKelasNestedInput
  }

  export type KelasUncheckedUpdateWithoutMataKuliahInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_kelas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tahun_ajaran_id?: IntFieldUpdateOperationsInput | number
    dosenPengampu?: DosenPengampuUncheckedUpdateManyWithoutKelasNestedInput
    pesertaKelas?: PesertaKelasUncheckedUpdateManyWithoutKelasNestedInput
    rps?: RPSUncheckedUpdateManyWithoutKelasNestedInput
    cpmk?: CPMKUncheckedUpdateManyWithoutKelasNestedInput
  }

  export type KelasUncheckedUpdateManyWithoutMataKuliahInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_kelas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tahun_ajaran_id?: IntFieldUpdateOperationsInput | number
  }

  export type PerformanceIndicatorCreateManyPiGroupInput = {
    id?: number
    kode_pi: string
    deskripsi: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CPLCreateManyPiGroupInput = {
    id?: number
    kode_cpl: string
    deskripsi: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kurikulum_id: number
  }

  export type PerformanceIndicatorUpdateWithoutPiGroupInput = {
    kode_pi?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpmkMap?: CPMK_PI_MapUpdateManyWithoutPiNestedInput
  }

  export type PerformanceIndicatorUncheckedUpdateWithoutPiGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_pi?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpmkMap?: CPMK_PI_MapUncheckedUpdateManyWithoutPiNestedInput
  }

  export type PerformanceIndicatorUncheckedUpdateManyWithoutPiGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_pi?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CPLUpdateWithoutPiGroupInput = {
    kode_cpl?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kurikulum?: KurikulumUpdateOneRequiredWithoutCplNestedInput
  }

  export type CPLUncheckedUpdateWithoutPiGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_cpl?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kurikulum_id?: IntFieldUpdateOperationsInput | number
  }

  export type CPLUncheckedUpdateManyWithoutPiGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_cpl?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kurikulum_id?: IntFieldUpdateOperationsInput | number
  }

  export type CPMK_PI_MapCreateManyPiInput = {
    cpmk_id: number
  }

  export type CPMK_PI_MapUpdateWithoutPiInput = {
    cpmk?: CPMKUpdateOneRequiredWithoutPiMapNestedInput
  }

  export type CPMK_PI_MapUncheckedUpdateWithoutPiInput = {
    cpmk_id?: IntFieldUpdateOperationsInput | number
  }

  export type CPMK_PI_MapUncheckedUpdateManyWithoutPiInput = {
    cpmk_id?: IntFieldUpdateOperationsInput | number
  }

  export type KelasCreateManyTahunAjaranInput = {
    id?: number
    nama_kelas: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mata_kuliah_id: number
  }

  export type KelasUpdateWithoutTahunAjaranInput = {
    nama_kelas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mataKuliah?: MataKuliahUpdateOneRequiredWithoutKelasNestedInput
    dosenPengampu?: DosenPengampuUpdateManyWithoutKelasNestedInput
    pesertaKelas?: PesertaKelasUpdateManyWithoutKelasNestedInput
    rps?: RPSUpdateManyWithoutKelasNestedInput
    cpmk?: CPMKUpdateManyWithoutKelasNestedInput
  }

  export type KelasUncheckedUpdateWithoutTahunAjaranInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_kelas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mata_kuliah_id?: IntFieldUpdateOperationsInput | number
    dosenPengampu?: DosenPengampuUncheckedUpdateManyWithoutKelasNestedInput
    pesertaKelas?: PesertaKelasUncheckedUpdateManyWithoutKelasNestedInput
    rps?: RPSUncheckedUpdateManyWithoutKelasNestedInput
    cpmk?: CPMKUncheckedUpdateManyWithoutKelasNestedInput
  }

  export type KelasUncheckedUpdateManyWithoutTahunAjaranInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_kelas?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mata_kuliah_id?: IntFieldUpdateOperationsInput | number
  }

  export type DosenPengampuCreateManyKelasInput = {
    id?: number
    createdAt?: Date | string
    dosen_id: number
  }

  export type PesertaKelasCreateManyKelasInput = {
    id?: number
    createdAt?: Date | string
    mahasiswa_id: number
  }

  export type RPSCreateManyKelasInput = {
    id?: number
    file_path: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CPMKCreateManyKelasInput = {
    id?: number
    kode_cpmk: string
    is_locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DosenPengampuUpdateWithoutKelasInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dosen?: UserUpdateOneRequiredWithoutDosenPengampuNestedInput
  }

  export type DosenPengampuUncheckedUpdateWithoutKelasInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dosen_id?: IntFieldUpdateOperationsInput | number
  }

  export type DosenPengampuUncheckedUpdateManyWithoutKelasInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dosen_id?: IntFieldUpdateOperationsInput | number
  }

  export type PesertaKelasUpdateWithoutKelasInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mahasiswa?: UserUpdateOneRequiredWithoutPesertaKelasNestedInput
    nilai?: NilaiUpdateManyWithoutPesertaKelasNestedInput
  }

  export type PesertaKelasUncheckedUpdateWithoutKelasInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mahasiswa_id?: IntFieldUpdateOperationsInput | number
    nilai?: NilaiUncheckedUpdateManyWithoutPesertaKelasNestedInput
  }

  export type PesertaKelasUncheckedUpdateManyWithoutKelasInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mahasiswa_id?: IntFieldUpdateOperationsInput | number
  }

  export type RPSUpdateWithoutKelasInput = {
    file_path?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RPSUncheckedUpdateWithoutKelasInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_path?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RPSUncheckedUpdateManyWithoutKelasInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_path?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CPMKUpdateWithoutKelasInput = {
    kode_cpmk?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    komponenPenilaian?: KomponenPenilaianUpdateManyWithoutCpmkNestedInput
    piMap?: CPMK_PI_MapUpdateManyWithoutCpmkNestedInput
  }

  export type CPMKUncheckedUpdateWithoutKelasInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_cpmk?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    komponenPenilaian?: KomponenPenilaianUncheckedUpdateManyWithoutCpmkNestedInput
    piMap?: CPMK_PI_MapUncheckedUpdateManyWithoutCpmkNestedInput
  }

  export type CPMKUncheckedUpdateManyWithoutKelasInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode_cpmk?: StringFieldUpdateOperationsInput | string
    is_locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NilaiCreateManyPesertaKelasInput = {
    id?: number
    nilai_angka: number
    createdAt?: Date | string
    updatedAt?: Date | string
    komponen_penilaian_id: number
  }

  export type NilaiUpdateWithoutPesertaKelasInput = {
    nilai_angka?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    komponenPenilaian?: KomponenPenilaianUpdateOneRequiredWithoutNilaiNestedInput
  }

  export type NilaiUncheckedUpdateWithoutPesertaKelasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nilai_angka?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    komponen_penilaian_id?: IntFieldUpdateOperationsInput | number
  }

  export type NilaiUncheckedUpdateManyWithoutPesertaKelasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nilai_angka?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    komponen_penilaian_id?: IntFieldUpdateOperationsInput | number
  }

  export type KomponenPenilaianCreateManyCpmkInput = {
    id?: number
    nama: string
    bobot: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CPMK_PI_MapCreateManyCpmkInput = {
    pi_id: number
  }

  export type KomponenPenilaianUpdateWithoutCpmkInput = {
    nama?: StringFieldUpdateOperationsInput | string
    bobot?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nilai?: NilaiUpdateManyWithoutKomponenPenilaianNestedInput
  }

  export type KomponenPenilaianUncheckedUpdateWithoutCpmkInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    bobot?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nilai?: NilaiUncheckedUpdateManyWithoutKomponenPenilaianNestedInput
  }

  export type KomponenPenilaianUncheckedUpdateManyWithoutCpmkInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    bobot?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CPMK_PI_MapUpdateWithoutCpmkInput = {
    pi?: PerformanceIndicatorUpdateOneRequiredWithoutCpmkMapNestedInput
  }

  export type CPMK_PI_MapUncheckedUpdateWithoutCpmkInput = {
    pi_id?: IntFieldUpdateOperationsInput | number
  }

  export type CPMK_PI_MapUncheckedUpdateManyWithoutCpmkInput = {
    pi_id?: IntFieldUpdateOperationsInput | number
  }

  export type NilaiCreateManyKomponenPenilaianInput = {
    id?: number
    nilai_angka: number
    createdAt?: Date | string
    updatedAt?: Date | string
    peserta_kelas_id: number
  }

  export type NilaiUpdateWithoutKomponenPenilaianInput = {
    nilai_angka?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pesertaKelas?: PesertaKelasUpdateOneRequiredWithoutNilaiNestedInput
  }

  export type NilaiUncheckedUpdateWithoutKomponenPenilaianInput = {
    id?: IntFieldUpdateOperationsInput | number
    nilai_angka?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    peserta_kelas_id?: IntFieldUpdateOperationsInput | number
  }

  export type NilaiUncheckedUpdateManyWithoutKomponenPenilaianInput = {
    id?: IntFieldUpdateOperationsInput | number
    nilai_angka?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    peserta_kelas_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}